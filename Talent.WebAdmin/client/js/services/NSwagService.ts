/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.1.5.0 (NJsonSchema v10.0.27.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming
import { GetAccountsQueryModel } from '../models/DashboardGuestAccount'
import { queryToString } from './helper';

export class ContentService {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @return Success
     */
    getPaginate(filter: ApprovalContentFilterModel | null | undefined): Promise<ResponseApprovalContentModel> {
        let url_ = this.baseUrl + "/api/approval/content/get-paginate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(filter);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetPaginate(_response);
        });
    }

    protected processGetPaginate(response: Response): Promise<ResponseApprovalContentModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ResponseApprovalContentModel>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ResponseApprovalContentModel>(<any>null);
    }

    /**
     * @return Success
     */
    changeStatus(id: number, type: string): Promise<boolean> {
        let url_ = this.baseUrl + "/api/approval/content/change-status/{id}/{type}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        if (type === undefined || type === null)
            throw new Error("The parameter 'type' must be defined.");
        url_ = url_.replace("{type}", encodeURIComponent("" + type)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processChangeStatus(_response);
        });
    }

    protected processChangeStatus(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <boolean>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(<any>null);
    }

    /**
     * @param model (optional) 
     * @return Success
     */
    rejectApprovalInbox(model: InboxRejectedModel | null | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/approval/content/reject-approval-inbox";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRejectApprovalInbox(_response);
        });
    }

    protected processRejectApprovalInbox(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <boolean>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(<any>null);
    }

    /**
     * @return Success
     */
    acceptApprovalInbox(approvalId: number, inboxId: number): Promise<boolean> {
        let url_ = this.baseUrl + "/api/approval/content/accept-approval-inbox/{approvalId}/{inboxId}";
        if (approvalId === undefined || approvalId === null)
            throw new Error("The parameter 'approvalId' must be defined.");
        url_ = url_.replace("{approvalId}", encodeURIComponent("" + approvalId)); 
        if (inboxId === undefined || inboxId === null)
            throw new Error("The parameter 'inboxId' must be defined.");
        url_ = url_.replace("{inboxId}", encodeURIComponent("" + inboxId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAcceptApprovalInbox(_response);
        });
    }

    protected processAcceptApprovalInbox(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <boolean>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(<any>null);
    }
}

export class ApprovalMappingService {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param level (optional) 
     * @param pageName (optional) 
     * @param positionName (optional) 
     * @param sortBy (optional) 
     * @param pageNumber (optional) 
     * @return Success
     */
    getApprovalMappingFiltered(startDate: Date | null | undefined, endDate: Date | null | undefined, level: number | null | undefined, pageName: string | null | undefined, positionName: string | null | undefined, sortBy: string | null | undefined, pageNumber: number | null | undefined): Promise<ApprovalMappingViewModel> {
        let url_ = this.baseUrl + "/api/v1/approval-mapping/get-approval-mapping-filtered?";
        if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        if (level !== undefined)
            url_ += "Level=" + encodeURIComponent("" + level) + "&"; 
        if (pageName !== undefined)
            url_ += "PageName=" + encodeURIComponent("" + pageName) + "&"; 
        if (positionName !== undefined)
            url_ += "PositionName=" + encodeURIComponent("" + positionName) + "&"; 
        if (sortBy !== undefined)
            url_ += "SortBy=" + encodeURIComponent("" + sortBy) + "&"; 
        if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetApprovalMappingFiltered(_response);
        });
    }

    protected processGetApprovalMappingFiltered(response: Response): Promise<ApprovalMappingViewModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ApprovalMappingViewModel>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApprovalMappingViewModel>(<any>null);
    }

    /**
     * @param model (optional) 
     * @return Success
     */
    insertApprovalMappings(model: ApprovalMappingFormModel | null | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/v1/approval-mapping/insert-approval-mappings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processInsertApprovalMappings(_response);
        });
    }

    protected processInsertApprovalMappings(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <boolean>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(<any>null);
    }

    /**
     * @return Success
     */
    deleteApprovalMappings(id: number): Promise<boolean> {
        let url_ = this.baseUrl + "/api/v1/approval-mapping/delete-approval-mappings/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteApprovalMappings(_response);
        });
    }

    protected processDeleteApprovalMappings(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <boolean>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(<any>null);
    }

    /**
     * @param model (optional) 
     * @return Success
     */
    updateApprovalMappings(model: ApprovalMappingFormModel | null | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/v1/approval-mapping/update-approval-mappings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateApprovalMappings(_response);
        });
    }

    protected processUpdateApprovalMappings(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <boolean>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(<any>null);
    }

    /**
     * @return Success
     */
    getAllPages(): Promise<PagesModel[]> {
        let url_ = this.baseUrl + "/api/v1/approval-mapping/get-all-pages";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllPages(_response);
        });
    }

    protected processGetAllPages(response: Response): Promise<PagesModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <PagesModel[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PagesModel[]>(<any>null);
    }

    /**
     * @return Success
     */
    getAllApprovalLevel(): Promise<ApprovalLevelModel[]> {
        let url_ = this.baseUrl + "/api/v1/approval-mapping/get-all-approval-level";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllApprovalLevel(_response);
        });
    }

    protected processGetAllApprovalLevel(response: Response): Promise<ApprovalLevelModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ApprovalLevelModel[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApprovalLevelModel[]>(<any>null);
    }

    /**
     * @return Success
     */
    getUninsertedPage(): Promise<PagesModel[]> {
        let url_ = this.baseUrl + "/api/v1/approval-mapping/get-uninserted-page";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetUninsertedPage(_response);
        });
    }

    protected processGetUninsertedPage(response: Response): Promise<PagesModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <PagesModel[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PagesModel[]>(<any>null);
    }
}

export class ApprovalStatusService {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllApprovalStatuses(): Promise<ApprovalStatusViewModel> {
        let url_ = this.baseUrl + "/api/v1/approval-status/get-all-approval-statuses";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllApprovalStatuses(_response);
        });
    }

    protected processGetAllApprovalStatuses(response: Response): Promise<ApprovalStatusViewModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ApprovalStatusViewModel>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApprovalStatusViewModel>(<any>null);
    }

    /**
     * @return Success
     */
    getApprovalStatusById(id: number): Promise<ApprovalStatusModel> {
        let url_ = this.baseUrl + "/api/v1/approval-status/get-approval-status-by-id/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetApprovalStatusById(_response);
        });
    }

    protected processGetApprovalStatusById(response: Response): Promise<ApprovalStatusModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ApprovalStatusModel>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApprovalStatusModel>(<any>null);
    }
}

export class ApprovalTrainingService {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param courseName (optional) 
     * @param programTypeName (optional) 
     * @param batch (optional) 
     * @param enrolment (optional) 
     * @param quota (optional) 
     * @param sortBy (optional) 
     * @param pageNumber (optional) 
     * @return Success
     */
    getApprovalTraining(startDate: Date | null | undefined, endDate: Date | null | undefined, courseName: string | null | undefined, programTypeName: string | null | undefined, batch: number | null | undefined, enrolment: number | null | undefined, quota: number | null | undefined, sortBy: string | null | undefined, pageNumber: number | null | undefined): Promise<ApprovalTrainingViewModel> {
        let url_ = this.baseUrl + "/api/v1/approval-training/get-approval-training?";
        if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        if (courseName !== undefined)
            url_ += "CourseName=" + encodeURIComponent("" + courseName) + "&"; 
        if (programTypeName !== undefined)
            url_ += "ProgramTypeName=" + encodeURIComponent("" + programTypeName) + "&"; 
        if (batch !== undefined)
            url_ += "Batch=" + encodeURIComponent("" + batch) + "&"; 
        if (enrolment !== undefined)
            url_ += "Enrolment=" + encodeURIComponent("" + enrolment) + "&"; 
        if (quota !== undefined)
            url_ += "Quota=" + encodeURIComponent("" + quota) + "&"; 
        if (sortBy !== undefined)
            url_ += "SortBy=" + encodeURIComponent("" + sortBy) + "&"; 
        if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetApprovalTraining(_response);
        });
    }

    protected processGetApprovalTraining(response: Response): Promise<ApprovalTrainingViewModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ApprovalTrainingViewModel>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApprovalTrainingViewModel>(<any>null);
    }

    /**
     * @return Success
     */
    getApprovalTrainingById(id: number): Promise<ApprovalTrainingDetailViewModel> {
        let url_ = this.baseUrl + "/api/v1/approval-training/get-approval-training-by-id/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetApprovalTrainingById(_response);
        });
    }

    protected processGetApprovalTrainingById(response: Response): Promise<ApprovalTrainingDetailViewModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ApprovalTrainingDetailViewModel>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApprovalTrainingDetailViewModel>(<any>null);
    }

    /**
     * @param model (optional) 
     * @return Success
     */
    saveApprovalTraining(model: ApprovalTrainingEmployee[] | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/v1/approval-training/save-approval-training";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSaveApprovalTraining(_response);
        });
    }

    protected processSaveApprovalTraining(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param model (optional) 
     * @return Success
     */
    sendInvitation(model: TrainingInvitationModel | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/v1/approval-training/send-invitation-new";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSendInvitation(_response);
        });
    }

    protected processSendInvitation(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }
}

export class AssessmentService {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param dateStart (optional) 
     * @param dateEnd (optional) 
     * @param outletName (optional) 
     * @param assessmentName (optional) 
     * @param positionName (optional) 
     * @param employeeName (optional) 
     * @param publisherName (optional) 
     * @param sortBy (optional) 
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    getAllAssessment(dateStart: Date | null | undefined, dateEnd: Date | null | undefined, outletName: string | null | undefined, assessmentName: string | null | undefined, positionName: string | null | undefined, employeeName: string | null | undefined, publisherName: string | null | undefined, sortBy: string | null | undefined, pageIndex: number | null | undefined, pageSize: number | null | undefined): Promise<AssessmentGridModel> {
        let url_ = this.baseUrl + "/api/v1/assessment/get-all-assessment?";
        if (dateStart !== undefined)
            url_ += "DateStart=" + encodeURIComponent(dateStart ? "" + dateStart.toJSON() : "") + "&"; 
        if (dateEnd !== undefined)
            url_ += "DateEnd=" + encodeURIComponent(dateEnd ? "" + dateEnd.toJSON() : "") + "&"; 
        if (outletName !== undefined)
            url_ += "OutletName=" + encodeURIComponent("" + outletName) + "&"; 
        if (assessmentName !== undefined)
            url_ += "AssessmentName=" + encodeURIComponent("" + assessmentName) + "&"; 
        if (positionName !== undefined)
            url_ += "PositionName=" + encodeURIComponent("" + positionName) + "&"; 
        if (employeeName !== undefined)
            url_ += "EmployeeName=" + encodeURIComponent("" + employeeName) + "&"; 
        if (publisherName !== undefined)
            url_ += "PublisherName=" + encodeURIComponent("" + publisherName) + "&"; 
        if (sortBy !== undefined)
            url_ += "SortBy=" + encodeURIComponent("" + sortBy) + "&"; 
        if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&"; 
        if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllAssessment(_response);
        });
    }

    protected processGetAllAssessment(response: Response): Promise<AssessmentGridModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <AssessmentGridModel>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AssessmentGridModel>(<any>null);
    }

    /**
     * @param model (optional) 
     * @return Success
     */
    insertAssessment(model: AssessmentCreateModel | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/v1/assessment/insert-assessment";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processInsertAssessment(_response);
        });
    }

    protected processInsertAssessment(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param assessmentId (optional) 
     * @return Success
     */
    getAssessmentById(assessmentId: number | null | undefined): Promise<AssessmentViewDetailModel> {
        let url_ = this.baseUrl + "/api/v1/assessment/get-assessment-by-id?";
        if (assessmentId !== undefined)
            url_ += "assessmentId=" + encodeURIComponent("" + assessmentId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAssessmentById(_response);
        });
    }

    protected processGetAssessmentById(response: Response): Promise<AssessmentViewDetailModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <AssessmentViewDetailModel>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AssessmentViewDetailModel>(<any>null);
    }

    /**
     * @param model (optional) 
     * @return Success
     */
    updateAssessment(model: AssessmentUpdateModel | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/v1/assessment/update-assessment";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateAssessment(_response);
        });
    }

    protected processUpdateAssessment(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param assessmentId (optional) 
     * @return Success
     */
    deleteAssessment(assessmentId: number | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/v1/assessment/delete-assessment?";
        if (assessmentId !== undefined)
            url_ += "assessmentId=" + encodeURIComponent("" + assessmentId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteAssessment(_response);
        });
    }

    protected processDeleteAssessment(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }
}

export class BannerService {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param dateFilterStart (optional) 
     * @param dateFilterEnd (optional) 
     * @param bannerTypeId (optional) 
     * @param name (optional) 
     * @param approvalStatus (optional) 
     * @param actionBy (optional) 
     * @param sortBy (optional) 
     * @param pageNumber (optional) 
     * @return Success
     */
    getBannerFiltered(startDate: Date | null | undefined, endDate: Date | null | undefined, dateFilterStart: Date | null | undefined, dateFilterEnd: Date | null | undefined, bannerTypeId: number | null | undefined, name: string | null | undefined, approvalStatus: string | null | undefined, actionBy: string | null | undefined, sortBy: string | null | undefined, pageNumber: number | null | undefined): Promise<BannerViewModel> {
        let url_ = this.baseUrl + "/api/v1/banner/get-banner-filtered?";
        if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        if (dateFilterStart !== undefined)
            url_ += "DateFilterStart=" + encodeURIComponent(dateFilterStart ? "" + dateFilterStart.toJSON() : "") + "&"; 
        if (dateFilterEnd !== undefined)
            url_ += "DateFilterEnd=" + encodeURIComponent(dateFilterEnd ? "" + dateFilterEnd.toJSON() : "") + "&"; 
        if (bannerTypeId !== undefined)
            url_ += "BannerTypeId=" + encodeURIComponent("" + bannerTypeId) + "&"; 
        if (name !== undefined)
            url_ += "Name=" + encodeURIComponent("" + name) + "&"; 
        if (approvalStatus !== undefined)
            url_ += "ApprovalStatus=" + encodeURIComponent("" + approvalStatus) + "&"; 
        if (actionBy !== undefined)
            url_ += "ActionBy=" + encodeURIComponent("" + actionBy) + "&"; 
        if (sortBy !== undefined)
            url_ += "SortBy=" + encodeURIComponent("" + sortBy) + "&"; 
        if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetBannerFiltered(_response);
        });
    }

    protected processGetBannerFiltered(response: Response): Promise<BannerViewModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <BannerViewModel>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BannerViewModel>(<any>null);
    }

    /**
     * @param model (optional) 
     * @return Success
     */
    insertBanner(model: BannerFormModel | null | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/v1/banner/insert-banner";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processInsertBanner(_response);
        });
    }

    protected processInsertBanner(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <boolean>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(<any>null);
    }

    /**
     * @return Success
     */
    deleteBanner(id: number): Promise<boolean> {
        let url_ = this.baseUrl + "/api/v1/banner/delete-banner/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteBanner(_response);
        });
    }

    protected processDeleteBanner(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <boolean>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(<any>null);
    }

    /**
     * @return Success
     */
    getBannerById(id: number): Promise<BannerFormModel> {
        let url_ = this.baseUrl + "/api/v1/banner/get-banner-by-id/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetBannerById(_response);
        });
    }

    protected processGetBannerById(response: Response): Promise<BannerFormModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <BannerFormModel>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BannerFormModel>(<any>null);
    }

    /**
     * @return Success
     */
    getBannerByIdFromOutside(id: number): Promise<BannerViewModel> {
        let url_ = this.baseUrl + "/api/v1/banner/get-banner-by-id-from-outside/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetBannerByIdFromOutside(_response);
        });
    }

    protected processGetBannerByIdFromOutside(response: Response): Promise<BannerViewModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <BannerViewModel>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BannerViewModel>(<any>null);
    }

    /**
     * @return Success
     */
    getAllContentType(): Promise<MobileMappingPage[]> {
        let url_ = this.baseUrl + "/api/v1/banner/get-all-content-type";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllContentType(_response);
        });
    }

    protected processGetAllContentType(response: Response): Promise<MobileMappingPage[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <MobileMappingPage[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<MobileMappingPage[]>(<any>null);
    }

    /**
     * @param typeContent (optional) 
     * @param name (optional) 
     * @return Success
     */
    getContentName(typeContent: number | null | undefined, name: string | null | undefined): Promise<ContentModel[]> {
        let url_ = this.baseUrl + "/api/v1/banner/get-content-name?";
        if (typeContent !== undefined)
            url_ += "TypeContent=" + encodeURIComponent("" + typeContent) + "&"; 
        if (name !== undefined)
            url_ += "Name=" + encodeURIComponent("" + name) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetContentName(_response);
        });
    }

    protected processGetContentName(response: Response): Promise<ContentModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ContentModel[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ContentModel[]>(<any>null);
    }

    /**
     * @param typeContent (optional) 
     * @param contentId (optional) 
     * @return Success
     */
    getContentNameById(typeContent: number | null | undefined, contentId: number | null | undefined): Promise<ContentModel> {
        let url_ = this.baseUrl + "/api/v1/banner/get-content-name-by-id?";
        if (typeContent !== undefined)
            url_ += "TypeContent=" + encodeURIComponent("" + typeContent) + "&"; 
        if (contentId !== undefined)
            url_ += "ContentId=" + encodeURIComponent("" + contentId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetContentNameById(_response);
        });
    }

    protected processGetContentNameById(response: Response): Promise<ContentModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ContentModel>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ContentModel>(<any>null);
    }

    /**
     * @param model (optional) 
     * @return Success
     */
    updateBanner(model: BannerFormModel | null | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/v1/banner/update-banner";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateBanner(_response);
        });
    }

    protected processUpdateBanner(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <boolean>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(<any>null);
    }

    /**
     * @return Success
     */
    getApprovalStatusForBanner(): Promise<ApprovalStatusForBannerModel[]> {
        let url_ = this.baseUrl + "/api/v1/banner/get-approval-status-for-banner";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetApprovalStatusForBanner(_response);
        });
    }

    protected processGetApprovalStatusForBanner(response: Response): Promise<ApprovalStatusForBannerModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ApprovalStatusForBannerModel[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApprovalStatusForBannerModel[]>(<any>null);
    }
}

export class BlobFileService {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param model (optional) 
     * @return Success
     */
    insertBlobFile(model: any): Promise<any> {
        let url_ = this.baseUrl + "/api/v1/blob/upload-filecontent";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processBlobFile(_response);
        });
    }

    protected processBlobFile(response: Response): Promise<any> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <any>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<any>(<any>null);
    }
}

export class LandingPageService {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param id (optional)
     * @return Success
     */
    getLandingPages(id?: String): Promise<LandingPageViewModel> {
        let url_ = this.baseUrl + "/api/v1/onboarding/data?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent(id ? "" + id : "");
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetLandingPages(_response);
        });
    }

    protected processGetLandingPages(response: Response): Promise<LandingPageViewModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <LandingPageViewModel>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<LandingPageViewModel>(<any>null);
    }

    /**
     * @param model (optional) 
     * @return Success
     */
    insertLandingPage(model: any): Promise<any> {
        let url_ = this.baseUrl + "/api/v1/onboarding/data";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processInsertLandingPage(_response);
        });
    }

    protected processInsertLandingPage(response: Response): Promise<any> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <any>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<any>(<any>null);
    }

    /**
     * @param model (optional) 
     * @return Success
     */
    updateLandingPage(model: any): Promise<any> {
        let url_ = this.baseUrl + "/api/v1/onboarding/data";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateLandingPage(_response);
        });
    }

    protected processUpdateLandingPage(response: Response): Promise<any> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <any>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<any>(<any>null);
    }

    /**
     * @param model (optional) 
     * @return Success
     */
    updateLandingPages(model: any): Promise<any> {
        let url_ = this.baseUrl + "/api/v1/onboarding/order";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateLandingPages(_response);
        });
    }

    protected processUpdateLandingPages(response: Response): Promise<any> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <any>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<any>(<any>null);
    }

    /**
     * @param model (optional) 
     * @return Success
     */
    deleteLandingPage(id: any): Promise<any> {
        let url_ = this.baseUrl + `/api/v1/onboarding/data?id=${id}`;
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteLandingPage(_response);
        });
    }

    protected processDeleteLandingPage(response: Response): Promise<any> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <any>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<any>(<any>null);
    }
}

export class DashboardGuestAccountService {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param id (optional)
     * @return Success
     */
    getChartSummary(id?: String): Promise<any> {
        let url_ = this.baseUrl + `/api/v1/guest-account-data/user-summary?`;
        if (id !== undefined && id !== '')
            url_ += "dealerId=" + encodeURIComponent(id ? "" + id : "");
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetChartSummary(_response);
        });
    }

    protected processGetChartSummary(response: Response): Promise<any> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                result200 = _responseText === "" ? null : <any>JSON.parse(_responseText, this.jsonParseReviver);
                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<any>(<any>null);
    }

    /**
     * @param id (optional)
     * @return Success
     */
     getAccounts(params: GetAccountsQueryModel): Promise<any> {
        const query = queryToString(params);
        let url_ = this.baseUrl + `/api/v1/guest-account-data/get-list-guest?${query}`
        // if (id !== undefined)
        //     url_ += "id=" + encodeURIComponent(id ? "" + id : "");
        // url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAccounts(_response);
        });
    }

    protected processGetAccounts(response: Response): Promise<any> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                result200 = _responseText === "" ? null : <any>JSON.parse(_responseText, this.jsonParseReviver);
                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<any>(<any>null);
    }

    exportAccounts(params: GetAccountsQueryModel): Promise<any> {
        const query = queryToString(params);
        let url_ = this.baseUrl + `/api/v1/guest-account-data/export-list-guest?${query}`
        // if (id !== undefined)
        //     url_ += "id=" + encodeURIComponent(id ? "" + id : "");
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processExportAccounts(_response);
        });
    }

    protected processExportAccounts(response: Response): Promise<any> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.blob().then((blob) => {
                return blob;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<any>(<any>null);
    }

    getSummaryDealer(id?: any): Promise<any> {
        let url_ = this.baseUrl + `/api/v1/guest-account-data/user-summary-dealer?${id ? "" + id : ""}`;
        url_ = url_.replace(/,/g, '');

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetSummaryDealer(_response);
        });
    }

    protected processGetSummaryDealer(response: Response): Promise<any> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                result200 = _responseText === "" ? null : <any>JSON.parse(_responseText, this.jsonParseReviver);
                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<any>(<any>null);
    }

    /**
     * @param id (optional)
     * @return Success
     */
    getSummaryOthers(id?: String): Promise<any> {
        let url_ = this.baseUrl + `/api/v1/guest-account-data/user-summary-other?${id ? "" + id : ""}`;
        url_ = url_.replace(/,/g, '');

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetSummaryOthers(_response);
        });
    }

    protected processGetSummaryOthers(response: Response): Promise<any> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                result200 = _responseText === "" ? null : <any>JSON.parse(_responseText, this.jsonParseReviver);
                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<any>(<any>null);
    }

    getSummaryOutlet(id?: String, dealerId?: String): Promise<any> {
        let url_ = this.baseUrl + `/api/v1/guest-account-data/user-summary-outlet?dealerId=${dealerId}&${id ? "" + id : ""}`;
        url_ = url_.replace(/,/g, '');

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetSummaryOutlet(_response);
        });
    }

    protected processGetSummaryOutlet(response: Response): Promise<any> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                result200 = _responseText === "" ? null : <any>JSON.parse(_responseText, this.jsonParseReviver);
                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<any>(<any>null);
    }

    /**
     * @param id (optional)
     * @return Success
     */
    updateAccountStatus(body: any): Promise<any> {
        let url_ = this.baseUrl + "/api/v1/guest-account-data/update-status";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateAccountStatus(_response);
        });
    }

    protected processUpdateAccountStatus(response: Response): Promise<any> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                result200 = _responseText === "" ? null : <any>JSON.parse(_responseText, this.jsonParseReviver);
                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<any>(<any>null);
    }

    updateAccount(body: any): Promise<any> {
        let url_ = this.baseUrl + "/api/v1/guest-account-data/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateAccount(_response);
        });
    }

    protected processUpdateAccount(response: Response): Promise<any> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                result200 = _responseText === "" ? null : <any>JSON.parse(_responseText, this.jsonParseReviver);
                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<any>(<any>null);
    }
}


export class PushNotificationService {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param id (optional)
     * @return Success
     */
    getPushNotifications(params: any): Promise<any> {
        const query = queryToString(params);
        let url_ = this.baseUrl + `/api/push-notifications/get-push-notifications?${query}`;
        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetPushNotifications(_response);
        });
    }

    protected processGetPushNotifications(response: Response): Promise<any> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                result200 = _responseText === "" ? null : <any>JSON.parse(_responseText, this.jsonParseReviver);
                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<any>(<any>null);
    }

    insertPushNotification(body: any): Promise<any> {
        let url_ = this.baseUrl + `/api/push-notifications/create-push-notifications`;
        const content_ = JSON.stringify(body);
        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Accept": "application/json",
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processInsertPushNotification(_response);
        });
    }

    protected processInsertPushNotification(response: Response): Promise<any> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                result200 = _responseText === "" ? null : <any>JSON.parse(_responseText, this.jsonParseReviver);
                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<any>(<any>null);
    }

    updatePushNotification(body: any): Promise<any> {
        let url_ = this.baseUrl + `/api/push-notifications/update-push-notifications`;
        const content_ = JSON.stringify(body);
        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Accept": "application/json",
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdatePushNotification(_response);
        });
    }

    protected processUpdatePushNotification(response: Response): Promise<any> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                result200 = _responseText === "" ? null : <any>JSON.parse(_responseText, this.jsonParseReviver);
                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<any>(<any>null);
    }

    /**
     * @param id (optional)
     * @return Success
     */
    deleteAnnouncement(id?: String): Promise<any> {
        let url_ = this.baseUrl + `/api/push-notifications/delete-push-notifications?id=${id}`;
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: Response): Promise<any> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <any>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<any>(<any>null);
    }
}

export class UsersideProfileService {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param id (optional)
     * @return Success
     */
    getProfilAccount(id?: String): Promise<any> {
        let url_ = this.baseUrl + `/api/v1/userside-profile/get-profile/${id}`;
        // if (id !== undefined)
        //     url_ += "id=" + encodeURIComponent(id ? "" + id : "");
        // url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetProfileAccount(_response);
        });
    }

    protected processGetProfileAccount(response: Response): Promise<any> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                result200 = _responseText === "" ? null : <any>JSON.parse(_responseText, this.jsonParseReviver);
                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<any>(<any>null);
    }
}

export class AnnouncementService {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param id (optional)
     * @return Success
     */
    getAnnouncements(id?: String): Promise<any> {
        let url_ = this.baseUrl + "/api/v1/announcement/data?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent(id ? "" + id : "");
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAnnouncements(_response);
        });
    }

    protected processGetAnnouncements(response: Response): Promise<any> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <any>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<any>(<any>null);
    }

    /**
     * @param id (optional)
     * @return Success
     */
    deleteAnnouncement(id?: String): Promise<any> {
        let url_ = this.baseUrl + `/api/v1/announcement/data?id=${id}`;
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteAnnouncement(_response);
        });
    }

    protected processDeleteAnnouncement(response: Response): Promise<any> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <any>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<any>(<any>null);
    }

    /**
     * @param model (optional) 
     * @return Success
     */
    insertAnnouncement(model: any): Promise<any> {
        let url_ = this.baseUrl + "/api/v1/announcement/data";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processInsertAnnouncement(_response);
        });
    }

    protected processInsertAnnouncement(response: Response): Promise<any> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <any>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<any>(<any>null);
    }

    /**
     * @param model (optional) 
     * @return Success
     */
    updateAnnouncement(model: any): Promise<any> {
        let url_ = this.baseUrl + "/api/v1/announcement/data";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateAnnouncement(_response);
        });
    }

    protected processUpdateAnnouncement(response: Response): Promise<any> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <any>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<any>(<any>null);
    }
}

export class BlobService {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param file (optional) 
     * @return Success
     */
    uploadFile(file: any[] | null | undefined): Promise<string> {
        let url_ = this.baseUrl + "/api/v1/blob/upload-file";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file !== null && file !== undefined)
            content_.append("file", file.toString());

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUploadFile(_response);
        });
    }

    protected processUploadFile(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <string>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(<any>null);
    }

    /**
     * @param file (optional) 
     * @return Success
     */
    uploadFilecontent(file: FileContent | null | undefined): Promise<string> {
        let url_ = this.baseUrl + "/api/v1/blob/upload-filecontent";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(file);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUploadFilecontent(_response);
        });
    }

    protected processUploadFilecontent(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <string>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(<any>null);
    }

    /**
     * @param files (optional) 
     * @return Success
     */
    uploadFilecontentList(files: FileContent[] | null | undefined): Promise<string[]> {
        let url_ = this.baseUrl + "/api/v1/blob/upload-filecontent-list";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(files);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUploadFilecontentList(_response);
        });
    }

    protected processUploadFilecontentList(response: Response): Promise<string[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <string[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string[]>(<any>null);
    }

    /**
     * @return Success
     */
    getImageUrl(fileName: string, fileExtension: string): Promise<string> {
        let url_ = this.baseUrl + "/api/v1/blob/get-image-url/{fileName}/{fileExtension}";
        if (fileName === undefined || fileName === null)
            throw new Error("The parameter 'fileName' must be defined.");
        url_ = url_.replace("{fileName}", encodeURIComponent("" + fileName)); 
        if (fileExtension === undefined || fileExtension === null)
            throw new Error("The parameter 'fileExtension' must be defined.");
        url_ = url_.replace("{fileExtension}", encodeURIComponent("" + fileExtension)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetImageUrl(_response);
        });
    }

    protected processGetImageUrl(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <string>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(<any>null);
    }

    /**
     * @return Success
     */
    getImageDetail(id: string): Promise<FileModel> {
        let url_ = this.baseUrl + "/api/v1/blob/get-image-detail/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetImageDetail(_response);
        });
    }

    protected processGetImageDetail(response: Response): Promise<FileModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <FileModel>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileModel>(<any>null);
    }

    /**
     * @return Success
     */
    getBlobById(id: string): Promise<BlobModel> {
        let url_ = this.baseUrl + "/api/v1/blob/get-blob-by-id/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetBlobById(_response);
        });
    }

    protected processGetBlobById(response: Response): Promise<BlobModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <BlobModel>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BlobModel>(<any>null);
    }

    /**
     * @return Success
     */
    deleteFile(fileName: string, fileExtension: string): Promise<void> {
        let url_ = this.baseUrl + "/api/v1/blob/delete-file/{fileName}/{fileExtension}";
        if (fileName === undefined || fileName === null)
            throw new Error("The parameter 'fileName' must be defined.");
        url_ = url_.replace("{fileName}", encodeURIComponent("" + fileName)); 
        if (fileExtension === undefined || fileExtension === null)
            throw new Error("The parameter 'fileExtension' must be defined.");
        url_ = url_.replace("{fileExtension}", encodeURIComponent("" + fileExtension)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteFile(_response);
        });
    }

    protected processDeleteFile(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @return Success
     */
    getFileStreamUrl(blobId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/v1/blob/get-file-stream-url/{blobId}";
        if (blobId === undefined || blobId === null)
            throw new Error("The parameter 'blobId' must be defined.");
        url_ = url_.replace("{blobId}", encodeURIComponent("" + blobId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetFileStreamUrl(_response);
        });
    }

    protected processGetFileStreamUrl(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }
}

export class CalendarService {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllCourseSchedule(): Promise<CalendarScheduleCourseModel[]> {
        let url_ = this.baseUrl + "/api/v1/calendar/get-all-course-schedule";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllCourseSchedule(_response);
        });
    }

    protected processGetAllCourseSchedule(response: Response): Promise<CalendarScheduleCourseModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <CalendarScheduleCourseModel[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CalendarScheduleCourseModel[]>(<any>null);
    }
}

export class CoachService {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param dateFilterStart (optional) 
     * @param dateFilterEnd (optional) 
     * @param coachName (optional) 
     * @param topicName (optional) 
     * @param coachIsActive (optional) 
     * @param ebadgeName (optional) 
     * @param sortBy (optional) 
     * @param pageNumber (optional) 
     * @return Success
     */
    getAllCoachesFilter(startDate: Date | null | undefined, endDate: Date | null | undefined, dateFilterStart: Date | null | undefined, dateFilterEnd: Date | null | undefined, coachName: string | null | undefined, topicName: string | null | undefined, coachIsActive: boolean | null | undefined, ebadgeName: string | null | undefined, sortBy: string | null | undefined, pageNumber: number | null | undefined): Promise<CoachesViewModel> {
        let url_ = this.baseUrl + "/api/v1/coach/get-all-coaches-filter?";
        if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        if (dateFilterStart !== undefined)
            url_ += "DateFilterStart=" + encodeURIComponent(dateFilterStart ? "" + dateFilterStart.toJSON() : "") + "&"; 
        if (dateFilterEnd !== undefined)
            url_ += "DateFilterEnd=" + encodeURIComponent(dateFilterEnd ? "" + dateFilterEnd.toJSON() : "") + "&"; 
        if (coachName !== undefined)
            url_ += "CoachName=" + encodeURIComponent("" + coachName) + "&"; 
        if (topicName !== undefined)
            url_ += "TopicName=" + encodeURIComponent("" + topicName) + "&"; 
        if (coachIsActive !== undefined)
            url_ += "CoachIsActive=" + encodeURIComponent("" + coachIsActive) + "&"; 
        if (ebadgeName !== undefined)
            url_ += "EbadgeName=" + encodeURIComponent("" + ebadgeName) + "&"; 
        if (sortBy !== undefined)
            url_ += "SortBy=" + encodeURIComponent("" + sortBy) + "&"; 
        if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllCoachesFilter(_response);
        });
    }

    protected processGetAllCoachesFilter(response: Response): Promise<CoachesViewModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <CoachesViewModel>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CoachesViewModel>(<any>null);
    }

    /**
     * @return Success
     */
    getAllEmployeeForAdd(employeeName: string, IsTam?: string, IsDealer?: string): Promise<ListEmployeeForCoach> {
        let url_ = this.baseUrl + "/api/v1/coach/get-all-employee-for-add/{employeeName}";
        if (employeeName === undefined || employeeName === null)
            throw new Error("The parameter 'employeeName' must be defined.");
        
        if (IsTam !== undefined && IsTam != null && IsTam != '') {
            url_ += `?IsTam=${IsTam}`
        } else if (IsDealer !== undefined && IsDealer != null && IsDealer != '') {
            url_ += `?IsDealer=${IsDealer}`
        }
        url_ = url_.replace("{employeeName}", encodeURIComponent("" + employeeName)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllEmployeeForAdd(_response);
        });
    }

    protected processGetAllEmployeeForAdd(response: Response): Promise<ListEmployeeForCoach> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ListEmployeeForCoach>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ListEmployeeForCoach>(<any>null);
    }

    /**
     * @return Success
     */
    getAllEmployee(employeeName: string, IsTam?: string, IsDealer?: string): Promise<ListEmployeeForCoach> {
        let url_ = this.baseUrl + "/api/v1/coach/get-all-employee/{employeeName}";
        if (employeeName === undefined || employeeName === null)
            throw new Error("The parameter 'employeeName' must be defined.");

        if (IsTam !== undefined && IsTam != null && IsTam != '') {
            url_ += `?IsTam=${IsTam}`
        } else if (IsDealer !== undefined && IsDealer != null && IsDealer != '') {
            url_ += `?IsDealer=${IsDealer}`
        }
        url_ = url_.replace("{employeeName}", encodeURIComponent("" + employeeName)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllEmployee(_response);
        });
    }

    protected processGetAllEmployee(response: Response): Promise<ListEmployeeForCoach> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ListEmployeeForCoach>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ListEmployeeForCoach>(<any>null);
    }

    /**
     * @return Success
     */
    getAllTopics(): Promise<TopicsEbadgeJoinModelForCoach[]> {
        let url_ = this.baseUrl + "/api/v1/coach/get-all-topics";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllTopics(_response);
        });
    }

    protected processGetAllTopics(response: Response): Promise<TopicsEbadgeJoinModelForCoach[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <TopicsEbadgeJoinModelForCoach[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TopicsEbadgeJoinModelForCoach[]>(<any>null);
    }

    /**
     * @param model (optional) 
     * @return Success
     */
    insertMasterCoach(model: CoachFormModel | null | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/v1/coach/insert-master-coach";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processInsertMasterCoach(_response);
        });
    }

    protected processInsertMasterCoach(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <boolean>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(<any>null);
    }

    /**
     * @return Success
     */
    getCoachDetail(id: number): Promise<CoachViewDetail> {
        let url_ = this.baseUrl + "/api/v1/coach/get-coach-detail/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetCoachDetail(_response);
        });
    }

    protected processGetCoachDetail(response: Response): Promise<CoachViewDetail> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <CoachViewDetail>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CoachViewDetail>(<any>null);
    }

    /**
     * @param model (optional) 
     * @return Success
     */
    updateCoachDetail(model: CoachFormModel | null | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/v1/coach/update-coach-detail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateCoachDetail(_response);
        });
    }

    protected processUpdateCoachDetail(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <boolean>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(<any>null);
    }

    /**
     * @param model (optional) 
     * @return Success
     */
    deleteCoach(model: CoachDeleteFormModel | null | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/v1/coach/delete-coach";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ = <RequestInit>{
            body: content_,
            method: "DELETE",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteCoach(_response);
        });
    }

    protected processDeleteCoach(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <boolean>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(<any>null);
    }

    /**
     * @return Success
     */
    validateUpdateCoach(id: number, employeeId: string): Promise<boolean> {
        let url_ = this.baseUrl + "/api/v1/coach/validate-update-coach/{id}/{employeeId}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        if (employeeId === undefined || employeeId === null)
            throw new Error("The parameter 'employeeId' must be defined.");
        url_ = url_.replace("{employeeId}", encodeURIComponent("" + employeeId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processValidateUpdateCoach(_response);
        });
    }

    protected processValidateUpdateCoach(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <boolean>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(<any>null);
    }
}

export class CompetencyService {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param competencyName (optional) 
     * @param prefixCode (optional) 
     * @param keyActionCode (optional) 
     * @param sortBy (optional) 
     * @param pageNumber (optional) 
     * @return Success
     */
    getAllJoinCompetencies(startDate: Date | null | undefined, endDate: Date | null | undefined, competencyName: string | null | undefined, prefixCode: string | null | undefined, keyActionCode: string | null | undefined, sortBy: string | null | undefined, pageNumber: number | null | undefined): Promise<CompetencyJoinViewModel> {
        let url_ = this.baseUrl + "/api/v1/competency/get-all-join-competencies?";
        if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        if (competencyName !== undefined)
            url_ += "CompetencyName=" + encodeURIComponent("" + competencyName) + "&"; 
        if (prefixCode !== undefined)
            url_ += "PrefixCode=" + encodeURIComponent("" + prefixCode) + "&"; 
        if (keyActionCode !== undefined)
            url_ += "KeyActionCode=" + encodeURIComponent("" + keyActionCode) + "&"; 
        if (sortBy !== undefined)
            url_ += "SortBy=" + encodeURIComponent("" + sortBy) + "&"; 
        if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllJoinCompetencies(_response);
        });
    }

    protected processGetAllJoinCompetencies(response: Response): Promise<CompetencyJoinViewModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <CompetencyJoinViewModel>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CompetencyJoinViewModel>(<any>null);
    }

    /**
     * @return Success
     */
    getJoinCompetencyById(id: number): Promise<CompetencyJoinModel> {
        let url_ = this.baseUrl + "/api/v1/competency/get-join-competency-by-id/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetJoinCompetencyById(_response);
        });
    }

    protected processGetJoinCompetencyById(response: Response): Promise<CompetencyJoinModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <CompetencyJoinModel>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CompetencyJoinModel>(<any>null);
    }

    /**
     * @return Success
     */
    all(): Promise<CompetencyJoinViewModel> {
        let url_ = this.baseUrl + "/api/v1/competency/all";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAll(_response);
        });
    }

    protected processAll(response: Response): Promise<CompetencyJoinViewModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <CompetencyJoinViewModel>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CompetencyJoinViewModel>(<any>null);
    }

    /**
     * @param model (optional) 
     * @return Success
     */
    create(model: CompetencyFormModel | null | undefined): Promise<number> {
        let url_ = this.baseUrl + "/api/v1/competency/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: Response): Promise<number> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <number>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<number>(<any>null);
    }

    /**
     * @param model (optional) 
     * @return Success
     */
    update(model: CompetencyFormModel | null | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/v1/competency/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <boolean>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/v1/competency/delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(id);

        let options_ = <RequestInit>{
            body: content_,
            method: "DELETE",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <boolean>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(<any>null);
    }

    /**
     * @return Success
     */
    getAllCompetenciesAsync(): Promise<CompetencyModel[]> {
        let url_ = this.baseUrl + "/api/v1/competency/get-all-competencies-async";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllCompetenciesAsync(_response);
        });
    }

    protected processGetAllCompetenciesAsync(response: Response): Promise<CompetencyModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <CompetencyModel[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CompetencyModel[]>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getCompetenciesByIdAsync(id: number | null | undefined): Promise<CompetencyModel> {
        let url_ = this.baseUrl + "/api/v1/competency/get-competencies-by-id-async?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetCompetenciesByIdAsync(_response);
        });
    }

    protected processGetCompetenciesByIdAsync(response: Response): Promise<CompetencyModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <CompetencyModel>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CompetencyModel>(<any>null);
    }
}

export class CompetencyMappingService {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param competencyName (optional) 
     * @param competencyMappingCode (optional) 
     * @param typeofEvaluation (optional) 
     * @param sortBy (optional) 
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    getAllCompetencyMappingPaginateAsync(startDate: Date | null | undefined, endDate: Date | null | undefined, competencyName: string | null | undefined, competencyMappingCode: string | null | undefined, typeofEvaluation: string | null | undefined, sortBy: string | null | undefined, pageIndex: number | null | undefined, pageSize: number | null | undefined): Promise<CompetencyMappingPaginate> {
        let url_ = this.baseUrl + "/api/v1/competency-mapping/get-all-competency-mapping-paginate-async?";
        if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        if (competencyName !== undefined)
            url_ += "CompetencyName=" + encodeURIComponent("" + competencyName) + "&"; 
        if (competencyMappingCode !== undefined)
            url_ += "CompetencyMappingCode=" + encodeURIComponent("" + competencyMappingCode) + "&"; 
        if (typeofEvaluation !== undefined)
            url_ += "TypeofEvaluation=" + encodeURIComponent("" + typeofEvaluation) + "&"; 
        if (sortBy !== undefined)
            url_ += "SortBy=" + encodeURIComponent("" + sortBy) + "&"; 
        if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&"; 
        if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllCompetencyMappingPaginateAsync(_response);
        });
    }

    protected processGetAllCompetencyMappingPaginateAsync(response: Response): Promise<CompetencyMappingPaginate> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <CompetencyMappingPaginate>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CompetencyMappingPaginate>(<any>null);
    }

    /**
     * @return Success
     */
    getAllCompetencyMappingByCompetencyIdAndEvaluationIdPaginateAsync(competencyId: number, evaluationTypeId: number): Promise<CompetencyMapping> {
        let url_ = this.baseUrl + "/api/v1/competency-mapping/get-all-competency-mapping-by-competency-id-and-evaluation-id-paginate-async?";
        if (competencyId === undefined || competencyId === null)
            throw new Error("The parameter 'competencyId' must be defined and cannot be null.");
        else
            url_ += "CompetencyId=" + encodeURIComponent("" + competencyId) + "&"; 
        if (evaluationTypeId === undefined || evaluationTypeId === null)
            throw new Error("The parameter 'evaluationTypeId' must be defined and cannot be null.");
        else
            url_ += "EvaluationTypeId=" + encodeURIComponent("" + evaluationTypeId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllCompetencyMappingByCompetencyIdAndEvaluationIdPaginateAsync(_response);
        });
    }

    protected processGetAllCompetencyMappingByCompetencyIdAndEvaluationIdPaginateAsync(response: Response): Promise<CompetencyMapping> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <CompetencyMapping>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CompetencyMapping>(<any>null);
    }

    /**
     * @param insert (optional) 
     * @return Success
     */
    insertCompetencyMappingAsync(insert: CompetencyMappingInsertModel | null | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/v1/competency-mapping/insert-competency-mapping-async";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(insert);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processInsertCompetencyMappingAsync(_response);
        });
    }

    protected processInsertCompetencyMappingAsync(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <boolean>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(<any>null);
    }

    /**
     * @param update (optional) 
     * @return Success
     */
    updateCompetencyMappingAsync(competencyId: number, evaluationTypeId: number, update: CompetencyMappingInsertModel | null | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/v1/competency-mapping/update-competency-mapping-async?";
        if (competencyId === undefined || competencyId === null)
            throw new Error("The parameter 'competencyId' must be defined and cannot be null.");
        else
            url_ += "CompetencyId=" + encodeURIComponent("" + competencyId) + "&"; 
        if (evaluationTypeId === undefined || evaluationTypeId === null)
            throw new Error("The parameter 'evaluationTypeId' must be defined and cannot be null.");
        else
            url_ += "EvaluationTypeId=" + encodeURIComponent("" + evaluationTypeId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(update);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateCompetencyMappingAsync(_response);
        });
    }

    protected processUpdateCompetencyMappingAsync(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <boolean>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(<any>null);
    }

    /**
     * @return Success
     */
    deleteCompetencyMappingAsync(competencyId: number, evaluationTypeId: number): Promise<boolean> {
        let url_ = this.baseUrl + "/api/v1/competency-mapping/delete-competency-mapping-async?";
        if (competencyId === undefined || competencyId === null)
            throw new Error("The parameter 'competencyId' must be defined and cannot be null.");
        else
            url_ += "CompetencyId=" + encodeURIComponent("" + competencyId) + "&"; 
        if (evaluationTypeId === undefined || evaluationTypeId === null)
            throw new Error("The parameter 'evaluationTypeId' must be defined and cannot be null.");
        else
            url_ += "EvaluationTypeId=" + encodeURIComponent("" + evaluationTypeId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteCompetencyMappingAsync(_response);
        });
    }

    protected processDeleteCompetencyMappingAsync(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <boolean>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(<any>null);
    }
}

export class CompetencyTypeService {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllCompetencyTypes(): Promise<CompetencyTypeViewModel> {
        let url_ = this.baseUrl + "/api/v1/competency-type/get-all-competency-types";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllCompetencyTypes(_response);
        });
    }

    protected processGetAllCompetencyTypes(response: Response): Promise<CompetencyTypeViewModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <CompetencyTypeViewModel>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CompetencyTypeViewModel>(<any>null);
    }

    /**
     * @return Success
     */
    getCompetencyTypeById(id: number): Promise<CompetencyTypeModel> {
        let url_ = this.baseUrl + "/api/v1/competency-type/get-competency-type-by-id/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetCompetencyTypeById(_response);
        });
    }

    protected processGetCompetencyTypeById(response: Response): Promise<CompetencyTypeModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <CompetencyTypeModel>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CompetencyTypeModel>(<any>null);
    }
}

export class CourseService {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param courseName (optional) 
     * @param programTypeName (optional) 
     * @param learningName (optional) 
     * @param courseCategoryName (optional) 
     * @param pricing (optional) 
     * @param approvalName (optional) 
     * @param sortBy (optional) 
     * @param pageNumber (optional) 
     * @return Success
     */
    getAllJoinCourses(startDate: Date | null | undefined, endDate: Date | null | undefined, courseName: string | null | undefined, programTypeName: string | null | undefined, learningName: string | null | undefined, courseCategoryName: string | null | undefined, pricing: string | null | undefined, approvalName: string | null | undefined, sortBy: string | null | undefined, pageNumber: number | null | undefined): Promise<CourseJoinViewModel> {
        let url_ = this.baseUrl + "/api/v1/course/get-all-join-courses?";
        if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        if (courseName !== undefined)
            url_ += "CourseName=" + encodeURIComponent("" + courseName) + "&"; 
        if (programTypeName !== undefined)
            url_ += "ProgramTypeName=" + encodeURIComponent("" + programTypeName) + "&"; 
        if (learningName !== undefined)
            url_ += "LearningName=" + encodeURIComponent("" + learningName) + "&"; 
        if (courseCategoryName !== undefined)
            url_ += "CourseCategoryName=" + encodeURIComponent("" + courseCategoryName) + "&"; 
        if (pricing !== undefined)
            url_ += "Pricing=" + encodeURIComponent("" + pricing) + "&"; 
        if (approvalName !== undefined)
            url_ += "ApprovalName=" + encodeURIComponent("" + approvalName) + "&"; 
        if (sortBy !== undefined)
            url_ += "SortBy=" + encodeURIComponent("" + sortBy) + "&"; 
        if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllJoinCourses(_response);
        });
    }

    protected processGetAllJoinCourses(response: Response): Promise<CourseJoinViewModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <CourseJoinViewModel>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CourseJoinViewModel>(<any>null);
    }

    /**
     * @return Success
     */
    getJoinCourseById(id: number): Promise<CourseJoinModel> {
        let url_ = this.baseUrl + "/api/v1/course/get-join-course-by-id/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetJoinCourseById(_response);
        });
    }

    protected processGetJoinCourseById(response: Response): Promise<CourseJoinModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <CourseJoinModel>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CourseJoinModel>(<any>null);
    }

    /**
     * @param model (optional) 
     * @return Success
     */
    create(model: CourseFormModel | null | undefined): Promise<number> {
        let url_ = this.baseUrl + "/api/v1/course/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: Response): Promise<number> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <number>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<number>(<any>null);
    }

    /**
     * @param model (optional) 
     * @return Success
     */
    update(model: CourseFormModel | null | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/v1/course/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <boolean>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/v1/course/delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(id);

        let options_ = <RequestInit>{
            body: content_,
            method: "DELETE",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <boolean>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(<any>null);
    }
}

export class CourseCategoryService {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllCourseCategories(): Promise<CourseCategoryViewModel> {
        let url_ = this.baseUrl + "/api/v1/course-category/get-all-course-categories";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllCourseCategories(_response);
        });
    }

    protected processGetAllCourseCategories(response: Response): Promise<CourseCategoryViewModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <CourseCategoryViewModel>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CourseCategoryViewModel>(<any>null);
    }

    /**
     * @return Success
     */
    getCourseCategoryById(id: number): Promise<CourseCategoryModel> {
        let url_ = this.baseUrl + "/api/v1/course-category/get-course-category-by-id/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetCourseCategoryById(_response);
        });
    }

    protected processGetCourseCategoryById(response: Response): Promise<CourseCategoryModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <CourseCategoryModel>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CourseCategoryModel>(<any>null);
    }
}

export class DashboardOperationService {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllTotalUsers(): Promise<number> {
        let url_ = this.baseUrl + "/api/v1/dashboard-operation/get-all-total-users";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllTotalUsers(_response);
        });
    }

    protected processGetAllTotalUsers(response: Response): Promise<number> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <number>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<number>(<any>null);
    }

    /**
     * @return Success
     */
    getAllTotalActiveUsers(): Promise<number> {
        let url_ = this.baseUrl + "/api/v1/dashboard-operation/get-all-total-active-users";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllTotalActiveUsers(_response);
        });
    }

    protected processGetAllTotalActiveUsers(response: Response): Promise<number> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <number>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<number>(<any>null);
    }

    /**
     * @return Success
     */
    getAllTotalAccessRate(): Promise<number> {
        let url_ = this.baseUrl + "/api/v1/dashboard-operation/get-all-total-access-rate";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllTotalAccessRate(_response);
        });
    }

    protected processGetAllTotalAccessRate(response: Response): Promise<number> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <number>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<number>(<any>null);
    }

    /**
     * @return Success
     */
    getAverageAccessTime(): Promise<number> {
        let url_ = this.baseUrl + "/api/v1/dashboard-operation/get-average-access-time";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAverageAccessTime(_response);
        });
    }

    protected processGetAverageAccessTime(response: Response): Promise<number> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <number>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<number>(<any>null);
    }

    /**
     * @return Success
     */
    getTotalLearningEnrollment(): Promise<number> {
        let url_ = this.baseUrl + "/api/v1/dashboard-operation/get-total-learning-enrollment";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetTotalLearningEnrollment(_response);
        });
    }

    protected processGetTotalLearningEnrollment(response: Response): Promise<number> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <number>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<number>(<any>null);
    }

    /**
     * @return Success
     */
    getTotalCertificateRate(): Promise<number> {
        let url_ = this.baseUrl + "/api/v1/dashboard-operation/get-total-certificate-rate";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetTotalCertificateRate(_response);
        });
    }

    protected processGetTotalCertificateRate(response: Response): Promise<number> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <number>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<number>(<any>null);
    }

    /**
     * @return Success
     */
    getAllApprovalContent(): Promise<DashboardApprovalListViewModel> {
        let url_ = this.baseUrl + "/api/v1/dashboard-operation/get-all-approval-content";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllApprovalContent(_response);
        });
    }

    protected processGetAllApprovalContent(response: Response): Promise<DashboardApprovalListViewModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <DashboardApprovalListViewModel>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DashboardApprovalListViewModel>(<any>null);
    }

    /**
     * @return Success
     */
    getAllTotalUsersThisYear(): Promise<DashboardUsersThisYearListViewModel> {
        let url_ = this.baseUrl + "/api/v1/dashboard-operation/get-all-total-users-this-year";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllTotalUsersThisYear(_response);
        });
    }

    protected processGetAllTotalUsersThisYear(response: Response): Promise<DashboardUsersThisYearListViewModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <DashboardUsersThisYearListViewModel>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DashboardUsersThisYearListViewModel>(<any>null);
    }

    /**
     * @return Success
     */
    getTwoWeeksClassSchedule(): Promise<DashboardClassListViewModel> {
        let url_ = this.baseUrl + "/api/v1/dashboard-operation/get-two-weeks-class-schedule";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetTwoWeeksClassSchedule(_response);
        });
    }

    protected processGetTwoWeeksClassSchedule(response: Response): Promise<DashboardClassListViewModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <DashboardClassListViewModel>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DashboardClassListViewModel>(<any>null);
    }

    /**
     * @return Success
     */
    getAllTslReport(): Promise<SetupTSLViewModel> {
        let url_ = this.baseUrl + "/api/v1/dashboard-operation/get-all-tsl-report";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllTslReport(_response);
        });
    }

    protected processGetAllTslReport(response: Response): Promise<SetupTSLViewModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <SetupTSLViewModel>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SetupTSLViewModel>(<any>null);
    }

    /**
     * @return Success
     */
    getAllPositionName(): Promise<PositionNameModel[]> {
        let url_ = this.baseUrl + "/api/v1/dashboard-operation/get-all-position-name";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllPositionName(_response);
        });
    }

    protected processGetAllPositionName(response: Response): Promise<PositionNameModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <PositionNameModel[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PositionNameModel[]>(<any>null);
    }

    /**
     * @param positionName (optional) 
     * @return Success
     */
    getPositionCompetencyMapping(positionName: string | null | undefined): Promise<DashboardCompetencyMappingModel> {
        let url_ = this.baseUrl + "/api/v1/dashboard-operation/get-position-competency-mapping?";
        if (positionName !== undefined)
            url_ += "positionName=" + encodeURIComponent("" + positionName) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetPositionCompetencyMapping(_response);
        });
    }

    protected processGetPositionCompetencyMapping(response: Response): Promise<DashboardCompetencyMappingModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <DashboardCompetencyMappingModel>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DashboardCompetencyMappingModel>(<any>null);
    }

    /**
     * @return Success
     */
    getTop5Topics(): Promise<DashboardTop5TopicViewModel> {
        let url_ = this.baseUrl + "/api/v1/dashboard-operation/get-top-5-topics";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetTop5Topics(_response);
        });
    }

    protected processGetTop5Topics(response: Response): Promise<DashboardTop5TopicViewModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <DashboardTop5TopicViewModel>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DashboardTop5TopicViewModel>(<any>null);
    }

    /**
     * @return Success
     */
    getTop5Learnings(): Promise<DashboardTop5LearningViewModel> {
        let url_ = this.baseUrl + "/api/v1/dashboard-operation/get-top-5-learnings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetTop5Learnings(_response);
        });
    }

    protected processGetTop5Learnings(response: Response): Promise<DashboardTop5LearningViewModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <DashboardTop5LearningViewModel>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DashboardTop5LearningViewModel>(<any>null);
    }

    /**
     * @return Success
     */
    getTotalLearningLibrary(): Promise<DashboardTotalLearningLibraryViewModel> {
        let url_ = this.baseUrl + "/api/v1/dashboard-operation/get-total-learning-library";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetTotalLearningLibrary(_response);
        });
    }

    protected processGetTotalLearningLibrary(response: Response): Promise<DashboardTotalLearningLibraryViewModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <DashboardTotalLearningLibraryViewModel>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DashboardTotalLearningLibraryViewModel>(<any>null);
    }

    /**
     * @return Success
     */
    getTop5News(): Promise<DashboardTop5NewsViewModel> {
        let url_ = this.baseUrl + "/api/v1/dashboard-operation/get-top-5-news";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetTop5News(_response);
        });
    }

    protected processGetTop5News(response: Response): Promise<DashboardTop5NewsViewModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <DashboardTop5NewsViewModel>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DashboardTop5NewsViewModel>(<any>null);
    }

    /**
     * @return Success
     */
    getTop5Events(): Promise<DashboardTop5EventsViewModel> {
        let url_ = this.baseUrl + "/api/v1/dashboard-operation/get-top-5-events";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetTop5Events(_response);
        });
    }

    protected processGetTop5Events(response: Response): Promise<DashboardTop5EventsViewModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <DashboardTop5EventsViewModel>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DashboardTop5EventsViewModel>(<any>null);
    }

    /**
     * @return Success
     */
    getTop5Coach(): Promise<DashboardTop5CoachViewModel> {
        let url_ = this.baseUrl + "/api/v1/dashboard-operation/get-top-5-coach";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetTop5Coach(_response);
        });
    }

    protected processGetTop5Coach(response: Response): Promise<DashboardTop5CoachViewModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <DashboardTop5CoachViewModel>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DashboardTop5CoachViewModel>(<any>null);
    }

    /**
     * @return Success
     */
    getTop5RewardType(): Promise<DashboardTop5RewardTypeViewModel> {
        let url_ = this.baseUrl + "/api/v1/dashboard-operation/get-top-5-reward-type";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetTop5RewardType(_response);
        });
    }

    protected processGetTop5RewardType(response: Response): Promise<DashboardTop5RewardTypeViewModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <DashboardTop5RewardTypeViewModel>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DashboardTop5RewardTypeViewModel>(<any>null);
    }

    /**
     * @return Success
     */
    getNpsReport(): Promise<DashboardNPSReportViewModel> {
        let url_ = this.baseUrl + "/api/v1/dashboard-operation/get-nps-report";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetNpsReport(_response);
        });
    }

    protected processGetNpsReport(response: Response): Promise<DashboardNPSReportViewModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <DashboardNPSReportViewModel>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DashboardNPSReportViewModel>(<any>null);
    }

    /**
     * @return Success
     */
    getMyInsight(): Promise<DashboardMyInsightViewModel> {
        let url_ = this.baseUrl + "/api/v1/dashboard-operation/get-my-insight";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetMyInsight(_response);
        });
    }

    protected processGetMyInsight(response: Response): Promise<DashboardMyInsightViewModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <DashboardMyInsightViewModel>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DashboardMyInsightViewModel>(<any>null);
    }
}

export class DigitalSignatureService {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param employeeName (optional) 
     * @param sortBy (optional) 
     * @param pageNumber (optional) 
     * @return Success
     */
    getAllDigitalSignature(employeeName: string | null | undefined, sortBy: string | null | undefined, pageNumber: number | null | undefined): Promise<DigitalSignatureViewModel> {
        let url_ = this.baseUrl + "/api/v1/digital-signature/get-all-digital-signature?";
        if (employeeName !== undefined)
            url_ += "EmployeeName=" + encodeURIComponent("" + employeeName) + "&"; 
        if (sortBy !== undefined)
            url_ += "SortBy=" + encodeURIComponent("" + sortBy) + "&"; 
        if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllDigitalSignature(_response);
        });
    }

    protected processGetAllDigitalSignature(response: Response): Promise<DigitalSignatureViewModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <DigitalSignatureViewModel>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DigitalSignatureViewModel>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteDigitalSignature(id: number | null | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/v1/digital-signature/delete-digital-signature?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteDigitalSignature(_response);
        });
    }

    protected processDeleteDigitalSignature(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <boolean>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(<any>null);
    }

    /**
     * @param model (optional) 
     * @return Success
     */
    insertDigitalSignature(model: DigitalSignatureFormModel | null | undefined): Promise<number> {
        let url_ = this.baseUrl + "/api/v1/digital-signature/insert-digital-signature";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processInsertDigitalSignature(_response);
        });
    }

    protected processInsertDigitalSignature(response: Response): Promise<number> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <number>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<number>(<any>null);
    }

    /**
     * @param model (optional) 
     * @return Success
     */
    updateDigitalSignature(model: DigitalSignatureFormModel | null | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/v1/digital-signature/update-digital-signature";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateDigitalSignature(_response);
        });
    }

    protected processUpdateDigitalSignature(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <boolean>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(<any>null);
    }

    /**
     * @return Success
     */
    validateUpdate(id: number, employeeId: string): Promise<boolean> {
        let url_ = this.baseUrl + "/api/v1/digital-signature/validate-update/{id}/{employeeId}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        if (employeeId === undefined || employeeId === null)
            throw new Error("The parameter 'employeeId' must be defined.");
        url_ = url_.replace("{employeeId}", encodeURIComponent("" + employeeId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processValidateUpdate(_response);
        });
    }

    protected processValidateUpdate(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <boolean>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(<any>null);
    }
}

export class DropdownService {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllRewardTypeDropdown(): Promise<RewardTypeDropdownModel[]> {
        let url_ = this.baseUrl + "/api/v1/dropdown/get-all-reward-type-dropdown";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllRewardTypeDropdown(_response);
        });
    }

    protected processGetAllRewardTypeDropdown(response: Response): Promise<RewardTypeDropdownModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <RewardTypeDropdownModel[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<RewardTypeDropdownModel[]>(<any>null);
    }

    /**
     * @return Success
     */
    getAllModuleDropdown(): Promise<ModuleDropdownModel[]> {
        let url_ = this.baseUrl + "/api/v1/dropdown/get-all-module-dropdown";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllModuleDropdown(_response);
        });
    }

    protected processGetAllModuleDropdown(response: Response): Promise<ModuleDropdownModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ModuleDropdownModel[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ModuleDropdownModel[]>(<any>null);
    }

    /**
     * @return Success
     */
    getAllCoachDropdown(): Promise<CoachDropdownModel[]> {
        let url_ = this.baseUrl + "/api/v1/dropdown/get-all-coach-dropdown";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllCoachDropdown(_response);
        });
    }

    protected processGetAllCoachDropdown(response: Response): Promise<CoachDropdownModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <CoachDropdownModel[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CoachDropdownModel[]>(<any>null);
    }

    /**
     * @return Success
     */
    getAllEventDropdown(): Promise<EventDropdownModel[]> {
        let url_ = this.baseUrl + "/api/v1/dropdown/get-all-event-dropdown";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllEventDropdown(_response);
        });
    }

    protected processGetAllEventDropdown(response: Response): Promise<EventDropdownModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <EventDropdownModel[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<EventDropdownModel[]>(<any>null);
    }

    /**
     * @return Success
     */
    getAllRewardPointTypeDropdown(): Promise<RewardPointTypeDropdown[]> {
        let url_ = this.baseUrl + "/api/v1/dropdown/get-all-reward-point-type-dropdown";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllRewardPointTypeDropdown(_response);
        });
    }

    protected processGetAllRewardPointTypeDropdown(response: Response): Promise<RewardPointTypeDropdown[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <RewardPointTypeDropdown[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<RewardPointTypeDropdown[]>(<any>null);
    }

    /**
     * @return Success
     */
    getDealerDropdown(): Promise<DealerDropdownModel[]> {
        let url_ = this.baseUrl + "/api/v1/dropdown/get-dealer-dropdown";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetDealerDropdown(_response);
        });
    }

    protected processGetDealerDropdown(response: Response): Promise<DealerDropdownModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <DealerDropdownModel[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DealerDropdownModel[]>(<any>null);
    }

    /**
     * @return Success
     */
    getOthersDropdown(): Promise<any[]> {
        let url_ = this.baseUrl + "/api/v1/dealer/search-dealer?status=true";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetOthersDropdown(_response);
        });
    }

    protected processGetOthersDropdown(response: Response): Promise<any[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <any[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<any[]>(<any>null);
    }

    /**
     * @param dealerId (optional) 
     * @return Success
     */
    getOutletDropdown(dealerId: string | null | undefined): Promise<OutletDropdownModel[]> {
        let url_ = this.baseUrl + "/api/v1/dropdown/get-outlet-dropdown?";
        if (dealerId !== undefined)
            url_ += "dealerId=" + encodeURIComponent("" + dealerId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetOutletDropdown(_response);
        });
    }

    protected processGetOutletDropdown(response: Response): Promise<OutletDropdownModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <OutletDropdownModel[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<OutletDropdownModel[]>(<any>null);
    }

    /**
     * @param outletId (optional) 
     * @return Success
     */
    getPositionDropdown(outletId: string | null | undefined): Promise<PositionDropdownModel[]> {
        let url_ = this.baseUrl + "/api/v1/dropdown/get-position-dropdown?";
        if (outletId !== undefined)
            url_ += "outletId=" + encodeURIComponent("" + outletId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetPositionDropdown(_response);
        });
    }

    protected processGetPositionDropdown(response: Response): Promise<PositionDropdownModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <PositionDropdownModel[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PositionDropdownModel[]>(<any>null);
    }

    /**
     * @param positionId (optional) 
     * @param outletId (optional) 
     * @return Success
     */
    getEmployeeDropdown(positionId: number | null | undefined, outletId: string | null | undefined): Promise<EmployeeDropdownModel[]> {
        let url_ = this.baseUrl + "/api/v1/dropdown/get-employee-dropdown?";
        if (positionId !== undefined)
            url_ += "positionId=" + encodeURIComponent("" + positionId) + "&"; 
        if (outletId !== undefined)
            url_ += "outletId=" + encodeURIComponent("" + outletId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetEmployeeDropdown(_response);
        });
    }

    protected processGetEmployeeDropdown(response: Response): Promise<EmployeeDropdownModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <EmployeeDropdownModel[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<EmployeeDropdownModel[]>(<any>null);
    }

    /**
     * @return Success
     */
    getMaterialTypeDropdown(): Promise<MaterialTypeDropdownModel[]> {
        let url_ = this.baseUrl + "/api/v1/dropdown/get-material-type-dropdown";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetMaterialTypeDropdown(_response);
        });
    }

    protected processGetMaterialTypeDropdown(response: Response): Promise<MaterialTypeDropdownModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <MaterialTypeDropdownModel[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<MaterialTypeDropdownModel[]>(<any>null);
    }

    /**
     * @return Success
     */
    getTopicDropdown(): Promise<TopicDropdownModel[]> {
        let url_ = this.baseUrl + "/api/v1/dropdown/get-topic-dropdown";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetTopicDropdown(_response);
        });
    }

    protected processGetTopicDropdown(response: Response): Promise<TopicDropdownModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <TopicDropdownModel[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TopicDropdownModel[]>(<any>null);
    }

    /**
     * @return Success
     */
    getApprovalStatusDropdown(): Promise<ApprovalStatusDropdownModel[]> {
        let url_ = this.baseUrl + "/api/v1/dropdown/get-approval-status-dropdown";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetApprovalStatusDropdown(_response);
        });
    }

    protected processGetApprovalStatusDropdown(response: Response): Promise<ApprovalStatusDropdownModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ApprovalStatusDropdownModel[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApprovalStatusDropdownModel[]>(<any>null);
    }

    /**
     * @return Success
     */
    getApprovalStatus(): Promise<string[]> {
        let url_ = this.baseUrl + "/api/v1/dropdown/get-approval-status";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetApprovalStatus(_response);
        });
    }

    protected processGetApprovalStatus(response: Response): Promise<string[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <string[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string[]>(<any>null);
    }

    /**
     * @return Success
     */
    getContentCategory(): Promise<string[]> {
        let url_ = this.baseUrl + "/api/v1/dropdown/get-content-category";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetContentCategory(_response);
        });
    }

    protected processGetContentCategory(response: Response): Promise<string[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <string[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string[]>(<any>null);
    }

    /**
     * @return Success
     */
    getNewsList(): Promise<DropDownModel[]> {
        let url_ = this.baseUrl + "/api/v1/dropdown/get-news-list";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetNewsList(_response);
        });
    }

    protected processGetNewsList(response: Response): Promise<DropDownModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <DropDownModel[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DropDownModel[]>(<any>null);
    }

    /**
     * @return Success
     */
    getCompetency(): Promise<DropDownModel[]> {
        let url_ = this.baseUrl + "/api/v1/dropdown/get-competency";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetCompetency(_response);
        });
    }

    protected processGetCompetency(response: Response): Promise<DropDownModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <DropDownModel[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DropDownModel[]>(<any>null);
    }

    /**
     * @return Success
     */
    getCompetencyPriority(): Promise<string[]> {
        let url_ = this.baseUrl + "/api/v1/dropdown/get-competency-priority";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetCompetencyPriority(_response);
        });
    }

    protected processGetCompetencyPriority(response: Response): Promise<string[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <string[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string[]>(<any>null);
    }

    /**
     * @return Success
     */
    getCompetencyProficiency(): Promise<number[]> {
        let url_ = this.baseUrl + "/api/v1/dropdown/get-competency-Proficiency";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetCompetencyProficiency(_response);
        });
    }

    protected processGetCompetencyProficiency(response: Response): Promise<number[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <number[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<number[]>(<any>null);
    }

    /**
     * @return Success
     */
    getPosition(): Promise<DropDownModel[]> {
        let url_ = this.baseUrl + "/api/v1/dropdown/get-position";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetPosition(_response);
        });
    }

    protected processGetPosition(response: Response): Promise<DropDownModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <DropDownModel[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DropDownModel[]>(<any>null);
    }
}

export class EmployeeService {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    get(employeeId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/v1/employee/get/{employeeId}";
        if (employeeId === undefined || employeeId === null)
            throw new Error("The parameter 'employeeId' must be defined.");
        url_ = url_.replace("{employeeId}", encodeURIComponent("" + employeeId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @return Success
     */
    getEmployeeNameForDigitalSignature(employeeName: string): Promise<EmployeeListViewModel> {
        let url_ = this.baseUrl + "/api/v1/employee/get-employee-name-for-digital-signature/{employeeName}";
        if (employeeName === undefined || employeeName === null)
            throw new Error("The parameter 'employeeName' must be defined.");
        url_ = url_.replace("{employeeName}", encodeURIComponent("" + employeeName)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetEmployeeNameForDigitalSignature(_response);
        });
    }

    protected processGetEmployeeNameForDigitalSignature(response: Response): Promise<EmployeeListViewModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <EmployeeListViewModel>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<EmployeeListViewModel>(<any>null);
    }

    /**
     * @return Success
     */
    getEmployeeName(employeeName: string): Promise<EmployeeListViewModel> {
        let url_ = this.baseUrl + "/api/v1/employee/get-employee-name/{employeeName}";
        if (employeeName === undefined || employeeName === null)
            throw new Error("The parameter 'employeeName' must be defined.");
        url_ = url_.replace("{employeeName}", encodeURIComponent("" + employeeName)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetEmployeeName(_response);
        });
    }

    protected processGetEmployeeName(response: Response): Promise<EmployeeListViewModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <EmployeeListViewModel>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<EmployeeListViewModel>(<any>null);
    }

    /**
     * @param model (optional) 
     * @return Success
     */
    insertEmployeeTestApi(model: EmployeeFormModel | null | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/v1/employee/insert-employee-test-api";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processInsertEmployeeTestApi(_response);
        });
    }

    protected processInsertEmployeeTestApi(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <boolean>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(<any>null);
    }
}

export class EvaluationTypesService {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllEvaluationTypesAsync(): Promise<EvaluationTypesViewModel[]> {
        let url_ = this.baseUrl + "/api/v1/evaluation-types/get-all-evaluation-types-async";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllEvaluationTypesAsync(_response);
        });
    }

    protected processGetAllEvaluationTypesAsync(response: Response): Promise<EvaluationTypesViewModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <EvaluationTypesViewModel[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<EvaluationTypesViewModel[]>(<any>null);
    }
}

export class EventService {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param eventName (optional) 
     * @param eventCategoryName (optional) 
     * @param eventHostName (optional) 
     * @param approvalStatus (optional) 
     * @param eventFrom (optional) 
     * @param eventTo (optional) 
     * @param sortBy (optional) 
     * @param pageNumber (optional) 
     * @return Success
     */
    getAllJoinEvents(startDate: Date | null | undefined, endDate: Date | null | undefined, eventName: string | null | undefined, eventCategoryName: string | null | undefined, eventHostName: string | null | undefined, approvalStatus: string | null | undefined, eventFrom: Date | null | undefined, eventTo: Date | null | undefined, sortBy: string | null | undefined, pageNumber: number | null | undefined): Promise<EventJoinViewModel> {
        let url_ = this.baseUrl + "/api/v1/event/get-all-join-events?";
        if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        if (eventName !== undefined)
            url_ += "EventName=" + encodeURIComponent("" + eventName) + "&"; 
        if (eventCategoryName !== undefined)
            url_ += "EventCategoryName=" + encodeURIComponent("" + eventCategoryName) + "&"; 
        if (eventHostName !== undefined)
            url_ += "EventHostName=" + encodeURIComponent("" + eventHostName) + "&"; 
        if (approvalStatus !== undefined)
            url_ += "ApprovalStatus=" + encodeURIComponent("" + approvalStatus) + "&"; 
        if (eventFrom !== undefined)
            url_ += "EventFrom=" + encodeURIComponent(eventFrom ? "" + eventFrom.toJSON() : "") + "&"; 
        if (eventTo !== undefined)
            url_ += "EventTo=" + encodeURIComponent(eventTo ? "" + eventTo.toJSON() : "") + "&"; 
        if (sortBy !== undefined)
            url_ += "SortBy=" + encodeURIComponent("" + sortBy) + "&"; 
        if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllJoinEvents(_response);
        });
    }

    protected processGetAllJoinEvents(response: Response): Promise<EventJoinViewModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <EventJoinViewModel>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<EventJoinViewModel>(<any>null);
    }

    /**
     * @return Success
     */
    getJoinEventById(id: number): Promise<EventJoinModel> {
        let url_ = this.baseUrl + "/api/v1/event/get-join-event-by-id/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetJoinEventById(_response);
        });
    }

    protected processGetJoinEventById(response: Response): Promise<EventJoinModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <EventJoinModel>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<EventJoinModel>(<any>null);
    }

    /**
     * @param model (optional) 
     * @return Success
     */
    create(model: EventFormModel | null | undefined): Promise<number> {
        let url_ = this.baseUrl + "/api/v1/event/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: Response): Promise<number> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <number>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<number>(<any>null);
    }

    /**
     * @param model (optional) 
     * @return Success
     */
    update(model: EventJoinModel | null | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/v1/event/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <boolean>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/v1/event/delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(id);

        let options_ = <RequestInit>{
            body: content_,
            method: "DELETE",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <boolean>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(<any>null);
    }
}

export class EventCategoryService {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param eventCategoryName (optional) 
     * @param sortBy (optional) 
     * @param pageNumber (optional) 
     * @return Success
     */
    getAllEventCategories(eventCategoryName: string | null | undefined, sortBy: string | null | undefined, pageNumber: number | null | undefined): Promise<EventCategoryViewModel> {
        let url_ = this.baseUrl + "/api/v1/eventCategory/get-all-event-categories?";
        if (eventCategoryName !== undefined)
            url_ += "EventCategoryName=" + encodeURIComponent("" + eventCategoryName) + "&"; 
        if (sortBy !== undefined)
            url_ += "SortBy=" + encodeURIComponent("" + sortBy) + "&"; 
        if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllEventCategories(_response);
        });
    }

    protected processGetAllEventCategories(response: Response): Promise<EventCategoryViewModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <EventCategoryViewModel>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<EventCategoryViewModel>(<any>null);
    }

    /**
     * @return Success
     */
    getAllEventCategoriesNoFilter(): Promise<EventCategoryModel[]> {
        let url_ = this.baseUrl + "/api/v1/eventCategory/get-all-event-categories-no-filter";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllEventCategoriesNoFilter(_response);
        });
    }

    protected processGetAllEventCategoriesNoFilter(response: Response): Promise<EventCategoryModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <EventCategoryModel[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<EventCategoryModel[]>(<any>null);
    }

    /**
     * @return Success
     */
    getEventCategoryById(id: number): Promise<EventCategoryModel> {
        let url_ = this.baseUrl + "/api/v1/eventCategory/get-event-category-by-id/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetEventCategoryById(_response);
        });
    }

    protected processGetEventCategoryById(response: Response): Promise<EventCategoryModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <EventCategoryModel>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<EventCategoryModel>(<any>null);
    }

    /**
     * @param model (optional) 
     * @return Success
     */
    create(model: EventCategoryFormModel | null | undefined): Promise<number> {
        let url_ = this.baseUrl + "/api/v1/eventCategory/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: Response): Promise<number> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <number>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<number>(<any>null);
    }

    /**
     * @param model (optional) 
     * @return Success
     */
    update(model: EventCategoryFormModel | null | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/v1/eventCategory/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <boolean>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/v1/eventCategory/delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(id);

        let options_ = <RequestInit>{
            body: content_,
            method: "DELETE",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <boolean>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(<any>null);
    }
}

export class GuideService {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param guideName (optional) 
     * @param guideTypeName (optional) 
     * @param createdBy (optional) 
     * @param approvalStatus (optional) 
     * @param sortBy (optional) 
     * @param pageNumber (optional) 
     * @return Success
     */
    getAllJoinGuides(startDate: Date | null | undefined, endDate: Date | null | undefined, guideName: string | null | undefined, guideTypeName: string | null | undefined, createdBy: string | null | undefined, approvalStatus: string | null | undefined, sortBy: string | null | undefined, pageNumber: number | null | undefined): Promise<GuideJoinViewModel> {
        let url_ = this.baseUrl + "/api/v1/guide/get-all-join-guides?";
        if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        if (guideName !== undefined)
            url_ += "GuideName=" + encodeURIComponent("" + guideName) + "&"; 
        if (guideTypeName !== undefined)
            url_ += "GuideTypeName=" + encodeURIComponent("" + guideTypeName) + "&"; 
        if (createdBy !== undefined)
            url_ += "CreatedBy=" + encodeURIComponent("" + createdBy) + "&"; 
        if (approvalStatus !== undefined)
            url_ += "ApprovalStatus=" + encodeURIComponent("" + approvalStatus) + "&"; 
        if (sortBy !== undefined)
            url_ += "SortBy=" + encodeURIComponent("" + sortBy) + "&"; 
        if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllJoinGuides(_response);
        });
    }

    protected processGetAllJoinGuides(response: Response): Promise<GuideJoinViewModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <GuideJoinViewModel>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GuideJoinViewModel>(<any>null);
    }

    /**
     * @return Success
     */
    getJoinGuideById(id: number): Promise<GuideJoinModel> {
        let url_ = this.baseUrl + "/api/v1/guide/get-join-guide-by-id/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetJoinGuideById(_response);
        });
    }

    protected processGetJoinGuideById(response: Response): Promise<GuideJoinModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <GuideJoinModel>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GuideJoinModel>(<any>null);
    }

    /**
     * @param model (optional) 
     * @return Success
     */
    create(model: GuideFormModel | null | undefined): Promise<number> {
        let url_ = this.baseUrl + "/api/v1/guide/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: Response): Promise<number> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <number>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<number>(<any>null);
    }

    /**
     * @param model (optional) 
     * @return Success
     */
    update(model: GuideFormModel | null | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/v1/guide/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <boolean>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/v1/guide/delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(id);

        let options_ = <RequestInit>{
            body: content_,
            method: "DELETE",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <boolean>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(<any>null);
    }
}

export class GuideTypeService {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllGuideTypes(): Promise<GuideTypeViewModel> {
        let url_ = this.baseUrl + "/api/v1/guide-type/get-all-guide-types";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllGuideTypes(_response);
        });
    }

    protected processGetAllGuideTypes(response: Response): Promise<GuideTypeViewModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <GuideTypeViewModel>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GuideTypeViewModel>(<any>null);
    }

    /**
     * @return Success
     */
    getGuideTypeById(id: number): Promise<GuideTypeModel> {
        let url_ = this.baseUrl + "/api/v1/guide-type/get-guide-type-by-id/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetGuideTypeById(_response);
        });
    }

    protected processGetGuideTypeById(response: Response): Promise<GuideTypeModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <GuideTypeModel>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GuideTypeModel>(<any>null);
    }
}

export class HobbyService {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param hobbyName (optional) 
     * @param sortBy (optional) 
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    getAllHobbies(hobbyName: string | null | undefined, sortBy: string | null | undefined, pageIndex: number | null | undefined, pageSize: number | null | undefined): Promise<HobbyGridModel> {
        let url_ = this.baseUrl + "/api/v1/hobby/get-all-hobbies?";
        if (hobbyName !== undefined)
            url_ += "HobbyName=" + encodeURIComponent("" + hobbyName) + "&"; 
        if (sortBy !== undefined)
            url_ += "SortBy=" + encodeURIComponent("" + sortBy) + "&"; 
        if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&"; 
        if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllHobbies(_response);
        });
    }

    protected processGetAllHobbies(response: Response): Promise<HobbyGridModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <HobbyGridModel>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<HobbyGridModel>(<any>null);
    }

    /**
     * @param model (optional) 
     * @return Success
     */
    insertHobby(model: HobbyCreateModel | null | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/v1/hobby/insert-hobby";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processInsertHobby(_response);
        });
    }

    protected processInsertHobby(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <boolean>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(<any>null);
    }

    /**
     * @param hobbyId (optional) 
     * @return Success
     */
    getHobbyById(hobbyId: number | null | undefined): Promise<HobbyViewModel> {
        let url_ = this.baseUrl + "/api/v1/hobby/get-hobby-by-id?";
        if (hobbyId !== undefined)
            url_ += "hobbyId=" + encodeURIComponent("" + hobbyId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetHobbyById(_response);
        });
    }

    protected processGetHobbyById(response: Response): Promise<HobbyViewModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <HobbyViewModel>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<HobbyViewModel>(<any>null);
    }

    /**
     * @param model (optional) 
     * @return Success
     */
    updateHobby(model: HobbyUpdateModel | null | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/v1/hobby/update-hobby";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateHobby(_response);
        });
    }

    protected processUpdateHobby(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <boolean>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(<any>null);
    }

    /**
     * @param hobbyId (optional) 
     * @return Success
     */
    deleteHobby(hobbyId: number | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/v1/hobby/delete-hobby?";
        if (hobbyId !== undefined)
            url_ += "hobbyId=" + encodeURIComponent("" + hobbyId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteHobby(_response);
        });
    }

    protected processDeleteHobby(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }
}

export class InboxService {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param search (optional) 
     * @param sortBy (optional) 
     * @param pageNumber (optional) 
     * @return Success
     */
    getInbox(search: string | null | undefined, sortBy: string | null | undefined, pageNumber: number | null | undefined): Promise<InboxViewModel> {
        let url_ = this.baseUrl + "/api/v1/inbox/get-inbox?";
        if (search !== undefined)
            url_ += "Search=" + encodeURIComponent("" + search) + "&"; 
        if (sortBy !== undefined)
            url_ += "SortBy=" + encodeURIComponent("" + sortBy) + "&"; 
        if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetInbox(_response);
        });
    }

    protected processGetInbox(response: Response): Promise<InboxViewModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <InboxViewModel>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<InboxViewModel>(<any>null);
    }

    /**
     * @return Success
     */
    getUnreadInboxCount(): Promise<number> {
        let url_ = this.baseUrl + "/api/v1/inbox/get-unread-inbox-count";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetUnreadInboxCount(_response);
        });
    }

    protected processGetUnreadInboxCount(response: Response): Promise<number> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <number>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<number>(<any>null);
    }

    /**
     * @return Success
     */
    getApproval(approvalId: number, inboxId: number): Promise<ApprovalInboxModel> {
        let url_ = this.baseUrl + "/api/v1/inbox/get-approval/{approvalId}/{inboxId}";
        if (approvalId === undefined || approvalId === null)
            throw new Error("The parameter 'approvalId' must be defined.");
        url_ = url_.replace("{approvalId}", encodeURIComponent("" + approvalId)); 
        if (inboxId === undefined || inboxId === null)
            throw new Error("The parameter 'inboxId' must be defined.");
        url_ = url_.replace("{inboxId}", encodeURIComponent("" + inboxId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetApproval(_response);
        });
    }

    protected processGetApproval(response: Response): Promise<ApprovalInboxModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ApprovalInboxModel>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApprovalInboxModel>(<any>null);
    }
}

export class KeyActionService {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param keyActionCode (optional) 
     * @param keyActionName (optional) 
     * @param sortBy (optional) 
     * @param pageNumber (optional) 
     * @return Success
     */
    gets(startDate: Date | null | undefined, endDate: Date | null | undefined, keyActionCode: string | null | undefined, keyActionName: string | null | undefined, sortBy: string | null | undefined, pageNumber: number | null | undefined): Promise<KeyActionViewModel> {
        let url_ = this.baseUrl + "/api/v1/key-action/gets?";
        if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        if (keyActionCode !== undefined)
            url_ += "KeyActionCode=" + encodeURIComponent("" + keyActionCode) + "&"; 
        if (keyActionName !== undefined)
            url_ += "KeyActionName=" + encodeURIComponent("" + keyActionName) + "&"; 
        if (sortBy !== undefined)
            url_ += "SortBy=" + encodeURIComponent("" + sortBy) + "&"; 
        if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGets(_response);
        });
    }

    protected processGets(response: Response): Promise<KeyActionViewModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <KeyActionViewModel>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<KeyActionViewModel>(<any>null);
    }

    /**
     * @return Success
     */
    checkUnique(keyActionCode: string): Promise<boolean> {
        let url_ = this.baseUrl + "/api/v1/key-action/check-unique/{keyActionCode}";
        if (keyActionCode === undefined || keyActionCode === null)
            throw new Error("The parameter 'keyActionCode' must be defined.");
        url_ = url_.replace("{keyActionCode}", encodeURIComponent("" + keyActionCode)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCheckUnique(_response);
        });
    }

    protected processCheckUnique(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <boolean>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(<any>null);
    }

    /**
     * @return Success
     */
    getKeyActionById(id: number): Promise<KeyActionModel> {
        let url_ = this.baseUrl + "/api/v1/key-action/get-key-action-by-id/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetKeyActionById(_response);
        });
    }

    protected processGetKeyActionById(response: Response): Promise<KeyActionModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <KeyActionModel>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<KeyActionModel>(<any>null);
    }

    /**
     * @return Success
     */
    getAllKeyAction(page: number): Promise<KeyActionViewModel> {
        let url_ = this.baseUrl + "/api/v1/key-action/get-all-key-action/{page}";
        if (page === undefined || page === null)
            throw new Error("The parameter 'page' must be defined.");
        url_ = url_.replace("{page}", encodeURIComponent("" + page)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllKeyAction(_response);
        });
    }

    protected processGetAllKeyAction(response: Response): Promise<KeyActionViewModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <KeyActionViewModel>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<KeyActionViewModel>(<any>null);
    }

    /**
     * @return Success
     */
    getAllKeyActions(): Promise<KeyActionModel[]> {
        let url_ = this.baseUrl + "/api/v1/key-action/get-all-key-actions";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllKeyActions(_response);
        });
    }

    protected processGetAllKeyActions(response: Response): Promise<KeyActionModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <KeyActionModel[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<KeyActionModel[]>(<any>null);
    }

    /**
     * @param model (optional) 
     * @return Success
     */
    postKeyAction(model: KeyActionFormModel | null | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/v1/key-action/post-key-action";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPostKeyAction(_response);
        });
    }

    protected processPostKeyAction(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <boolean>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(<any>null);
    }

    /**
     * @return Success
     */
    deleteKeyAction(id: number): Promise<void> {
        let url_ = this.baseUrl + "/api/v1/key-action/delete-key-action/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteKeyAction(_response);
        });
    }

    protected processDeleteKeyAction(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param model (optional) 
     * @return Success
     */
    updateKeyAction(model: KeyActionFormModel | null | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/v1/key-action/update-key-action";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateKeyAction(_response);
        });
    }

    protected processUpdateKeyAction(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <boolean>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(<any>null);
    }
}

export class LearningTypeService {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllLearningTypes(): Promise<LearningTypeViewModel> {
        let url_ = this.baseUrl + "/api/v1/learning-type/get-all-learning-types";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllLearningTypes(_response);
        });
    }

    protected processGetAllLearningTypes(response: Response): Promise<LearningTypeViewModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <LearningTypeViewModel>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<LearningTypeViewModel>(<any>null);
    }

    /**
     * @return Success
     */
    getLearningTypeById(id: number): Promise<LearningTypeModel> {
        let url_ = this.baseUrl + "/api/v1/learning-type/get-learning-type-by-id/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetLearningTypeById(_response);
        });
    }

    protected processGetLearningTypeById(response: Response): Promise<LearningTypeModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <LearningTypeModel>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<LearningTypeModel>(<any>null);
    }
}

export class LevelService {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllLevels(): Promise<LevelViewModel> {
        let url_ = this.baseUrl + "/api/v1/level/get-all-levels";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllLevels(_response);
        });
    }

    protected processGetAllLevels(response: Response): Promise<LevelViewModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <LevelViewModel>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<LevelViewModel>(<any>null);
    }

    /**
     * @return Success
     */
    getLevelById(id: number): Promise<LevelModel> {
        let url_ = this.baseUrl + "/api/v1/level/get-level-by-id/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetLevelById(_response);
        });
    }

    protected processGetLevelById(response: Response): Promise<LevelModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <LevelModel>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<LevelModel>(<any>null);
    }
}

export class NewsService {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @return Success
     */
    getPaginate(filter: MasterNewsFilterModel | null | undefined): Promise<ResponseMasterNewsModel> {
        let url_ = this.baseUrl + "/api/master/news/get-paginate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(filter);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetPaginate(_response);
        });
    }

    protected processGetPaginate(response: Response): Promise<ResponseMasterNewsModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ResponseMasterNewsModel>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ResponseMasterNewsModel>(<any>null);
    }

    /**
     * @return Success
     */
    getDetail(id: number): Promise<MasterNewsFormModel> {
        let url_ = this.baseUrl + "/api/master/news/get-detail/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetDetail(_response);
        });
    }

    protected processGetDetail(response: Response): Promise<MasterNewsFormModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <MasterNewsFormModel>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<MasterNewsFormModel>(<any>null);
    }

    /**
     * @param model (optional) 
     * @return Success
     */
    insert(model: MasterNewsFormModel | null | undefined, type: string): Promise<string> {
        let url_ = this.baseUrl + "/api/master/news/insert/{type}";
        if (type === undefined || type === null)
            throw new Error("The parameter 'type' must be defined.");
        url_ = url_.replace("{type}", encodeURIComponent("" + type)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processInsert(_response);
        });
    }

    protected processInsert(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <string>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(<any>null);
    }

    /**
     * @param model (optional) 
     * @return Success
     */
    update(model: MasterNewsFormModel | null | undefined, type: string): Promise<string> {
        let url_ = this.baseUrl + "/api/master/news/update/{type}";
        if (type === undefined || type === null)
            throw new Error("The parameter 'type' must be defined.");
        url_ = url_.replace("{type}", encodeURIComponent("" + type)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <string>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(<any>null);
    }

    /**
     * @return Success
     */
    changeStatus(id: number, type: string): Promise<string> {
        let url_ = this.baseUrl + "/api/master/news/change-status/{id}/{type}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        if (type === undefined || type === null)
            throw new Error("The parameter 'type' must be defined.");
        url_ = url_.replace("{type}", encodeURIComponent("" + type)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processChangeStatus(_response);
        });
    }

    protected processChangeStatus(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <string>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(<any>null);
    }

    /**
     * @return Success
     */
    delete(id: number): Promise<string> {
        let url_ = this.baseUrl + "/api/master/news/delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <string>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(<any>null);
    }
}

export class MdmService {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param models (optional) 
     * @return Success
     */
    user(models: StagingUser[] | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/v1/mdm/user";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(models);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUser(_response);
        });
    }

    protected processUser(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param models (optional) 
     * @return Success
     */
    actualOrganizationStructure(models: StagingActualOrganizationStructure[] | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/v1/mdm/actual-organization-structure";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(models);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processActualOrganizationStructure(_response);
        });
    }

    protected processActualOrganizationStructure(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param models (optional) 
     * @return Success
     */
    organizationObject(models: StagingOrganizationObject[] | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/v1/mdm/organization-object";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(models);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processOrganizationObject(_response);
        });
    }

    protected processOrganizationObject(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param models (optional) 
     * @return Success
     */
    dealerEmployee(models: StagingDealerEmployee[] | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/v1/mdm/dealer-employee";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(models);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDealerEmployee(_response);
        });
    }

    protected processDealerEmployee(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param models (optional) 
     * @return Success
     */
    manpowerPositionType(models: StagingManpowerPositionType[] | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/v1/mdm/manpower-position-type";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(models);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processManpowerPositionType(_response);
        });
    }

    protected processManpowerPositionType(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param models (optional) 
     * @return Success
     */
    manpowerType(models: StagingManpowerType[] | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/v1/mdm/manpower-type";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(models);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processManpowerType(_response);
        });
    }

    protected processManpowerType(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param models (optional) 
     * @return Success
     */
    outlet(models: StagingOutlet[] | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/v1/mdm/outlet";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(models);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processOutlet(_response);
        });
    }

    protected processOutlet(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param models (optional) 
     * @return Success
     */
    region(models: StagingRegion[] | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/v1/mdm/region";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(models);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRegion(_response);
        });
    }

    protected processRegion(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param models (optional) 
     * @return Success
     */
    salesArea(models: StagingSalesArea[] | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/v1/mdm/sales-area";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(models);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSalesArea(_response);
        });
    }

    protected processSalesArea(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param models (optional) 
     * @return Success
     */
    afterSalesArea(models: StagingAfterSalesArea[] | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/v1/mdm/after-sales-area";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(models);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAfterSalesArea(_response);
        });
    }

    protected processAfterSalesArea(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param models (optional) 
     * @return Success
     */
    dealerGroup(models: StagingDealerGroup[] | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/v1/mdm/dealer-group";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(models);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDealerGroup(_response);
        });
    }

    protected processDealerGroup(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param models (optional) 
     * @return Success
     */
    dealerCompany(models: StagingDealerCompany[] | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/v1/mdm/dealer-company";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(models);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDealerCompany(_response);
        });
    }

    protected processDealerCompany(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }
}

export class ModulesService {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param moduleName (optional) 
     * @param materialTypeId (optional) 
     * @param topicName (optional) 
     * @param approvalStatus (optional) 
     * @param dateStart (optional) 
     * @param dateEnd (optional) 
     * @param sortBy (optional) 
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    getAllModule(moduleName: string | null | undefined, materialTypeId: number | null | undefined, topicName: string | null | undefined, approvalStatus: number | null | undefined, dateStart: Date | null | undefined, dateEnd: Date | null | undefined, sortBy: string | null | undefined, pageIndex: number | null | undefined, pageSize: number | null | undefined): Promise<ModuleGridModel> {
        let url_ = this.baseUrl + "/api/v1/modules/get-all-module?";
        if (moduleName !== undefined)
            url_ += "ModuleName=" + encodeURIComponent("" + moduleName) + "&"; 
        if (materialTypeId !== undefined)
            url_ += "MaterialTypeId=" + encodeURIComponent("" + materialTypeId) + "&"; 
        if (topicName !== undefined)
            url_ += "TopicName=" + encodeURIComponent("" + topicName) + "&"; 
        if (approvalStatus !== undefined)
            url_ += "ApprovalStatus=" + encodeURIComponent("" + approvalStatus) + "&"; 
        if (dateStart !== undefined)
            url_ += "DateStart=" + encodeURIComponent(dateStart ? "" + dateStart.toJSON() : "") + "&"; 
        if (dateEnd !== undefined)
            url_ += "DateEnd=" + encodeURIComponent(dateEnd ? "" + dateEnd.toJSON() : "") + "&"; 
        if (sortBy !== undefined)
            url_ += "SortBy=" + encodeURIComponent("" + sortBy) + "&"; 
        if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&"; 
        if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllModule(_response);
        });
    }

    protected processGetAllModule(response: Response): Promise<ModuleGridModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ModuleGridModel>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ModuleGridModel>(<any>null);
    }

    /**
     * @param model (optional) 
     * @return Success
     */
    insertModule(model: ModuleCreateModel | null | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/v1/modules/insert-module";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processInsertModule(_response);
        });
    }

    protected processInsertModule(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <boolean>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(<any>null);
    }

    /**
     * @param moduleId (optional) 
     * @return Success
     */
    getModuleById(moduleId: number | null | undefined): Promise<ModuleViewDetailModel> {
        let url_ = this.baseUrl + "/api/v1/modules/get-module-by-id?";
        if (moduleId !== undefined)
            url_ += "moduleId=" + encodeURIComponent("" + moduleId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetModuleById(_response);
        });
    }

    protected processGetModuleById(response: Response): Promise<ModuleViewDetailModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ModuleViewDetailModel>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ModuleViewDetailModel>(<any>null);
    }

    /**
     * @param model (optional) 
     * @return Success
     */
    updateModuleById(model: ModuleUpdateModel | null | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/v1/modules/update-module-by-id";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateModuleById(_response);
        });
    }

    protected processUpdateModuleById(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <boolean>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(<any>null);
    }

    /**
     * @param model (optional) 
     * @return Success
     */
    deleteModule(model: DeleteModuleModel | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/v1/modules/delete-module";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ = <RequestInit>{
            body: content_,
            method: "DELETE",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteModule(_response);
        });
    }

    protected processDeleteModule(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }
}

export class PointTypeService {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllPointTypeAsync(): Promise<PointTypeViewModel[]> {
        let url_ = this.baseUrl + "/api/v1/point-type/get-all-point-type-async";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllPointTypeAsync(_response);
        });
    }

    protected processGetAllPointTypeAsync(response: Response): Promise<PointTypeViewModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <PointTypeViewModel[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PointTypeViewModel[]>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getPointTypeById(id: number | null | undefined): Promise<string> {
        let url_ = this.baseUrl + "/api/v1/point-type/get-point-type-by-id?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetPointTypeById(_response);
        });
    }

    protected processGetPointTypeById(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <string>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(<any>null);
    }
}

export class PositionMapService {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getDetailMapping(id: number): Promise<PositionMapFormModel> {
        let url_ = this.baseUrl + "/api/master/position-map/get-detail-mapping/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetDetailMapping(_response);
        });
    }

    protected processGetDetailMapping(response: Response): Promise<PositionMapFormModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <PositionMapFormModel>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PositionMapFormModel>(<any>null);
    }

    /**
     * @return Success
     */
    getDetail(positionId: number): Promise<PositionMapFormModel> {
        let url_ = this.baseUrl + "/api/master/position-map/get-detail/{positionId}";
        if (positionId === undefined || positionId === null)
            throw new Error("The parameter 'positionId' must be defined.");
        url_ = url_.replace("{positionId}", encodeURIComponent("" + positionId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetDetail(_response);
        });
    }

    protected processGetDetail(response: Response): Promise<PositionMapFormModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <PositionMapFormModel>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PositionMapFormModel>(<any>null);
    }

    /**
     * @return Success
     */
    getList(positionId: number): Promise<DropDownModel[]> {
        let url_ = this.baseUrl + "/api/master/position-map/get-list/{positionId}";
        if (positionId === undefined || positionId === null)
            throw new Error("The parameter 'positionId' must be defined.");
        url_ = url_.replace("{positionId}", encodeURIComponent("" + positionId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetList(_response);
        });
    }

    protected processGetList(response: Response): Promise<DropDownModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <DropDownModel[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DropDownModel[]>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @return Success
     */
    getPaginate(filter: PositionMapFilterModel | null | undefined): Promise<ResponsePositionMapModel> {
        let url_ = this.baseUrl + "/api/master/position-map/get-paginate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(filter);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetPaginate(_response);
        });
    }

    protected processGetPaginate(response: Response): Promise<ResponsePositionMapModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ResponsePositionMapModel>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ResponsePositionMapModel>(<any>null);
    }

    /**
     * @param model (optional) 
     * @return Success
     */
    insert(model: PositionMapFormModel | null | undefined): Promise<string> {
        let url_ = this.baseUrl + "/api/master/position-map/insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processInsert(_response);
        });
    }

    protected processInsert(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <string>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(<any>null);
    }

    /**
     * @param model (optional) 
     * @return Success
     */
    update(model: PositionMapFormModel | null | undefined): Promise<string> {
        let url_ = this.baseUrl + "/api/master/position-map/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <string>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(<any>null);
    }

    /**
     * @return Success
     */
    delete(id: number): Promise<string> {
        let url_ = this.baseUrl + "/api/master/position-map/delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <string>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(<any>null);
    }

    /**
     * @param deleteModel (optional) 
     * @return Success
     */
    deleteModel(deleteModel: PositionMapDeleteModel | null | undefined): Promise<string> {
        let url_ = this.baseUrl + "/api/master/position-map/delete-model";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(deleteModel);

        let options_ = <RequestInit>{
            body: content_,
            method: "DELETE",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteModel(_response);
        });
    }

    protected processDeleteModel(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <string>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(<any>null);
    }
}

export class ProgramTypeService {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllProgramTypes(): Promise<ProgramTypeViewModel> {
        let url_ = this.baseUrl + "/api/v1/program-type/get-all-program-types";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllProgramTypes(_response);
        });
    }

    protected processGetAllProgramTypes(response: Response): Promise<ProgramTypeViewModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ProgramTypeViewModel>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ProgramTypeViewModel>(<any>null);
    }

    /**
     * @return Success
     */
    getProgramTypeById(id: number): Promise<ProgramTypeModel> {
        let url_ = this.baseUrl + "/api/v1/program-type/get-program-type-by-id/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetProgramTypeById(_response);
        });
    }

    protected processGetProgramTypeById(response: Response): Promise<ProgramTypeModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ProgramTypeModel>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ProgramTypeModel>(<any>null);
    }
}

export class ReleaseTrainingService {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getCourseSetupLearning(courseName: string): Promise<CourseReleaseTrainingModel[]> {
        let url_ = this.baseUrl + "/api/v1/release-training/get-course-setup-learning?courseName={courseName}";
        if (courseName === undefined || courseName === null)
            throw new Error("The parameter 'courseName' must be defined.");
        url_ = url_.replace("{courseName}", encodeURIComponent("" + courseName)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetCourseSetupLearning(_response);
        });
    }

    protected processGetCourseSetupLearning(response: Response): Promise<CourseReleaseTrainingModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <CourseReleaseTrainingModel[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CourseReleaseTrainingModel[]>(<any>null);
    }

    /**
     * @return Success
     */
    getApprovalStatus(): Promise<ApprovalStatusViewModels[]> {
        let url_ = this.baseUrl + "/api/v1/release-training/get-approval-status";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetApprovalStatus(_response);
        });
    }

    protected processGetApprovalStatus(response: Response): Promise<ApprovalStatusViewModels[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ApprovalStatusViewModels[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApprovalStatusViewModels[]>(<any>null);
    }

    /**
     * @return Success
     */
    getSetupModuleRelase(courseId: number): Promise<ReleaseTrainingSetupModuleModel[]> {
        let url_ = this.baseUrl + "/api/v1/release-training/get-setup-module-relase/{courseId}";
        if (courseId === undefined || courseId === null)
            throw new Error("The parameter 'courseId' must be defined.");
        url_ = url_.replace("{courseId}", encodeURIComponent("" + courseId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetSetupModuleRelase(_response);
        });
    }

    protected processGetSetupModuleRelase(response: Response): Promise<ReleaseTrainingSetupModuleModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ReleaseTrainingSetupModuleModel[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ReleaseTrainingSetupModuleModel[]>(<any>null);
    }

    /**
     * @return Success
     */
    getBatch(courseId: number): Promise<number> {
        let url_ = this.baseUrl + "/api/v1/release-training/get-batch/{courseId}";
        if (courseId === undefined || courseId === null)
            throw new Error("The parameter 'courseId' must be defined.");
        url_ = url_.replace("{courseId}", encodeURIComponent("" + courseId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetBatch(_response);
        });
    }

    protected processGetBatch(response: Response): Promise<number> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <number>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<number>(<any>null);
    }

    /**
     * @param model (optional) 
     * @return Success
     */
    insertRelaseTraining(model: ReleaseTrainingFormModel | null | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/v1/release-training/insert-relase-training";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processInsertRelaseTraining(_response);
        });
    }

    protected processInsertRelaseTraining(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <boolean>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(<any>null);
    }

    /**
     * @return Success
     */
    getCoachForReleaseTraining(coachName: string): Promise<CoachForReleaseTraining[]> {
        let url_ = this.baseUrl + "/api/v1/release-training/get-coach-for-release-training/{coachName}";
        if (coachName === undefined || coachName === null)
            throw new Error("The parameter 'coachName' must be defined.");
        url_ = url_.replace("{coachName}", encodeURIComponent("" + coachName)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetCoachForReleaseTraining(_response);
        });
    }

    protected processGetCoachForReleaseTraining(response: Response): Promise<CoachForReleaseTraining[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <CoachForReleaseTraining[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CoachForReleaseTraining[]>(<any>null);
    }

    /**
     * @return Success
     */
    getTeachingTimePoints(): Promise<TeachingTimepPointsModel[]> {
        let url_ = this.baseUrl + "/api/v1/release-training/get-teaching-time-points";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetTeachingTimePoints(_response);
        });
    }

    protected processGetTeachingTimePoints(response: Response): Promise<TeachingTimepPointsModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <TeachingTimepPointsModel[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TeachingTimepPointsModel[]>(<any>null);
    }

    /**
     * @param outletId (optional) 
     * @return Success
     */
    getAllPositionByOutlet(outletId: string | null | undefined): Promise<PositionViewModel[]> {
        let url_ = this.baseUrl + "/api/v1/release-training/get-all-position-by-outlet";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "outletId": outletId !== undefined && outletId !== null ? "" + outletId : "",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllPositionByOutlet(_response);
        });
    }

    protected processGetAllPositionByOutlet(response: Response): Promise<PositionViewModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <PositionViewModel[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PositionViewModel[]>(<any>null);
    }

    /**
     * @return Success
     */
    getAllPosition(): Promise<PositionViewModel[]> {
        let url_ = this.baseUrl + "/api/v1/release-training/get-all-position";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllPosition(_response);
        });
    }

    protected processGetAllPosition(response: Response): Promise<PositionViewModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <PositionViewModel[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PositionViewModel[]>(<any>null);
    }

    /**
     * @return Success
     */
    getAllArea(): Promise<AreaViewModel[]> {
        let url_ = this.baseUrl + "/api/v1/release-training/get-all-area";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllArea(_response);
        });
    }

    protected processGetAllArea(response: Response): Promise<AreaViewModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <AreaViewModel[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AreaViewModel[]>(<any>null);
    }

    /**
     * @return Success
     */
    getAllDealer(): Promise<DealerViewModel[]> {
        let url_ = this.baseUrl + "/api/v1/release-training/get-all-dealer";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllDealer(_response);
        });
    }

    protected processGetAllDealer(response: Response): Promise<DealerViewModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <DealerViewModel[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DealerViewModel[]>(<any>null);
    }

    /**
     * @return Success
     */
    getAllProvince(): Promise<ProvinceViewModel[]> {
        let url_ = this.baseUrl + "/api/v1/release-training/get-all-province";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllProvince(_response);
        });
    }

    protected processGetAllProvince(response: Response): Promise<ProvinceViewModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ProvinceViewModel[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ProvinceViewModel[]>(<any>null);
    }

    /**
     * @return Success
     */
    getAllCity(): Promise<CityViewModel[]> {
        let url_ = this.baseUrl + "/api/v1/release-training/get-all-city";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllCity(_response);
        });
    }

    protected processGetAllCity(response: Response): Promise<CityViewModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <CityViewModel[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CityViewModel[]>(<any>null);
    }

    /**
     * @return Success
     */
    getAllOutlet(): Promise<OutletCompleteViewModel[]> {
        let url_ = this.baseUrl + "/api/v1/release-training/get-all-outlet";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllOutlet(_response);
        });
    }

    protected processGetAllOutlet(response: Response): Promise<OutletCompleteViewModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <OutletCompleteViewModel[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<OutletCompleteViewModel[]>(<any>null);
    }

    /**
     * @param filterJson (optional) 
     * @return Success
     */
    getOutletFiltered(filterJson: string | null | undefined): Promise<OutletViewModel[]> {
        let url_ = this.baseUrl + "/api/v1/release-training/get-outlet-filtered";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "filterJson": filterJson !== undefined && filterJson !== null ? "" + filterJson : "",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetOutletFiltered(_response);
        });
    }

    protected processGetOutletFiltered(response: Response): Promise<OutletViewModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <OutletViewModel[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<OutletViewModel[]>(<any>null);
    }

    /**
     * @param filterJson (optional) 
     * @return Success
     */
    getOutletFilteredId(filterJson: string | null | undefined): Promise<OutletViewModel[]> {
        let url_ = this.baseUrl + "/api/v1/release-training/get-outlet-filtered-id";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "filterJson": filterJson !== undefined && filterJson !== null ? "" + filterJson : "",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetOutletFilteredId(_response);
        });
    }

    protected processGetOutletFilteredId(response: Response): Promise<OutletViewModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <OutletViewModel[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<OutletViewModel[]>(<any>null);
    }

    /**
     * @param courseName (optional) 
     * @param batch (optional) 
     * @param approvalStatusId (optional) 
     * @param dateFilterStart (optional) 
     * @param dateFilterEnd (optional) 
     * @param enrollmentStartDate (optional) 
     * @param enrollmentEndDate (optional) 
     * @param sortBy (optional) 
     * @param pageNumber (optional) 
     * @return Success
     */
    getReleaseTraining(courseName: string | null | undefined, batch: number | null | undefined, approvalStatusId: number | null | undefined, dateFilterStart: Date | null | undefined, dateFilterEnd: Date | null | undefined, enrollmentStartDate: Date | null | undefined, enrollmentEndDate: Date | null | undefined, sortBy: string | null | undefined, pageNumber: number | null | undefined, programTypeId?: number | null | undefined): Promise<ReleaseTrainingViewModel> {
        let url_ = this.baseUrl + "/api/v1/release-training/get-release-training?";
        if (courseName !== undefined)
            url_ += "CourseName=" + encodeURIComponent("" + courseName) + "&"; 
        if (batch !== undefined)
            url_ += "Batch=" + encodeURIComponent("" + batch) + "&"; 
        if (approvalStatusId !== undefined)
            url_ += "ApprovalStatusId=" + encodeURIComponent("" + approvalStatusId) + "&"; 
        if (dateFilterStart !== undefined)
            url_ += "DateFilterStart=" + encodeURIComponent(dateFilterStart ? "" + dateFilterStart.toJSON() : "") + "&"; 
        if (dateFilterEnd !== undefined)
            url_ += "DateFilterEnd=" + encodeURIComponent(dateFilterEnd ? "" + dateFilterEnd.toJSON() : "") + "&"; 
        if (enrollmentStartDate !== undefined)
            url_ += "EnrollmentStartDate=" + encodeURIComponent(enrollmentStartDate ? "" + enrollmentStartDate.toJSON() : "") + "&"; 
        if (enrollmentEndDate !== undefined)
            url_ += "EnrollmentEndDate=" + encodeURIComponent(enrollmentEndDate ? "" + enrollmentEndDate.toJSON() : "") + "&"; 
        if (sortBy !== undefined)
            url_ += "SortBy=" + encodeURIComponent("" + sortBy) + "&"; 
        if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&"; 
        if (programTypeId !== undefined)
            url_ += "ProgramTypeId=" + encodeURIComponent("" + programTypeId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetReleaseTraining(_response);
        });
    }

    protected processGetReleaseTraining(response: Response): Promise<ReleaseTrainingViewModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ReleaseTrainingViewModel>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ReleaseTrainingViewModel>(<any>null);
    }

    /**
     * @param courseName (optional) 
     * @param batch (optional) 
     * @param approvalStatusId (optional) 
     * @param dateFilterStart (optional) 
     * @param dateFilterEnd (optional) 
     * @param enrollmentStartDate (optional) 
     * @param enrollmentEndDate (optional) 
     * @param sortBy (optional) 
     * @param pageNumber (optional) 
     * @return Success
     */
     getReleaseTrainingReport(courseName: string | null | undefined, batch: number | null | undefined, approvalStatusId: number | null | undefined, dateFilterStart: Date | null | undefined, dateFilterEnd: Date | null | undefined, enrollmentStartDate: Date | null | undefined, enrollmentEndDate: Date | null | undefined, sortBy: string | null | undefined, pageNumber: number | null | undefined, programTypeId?: number | null | undefined, dealerId?: number | null | undefined): Promise<ReleaseTrainingViewModel> {
        let url_ = this.baseUrl + "/api/v1/release-training/get-release-training-by-dealer?";
        if (courseName !== undefined)
            url_ += "CourseName=" + encodeURIComponent("" + courseName) + "&"; 
        if (batch !== undefined)
            url_ += "Batch=" + encodeURIComponent("" + batch) + "&"; 
        if (approvalStatusId !== undefined)
            url_ += "ApprovalStatusId=" + encodeURIComponent("" + approvalStatusId) + "&"; 
        if (dateFilterStart !== undefined)
            url_ += "DateFilterStart=" + encodeURIComponent(dateFilterStart ? "" + dateFilterStart.toJSON() : "") + "&"; 
        if (dateFilterEnd !== undefined)
            url_ += "DateFilterEnd=" + encodeURIComponent(dateFilterEnd ? "" + dateFilterEnd.toJSON() : "") + "&"; 
        if (enrollmentStartDate !== undefined)
            url_ += "EnrollmentStartDate=" + encodeURIComponent(enrollmentStartDate ? "" + enrollmentStartDate.toJSON() : "") + "&"; 
        if (enrollmentEndDate !== undefined)
            url_ += "EnrollmentEndDate=" + encodeURIComponent(enrollmentEndDate ? "" + enrollmentEndDate.toJSON() : "") + "&"; 
        if (sortBy !== undefined)
            url_ += "SortBy=" + encodeURIComponent("" + sortBy) + "&"; 
        if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&"; 
        if (programTypeId !== undefined)
            url_ += "ProgramTypeId=" + encodeURIComponent("" + programTypeId) + "&"; 
        if (dealerId !== undefined)
            url_ += "DealerId=" + encodeURIComponent("" + dealerId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetReleaseTrainingReport(_response);
        });
    }

    protected processGetReleaseTrainingReport(response: Response): Promise<ReleaseTrainingViewModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ReleaseTrainingViewModel>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ReleaseTrainingViewModel>(<any>null);
    }

    /**
     * @param courseName (optional) 
     * @param batch (optional) 
     * @param approvalStatusId (optional) 
     * @param dateFilterStart (optional) 
     * @param dateFilterEnd (optional) 
     * @param enrollmentStartDate (optional) 
     * @param enrollmentEndDate (optional) 
     * @param sortBy (optional) 
     * @param pageNumber (optional) 
     * @return Success
     */
    getRelatedReleaseTraining(courseName: string | null | undefined, batch: number | null | undefined, approvalStatusId: number | null | undefined, dateFilterStart: Date | null | undefined, dateFilterEnd: Date | null | undefined, enrollmentStartDate: Date | null | undefined, enrollmentEndDate: Date | null | undefined, sortBy: string | null | undefined, pageNumber: number | null | undefined, programTypeId?: number | null | undefined): Promise<ReleaseTrainingViewModel> {
        let url_ = this.baseUrl + "/api/v1/release-training/get-related-release-training?";
        if (courseName !== undefined)
            url_ += "CourseName=" + encodeURIComponent("" + courseName) + "&"; 
        if (batch !== undefined)
            url_ += "Batch=" + encodeURIComponent("" + batch) + "&"; 
        if (approvalStatusId !== undefined)
            url_ += "ApprovalStatusId=" + encodeURIComponent("" + approvalStatusId) + "&"; 
        if (dateFilterStart !== undefined)
            url_ += "DateFilterStart=" + encodeURIComponent(dateFilterStart ? "" + dateFilterStart.toJSON() : "") + "&"; 
        if (dateFilterEnd !== undefined)
            url_ += "DateFilterEnd=" + encodeURIComponent(dateFilterEnd ? "" + dateFilterEnd.toJSON() : "") + "&"; 
        if (enrollmentStartDate !== undefined)
            url_ += "EnrollmentStartDate=" + encodeURIComponent(enrollmentStartDate ? "" + enrollmentStartDate.toJSON() : "") + "&"; 
        if (enrollmentEndDate !== undefined)
            url_ += "EnrollmentEndDate=" + encodeURIComponent(enrollmentEndDate ? "" + enrollmentEndDate.toJSON() : "") + "&"; 
        if (sortBy !== undefined)
            url_ += "SortBy=" + encodeURIComponent("" + sortBy) + "&"; 
        if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&"; 
        if (programTypeId !== undefined)
            url_ += "ProgramTypeId=" + encodeURIComponent("" + programTypeId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetRelatedReleaseTraining(_response);
        });
    }

    protected processGetRelatedReleaseTraining(response: Response): Promise<ReleaseTrainingViewModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ReleaseTrainingViewModel>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ReleaseTrainingViewModel>(<any>null);
    }

    /**
     * @return Success
     */
    getReleaseTrainingDetail(trainingId: number): Promise<RelaseTrainingDetailModel> {
        let url_ = this.baseUrl + "/api/v1/release-training/get-release-training-detail/{trainingId}";
        if (trainingId === undefined || trainingId === null)
            throw new Error("The parameter 'trainingId' must be defined.");
        url_ = url_.replace("{trainingId}", encodeURIComponent("" + trainingId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetReleaseTrainingDetail(_response);
        });
    }

    protected processGetReleaseTrainingDetail(response: Response): Promise<RelaseTrainingDetailModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <RelaseTrainingDetailModel>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<RelaseTrainingDetailModel>(<any>null);
    }

    /**
     * @param model (optional) 
     * @return Success
     */
    updateReleaseTraining(model: ReleaseTrainingFormModel | null | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/v1/release-training/update-release-training";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateReleaseTraining(_response);
        });
    }

    protected processUpdateReleaseTraining(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <boolean>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(<any>null);
    }

    /**
     * @return Success
     */
    deleteReleaseTraining(trainingId: number): Promise<boolean> {
        let url_ = this.baseUrl + "/api/v1/release-training/delete-release-training/{trainingId}";
        if (trainingId === undefined || trainingId === null)
            throw new Error("The parameter 'trainingId' must be defined.");
        url_ = url_.replace("{trainingId}", encodeURIComponent("" + trainingId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteReleaseTraining(_response);
        });
    }

    protected processDeleteReleaseTraining(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <boolean>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(<any>null);
    }

    /**
     * @return Success
     */
    getTotalDetailCourse(courseId: number): Promise<TotalCourseDetail> {
        let url_ = this.baseUrl + "/api/v1/release-training/get-total-detail-course/{courseId}";
        if (courseId === undefined || courseId === null)
            throw new Error("The parameter 'courseId' must be defined.");
        url_ = url_.replace("{courseId}", encodeURIComponent("" + courseId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetTotalDetailCourse(_response);
        });
    }

    protected processGetTotalDetailCourse(response: Response): Promise<TotalCourseDetail> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <TotalCourseDetail>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TotalCourseDetail>(<any>null);
    }
}

export class ReportService {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllReport(): Promise<ReportModel[]> {
        let url_ = this.baseUrl + "/api/v1/report/get-all-report";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllReport(_response);
        });
    }

    protected processGetAllReport(response: Response): Promise<ReportModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ReportModel[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ReportModel[]>(<any>null);
    }
}

export class ReportNpsService {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param pageSize (optional) 
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param courseName (optional) 
     * @param programTypeId (optional) 
     * @param status (optional) 
     * @param batch (optional) 
     * @param sortBy (optional) 
     * @param pageNumber (optional) 
     * @return Success
     */
    getAllReportNps(pageSize: number | null | undefined, startDate: Date | null | undefined, endDate: Date | null | undefined, courseName: string | null | undefined, programTypeId: number | null | undefined, status: string | null | undefined, batch: number | null | undefined, sortBy: string | null | undefined, pageNumber: number | null | undefined): Promise<ReportNPSViewModel> {
        let url_ = this.baseUrl + "/api/v1/report-nps/get-all-report-nps?";
        if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&"; 
        if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        if (courseName !== undefined)
            url_ += "CourseName=" + encodeURIComponent("" + courseName) + "&"; 
        if (programTypeId !== undefined)
            url_ += "ProgramTypeId=" + encodeURIComponent("" + programTypeId) + "&"; 
        if (status !== undefined)
            url_ += "Status=" + encodeURIComponent("" + status) + "&"; 
        if (batch !== undefined)
            url_ += "Batch=" + encodeURIComponent("" + batch) + "&"; 
        if (sortBy !== undefined)
            url_ += "SortBy=" + encodeURIComponent("" + sortBy) + "&"; 
        if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllReportNps(_response);
        });
    }

    protected processGetAllReportNps(response: Response): Promise<ReportNPSViewModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ReportNPSViewModel>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ReportNPSViewModel>(<any>null);
    }
}

export class RewardService {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param dateStart (optional) 
     * @param dateEnd (optional) 
     * @param rewardTypeId (optional) 
     * @param isActive (optional) 
     * @param name (optional) 
     * @param typeOfPoints (optional) 
     * @param sortBy (optional) 
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    getAllReward(dateStart: Date | null | undefined, dateEnd: Date | null | undefined, rewardTypeId: number | null | undefined, isActive: boolean | null | undefined, name: string | null | undefined, typeOfPoints: number | null | undefined, sortBy: string | null | undefined, pageIndex: number | null | undefined, pageSize: number | null | undefined): Promise<RewardGridModel> {
        let url_ = this.baseUrl + "/api/v1/reward/get-all-reward?";
        if (dateStart !== undefined)
            url_ += "DateStart=" + encodeURIComponent(dateStart ? "" + dateStart.toJSON() : "") + "&"; 
        if (dateEnd !== undefined)
            url_ += "DateEnd=" + encodeURIComponent(dateEnd ? "" + dateEnd.toJSON() : "") + "&"; 
        if (rewardTypeId !== undefined)
            url_ += "RewardTypeId=" + encodeURIComponent("" + rewardTypeId) + "&"; 
        if (isActive !== undefined)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&"; 
        if (name !== undefined)
            url_ += "Name=" + encodeURIComponent("" + name) + "&"; 
        if (typeOfPoints !== undefined)
            url_ += "TypeOfPoints=" + encodeURIComponent("" + typeOfPoints) + "&"; 
        if (sortBy !== undefined)
            url_ += "SortBy=" + encodeURIComponent("" + sortBy) + "&"; 
        if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&"; 
        if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllReward(_response);
        });
    }

    protected processGetAllReward(response: Response): Promise<RewardGridModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <RewardGridModel>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<RewardGridModel>(<any>null);
    }

    /**
     * @param model (optional) 
     * @return Success
     */
    insertReward(model: RewardCreateModel | null | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/v1/reward/insert-reward";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processInsertReward(_response);
        });
    }

    protected processInsertReward(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <boolean>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(<any>null);
    }

    /**
     * @param rewardId (optional) 
     * @return Success
     */
    getRewardById(rewardId: number | null | undefined): Promise<RewardViewDetailModel> {
        let url_ = this.baseUrl + "/api/v1/reward/get-reward-by-id?";
        if (rewardId !== undefined)
            url_ += "rewardId=" + encodeURIComponent("" + rewardId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetRewardById(_response);
        });
    }

    protected processGetRewardById(response: Response): Promise<RewardViewDetailModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <RewardViewDetailModel>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<RewardViewDetailModel>(<any>null);
    }

    /**
     * @param model (optional) 
     * @return Success
     */
    updateReward(model: RewardUpdateModel | null | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/v1/reward/update-reward";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateReward(_response);
        });
    }

    protected processUpdateReward(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <boolean>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(<any>null);
    }

    /**
     * @param rewardId (optional) 
     * @return Success
     */
    deleteReward(rewardId: number | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/v1/reward/delete-reward?";
        if (rewardId !== undefined)
            url_ += "rewardId=" + encodeURIComponent("" + rewardId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteReward(_response);
        });
    }

    protected processDeleteReward(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }
}

export class SetupCourseService {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param search (optional) 
     * @return Success
     */
    getAllCourseNoSetup(search: string | null | undefined): Promise<CourseViewModel> {
        let url_ = this.baseUrl + "/api/v1/setup-course/getAllCourseNoSetup?";
        if (search !== undefined)
            url_ += "search=" + encodeURIComponent("" + search) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllCourseNoSetup(_response);
        });
    }

    protected processGetAllCourseNoSetup(response: Response): Promise<CourseViewModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <CourseViewModel>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CourseViewModel>(<any>null);
    }

    /**
     * @param search (optional) 
     * @return Success
     */
    getAllModules(search: string | null | undefined): Promise<ModuleForSetupModel[]> {
        let url_ = this.baseUrl + "/api/v1/setup-course/getAllModules?";
        if (search !== undefined)
            url_ += "search=" + encodeURIComponent("" + search) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllModules(_response);
        });
    }

    protected processGetAllModules(response: Response): Promise<ModuleForSetupModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ModuleForSetupModel[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ModuleForSetupModel[]>(<any>null);
    }

    /**
     * @param search (optional) 
     * @return Success
     */
    getAllPrerequisites(search: string | null | undefined): Promise<CoursePrerequisiteViewModel[]> {
        let url_ = this.baseUrl + "/api/v1/setup-course/getAllPrerequisites?";
        if (search !== undefined)
            url_ += "search=" + encodeURIComponent("" + search) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllPrerequisites(_response);
        });
    }

    protected processGetAllPrerequisites(response: Response): Promise<CoursePrerequisiteViewModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <CoursePrerequisiteViewModel[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CoursePrerequisiteViewModel[]>(<any>null);
    }

    /**
     * @param search (optional) 
     * @return Success
     */
    getAllTaskCompetencies(search: string | null | undefined): Promise<CompetencyMappingJoinModel[]> {
        let url_ = this.baseUrl + "/api/v1/setup-course/getAllTaskCompetencies?";
        if (search !== undefined)
            url_ += "search=" + encodeURIComponent("" + search) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllTaskCompetencies(_response);
        });
    }

    protected processGetAllTaskCompetencies(response: Response): Promise<CompetencyMappingJoinModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <CompetencyMappingJoinModel[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CompetencyMappingJoinModel[]>(<any>null);
    }

    /**
     * @param search (optional) 
     * @return Success
     */
    getAllTaskModules(search: string | null | undefined): Promise<ModuleForSetupModel[]> {
        let url_ = this.baseUrl + "/api/v1/setup-course/getAllTaskModules?";
        if (search !== undefined)
            url_ += "search=" + encodeURIComponent("" + search) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllTaskModules(_response);
        });
    }

    protected processGetAllTaskModules(response: Response): Promise<ModuleForSetupModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ModuleForSetupModel[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ModuleForSetupModel[]>(<any>null);
    }

    /**
     * @param taskCode (optional) 
     * @param competencyId (optional) 
     * @param moduleId (optional) 
     * @return Success
     */
    getAllTaskFiltered(taskCode: string | null | undefined, competencyId: number | null | undefined, moduleId: number | null | undefined): Promise<TaskForSetupModuleModel[]> {
        let url_ = this.baseUrl + "/api/v1/setup-course/getAllTaskFiltered?";
        if (taskCode !== undefined)
            url_ += "TaskCode=" + encodeURIComponent("" + taskCode) + "&"; 
        if (competencyId !== undefined)
            url_ += "CompetencyId=" + encodeURIComponent("" + competencyId) + "&"; 
        if (moduleId !== undefined)
            url_ += "ModuleId=" + encodeURIComponent("" + moduleId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllTaskFiltered(_response);
        });
    }

    protected processGetAllTaskFiltered(response: Response): Promise<TaskForSetupModuleModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <TaskForSetupModuleModel[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TaskForSetupModuleModel[]>(<any>null);
    }

     /**
     * @param taskCode (optional) 
     * @param competencyId (optional) 
     * @param moduleId (optional) 
     * @return Success
     */
    getTaskScorePoint(taskTypeId, taskId): Promise<any[]> {
        let url_ = this.baseUrl + "/api/v1/setup-course/getScorePoints?";
        if (taskTypeId !== undefined)
            url_ += "TaskTypeId=" + encodeURIComponent("" + taskTypeId) + "&"; 
        if (taskId !== undefined)
            url_ += "TaskId=" + encodeURIComponent("" + taskId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetTaskScorePoint(_response);
        });
    }

    protected processGetTaskScorePoint(response: Response): Promise<any> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <any>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<any>(<any>null);
    }

    /**
     * @return Success
     */
    get(id: number): Promise<CourseJoinModel> {
        let url_ = this.baseUrl + "/api/v1/setup-course/get/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<CourseJoinModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <CourseJoinModel>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CourseJoinModel>(<any>null);
    }

    /**
     * @param model (optional) 
     * @return Success
     */
    create(model: SetupCourseFormModel | null | undefined): Promise<number> {
        let url_ = this.baseUrl + "/api/v1/setup-course/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: Response): Promise<number> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <number>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<number>(<any>null);
    }

    createAssessment(model: any): Promise<any> {
        let url_ = this.baseUrl + "/api/assesment/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateAssessment(_response);
        });
    }

    protected processCreateAssessment(response: Response): Promise<any> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <any>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<number>(<any>null);
    }

    updateAssessment(model: any): Promise<any> {
        let url_ = this.baseUrl + "/api/assesment/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processupdateAssessment(_response);
        });
    }

    protected processupdateAssessment(response: Response): Promise<any> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <any>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<number>(<any>null);
    }

}

export class SetupLearningService {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllProgramType(): Promise<string[]> {
        let url_ = this.baseUrl + "/api/v1/setup-learning/get-all-program-type";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllProgramType(_response);
        });
    }

    protected processGetAllProgramType(response: Response): Promise<string[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <string[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string[]>(<any>null);
    }

    /**
     * @return Success
     */
    getAllApprovalStatus(): Promise<string[]> {
        let url_ = this.baseUrl + "/api/v1/setup-learning/get-all-approval-status";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllApprovalStatus(_response);
        });
    }

    protected processGetAllApprovalStatus(response: Response): Promise<string[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <string[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string[]>(<any>null);
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param programType (optional) 
     * @param learningCategory (optional) 
     * @param learningName (optional) 
     * @param approvalStatus (optional) 
     * @param sortBy (optional) 
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    getAllSetupLearning(startDate: Date | null | undefined, endDate: Date | null | undefined, programType: string | null | undefined, learningCategory: string | null | undefined, learningName: string | null | undefined, approvalStatus: string | null | undefined, sortBy: string | null | undefined, pageIndex: number | null | undefined, pageSize: number | null | undefined): Promise<SetupLearningPaginate> {
        let url_ = this.baseUrl + "/api/v1/setup-learning/get-all-setup-learning?";
        if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        if (programType !== undefined)
            url_ += "ProgramType=" + encodeURIComponent("" + programType) + "&"; 
        if (learningCategory !== undefined)
            url_ += "LearningCategory=" + encodeURIComponent("" + learningCategory) + "&"; 
        if (learningName !== undefined)
            url_ += "LearningName=" + encodeURIComponent("" + learningName) + "&"; 
        if (approvalStatus !== undefined)
            url_ += "ApprovalStatus=" + encodeURIComponent("" + approvalStatus) + "&"; 
        if (sortBy !== undefined)
            url_ += "SortBy=" + encodeURIComponent("" + sortBy) + "&"; 
        if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&"; 
        if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllSetupLearning(_response);
        });
    }

    protected processGetAllSetupLearning(response: Response): Promise<SetupLearningPaginate> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <SetupLearningPaginate>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SetupLearningPaginate>(<any>null);
    }

    /**
     * @return Success
     */
    getAllCourseLockUnlock(id: number): Promise<SetupLearningCourseLockUnlock> {
        let url_ = this.baseUrl + "/api/v1/setup-learning/get-all-course-lock-unlock/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllCourseLockUnlock(_response);
        });
    }

    protected processGetAllCourseLockUnlock(response: Response): Promise<SetupLearningCourseLockUnlock> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <SetupLearningCourseLockUnlock>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SetupLearningCourseLockUnlock>(<any>null);
    }

    /**
     * @param course (optional) 
     * @return Success
     */
    courseLockUnlockModule(course: SetupLearningCourseLockUnlock | null | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/v1/setup-learning/course-lock-unlock-module";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(course);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCourseLockUnlockModule(_response);
        });
    }

    protected processCourseLockUnlockModule(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <boolean>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    removeCourse(id: number | null | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/v1/setup-learning/remove-course?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRemoveCourse(_response);
        });
    }

    protected processRemoveCourse(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <boolean>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(<any>null);
    }
}

export class SetupModuleService {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllModule(moduleNameSearch: string): Promise<SetupModuleModuleViewModel[]> {
        let url_ = this.baseUrl + "/api/v1/setup-module/get-all-module/{moduleNameSearch}";
        if (moduleNameSearch === undefined || moduleNameSearch === null)
            throw new Error("The parameter 'moduleNameSearch' must be defined.");
        url_ = url_.replace("{moduleNameSearch}", encodeURIComponent("" + moduleNameSearch)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllModule(_response);
        });
    }

    protected processGetAllModule(response: Response): Promise<SetupModuleModuleViewModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <SetupModuleModuleViewModel[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SetupModuleModuleViewModel[]>(<any>null);
    }

    /**
     * @return Success
     */
    getAllModuleForUpdate(moduleNameSearch: string): Promise<SetupModuleModuleViewModel[]> {
        let url_ = this.baseUrl + "/api/v1/setup-module/get-all-module-for-update/{moduleNameSearch}";
        if (moduleNameSearch === undefined || moduleNameSearch === null)
            throw new Error("The parameter 'moduleNameSearch' must be defined.");
        url_ = url_.replace("{moduleNameSearch}", encodeURIComponent("" + moduleNameSearch)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllModuleForUpdate(_response);
        });
    }

    protected processGetAllModuleForUpdate(response: Response): Promise<SetupModuleModuleViewModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <SetupModuleModuleViewModel[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SetupModuleModuleViewModel[]>(<any>null);
    }

    /**
     * @return Success
     */
    getAllTimePoints(): Promise<TimePointTaskModel[]> {
        let url_ = this.baseUrl + "/api/v1/setup-module/get-all-time-points";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllTimePoints(_response);
        });
    }

    protected processGetAllTimePoints(response: Response): Promise<TimePointTaskModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <TimePointTaskModel[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TimePointTaskModel[]>(<any>null);
    }

    /**
     * @return Success
     */
    getAllCompetenciesSetupModule(name: string): Promise<CompetencyMappingJoinModel[]> {
        let url_ = this.baseUrl + "/api/v1/setup-module/get-all-competencies-setup-module/{name}";
        if (name === undefined || name === null)
            throw new Error("The parameter 'name' must be defined.");
        url_ = url_.replace("{name}", encodeURIComponent("" + name)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllCompetenciesSetupModule(_response);
        });
    }

    protected processGetAllCompetenciesSetupModule(response: Response): Promise<CompetencyMappingJoinModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <CompetencyMappingJoinModel[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CompetencyMappingJoinModel[]>(<any>null);
    }

    /**
     * @return Success
     */
    getAllModuleFromTask(moduleNameSearch: string): Promise<SetupModuleModuleViewModel[]> {
        let url_ = this.baseUrl + "/api/v1/setup-module/get-all-module-from-task/{moduleNameSearch}";
        if (moduleNameSearch === undefined || moduleNameSearch === null)
            throw new Error("The parameter 'moduleNameSearch' must be defined.");
        url_ = url_.replace("{moduleNameSearch}", encodeURIComponent("" + moduleNameSearch)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllModuleFromTask(_response);
        });
    }

    protected processGetAllModuleFromTask(response: Response): Promise<SetupModuleModuleViewModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <SetupModuleModuleViewModel[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SetupModuleModuleViewModel[]>(<any>null);
    }

    /**
     * @return Success
     */
    getAllTaskCode(taskCode: string): Promise<TaskForSetupModuleModel[]> {
        let url_ = this.baseUrl + "/api/v1/setup-module/get-all-task-code/{taskCode}";
        if (taskCode === undefined || taskCode === null)
            throw new Error("The parameter 'taskCode' must be defined.");
        url_ = url_.replace("{taskCode}", encodeURIComponent("" + taskCode)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllTaskCode(_response);
        });
    }

    protected processGetAllTaskCode(response: Response): Promise<TaskForSetupModuleModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <TaskForSetupModuleModel[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TaskForSetupModuleModel[]>(<any>null);
    }

    /**
     * @param taskCode (optional) 
     * @param competencyId (optional) 
     * @param moduleId (optional) 
     * @return Success
     */
    getAllTaskCodeFiltered(taskCode: string | null | undefined, competencyId: number | null | undefined, moduleId: number | null | undefined): Promise<TaskForSetupModuleModel[]> {
        let url_ = this.baseUrl + "/api/v1/setup-module/get-all-task-code-filtered?";
        if (taskCode !== undefined)
            url_ += "TaskCode=" + encodeURIComponent("" + taskCode) + "&"; 
        if (competencyId !== undefined)
            url_ += "CompetencyId=" + encodeURIComponent("" + competencyId) + "&"; 
        if (moduleId !== undefined)
            url_ += "ModuleId=" + encodeURIComponent("" + moduleId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllTaskCodeFiltered(_response);
        });
    }

    protected processGetAllTaskCodeFiltered(response: Response): Promise<TaskForSetupModuleModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <TaskForSetupModuleModel[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TaskForSetupModuleModel[]>(<any>null);
    }

    /**
     * @return Success
     */
    getAllCompetencyFiltered(competencyName: string): Promise<CompetencyMappingJoinModel[]> {
        let url_ = this.baseUrl + "/api/v1/setup-module/get-all-competency-filtered/{competencyName}";
        if (competencyName === undefined || competencyName === null)
            throw new Error("The parameter 'competencyName' must be defined.");
        url_ = url_.replace("{competencyName}", encodeURIComponent("" + competencyName)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllCompetencyFiltered(_response);
        });
    }

    protected processGetAllCompetencyFiltered(response: Response): Promise<CompetencyMappingJoinModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <CompetencyMappingJoinModel[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CompetencyMappingJoinModel[]>(<any>null);
    }

    /**
     * @param taskCode (optional) 
     * @param competencyId (optional) 
     * @param moduleId (optional) 
     * @return Success
     */
    generetaTask(totalTask: number, taskCode: string | null | undefined, competencyId: number | null | undefined, moduleId: number | null | undefined): Promise<TaskForSetupModuleModel[]> {
        let url_ = this.baseUrl + "/api/v1/setup-module/genereta-task/{totalTask}?";
        if (totalTask === undefined || totalTask === null)
            throw new Error("The parameter 'totalTask' must be defined.");
        url_ = url_.replace("{totalTask}", encodeURIComponent("" + totalTask)); 
        if (taskCode !== undefined)
            url_ += "TaskCode=" + encodeURIComponent("" + taskCode) + "&"; 
        if (competencyId !== undefined)
            url_ += "CompetencyId=" + encodeURIComponent("" + competencyId) + "&"; 
        if (moduleId !== undefined)
            url_ += "ModuleId=" + encodeURIComponent("" + moduleId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGeneretaTask(_response);
        });
    }

    protected processGeneretaTask(response: Response): Promise<TaskForSetupModuleModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <TaskForSetupModuleModel[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TaskForSetupModuleModel[]>(<any>null);
    }

    /**
     * @param model (optional) 
     * @return Success
     */
    insertSetupModule(model: SetupModuleFormModel | null | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/v1/setup-module/insert-setup-module";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processInsertSetupModule(_response);
        });
    }

    protected processInsertSetupModule(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <boolean>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(<any>null);
    }

    /**
     * @return Success
     */
    getSetupModuleUpdate(id: number): Promise<SetupModuleFormModel> {
        let url_ = this.baseUrl + "/api/v1/setup-module/get-setup-module-update/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetSetupModuleUpdate(_response);
        });
    }

    protected processGetSetupModuleUpdate(response: Response): Promise<SetupModuleFormModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <SetupModuleFormModel>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SetupModuleFormModel>(<any>null);
    }

    /**
     * @param model (optional) 
     * @return Success
     */
    updateSetupModule(model: SetupModuleFormModel | null | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/v1/setup-module/update-setup-module";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateSetupModule(_response);
        });
    }

    protected processUpdateSetupModule(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <boolean>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(<any>null);
    }

    /**
     * @return Success
     */
    deleteSetupModule(id: number): Promise<boolean> {
        let url_ = this.baseUrl + "/api/v1/setup-module/delete-setup-module/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteSetupModule(_response);
        });
    }

    protected processDeleteSetupModule(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <boolean>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(<any>null);
    }
}

export class SetupPopQuizService {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param name (optional) 
     * @return Success
     */
    getCompetency(name: string | null | undefined): Promise<CompetencySetupModel[]> {
        let url_ = this.baseUrl + "/api/v1/setup-pop-quiz/get-competency?";
        if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetCompetency(_response);
        });
    }

    protected processGetCompetency(response: Response): Promise<CompetencySetupModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <CompetencySetupModel[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CompetencySetupModel[]>(<any>null);
    }

    /**
     * @param name (optional) 
     * @return Success
     */
    getModule(name: string | null | undefined): Promise<ModuleSetupModel[]> {
        let url_ = this.baseUrl + "/api/v1/setup-pop-quiz/get-module?";
        if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetModule(_response);
        });
    }

    protected processGetModule(response: Response): Promise<ModuleSetupModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ModuleSetupModel[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ModuleSetupModel[]>(<any>null);
    }

    /**
     * @param competencyId (optional) 
     * @param moduleId (optional) 
     * @param filterName (optional) 
     * @return Success
     */
    getTaskCode(competencyId: number | null | undefined, moduleId: number | null | undefined, filterName: string | null | undefined): Promise<TaskCodeSetupModel[]> {
        let url_ = this.baseUrl + "/api/v1/setup-pop-quiz/get-task-code?";
        if (competencyId !== undefined)
            url_ += "CompetencyId=" + encodeURIComponent("" + competencyId) + "&"; 
        if (moduleId !== undefined)
            url_ += "ModuleId=" + encodeURIComponent("" + moduleId) + "&"; 
        if (filterName !== undefined)
            url_ += "FilterName=" + encodeURIComponent("" + filterName) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetTaskCode(_response);
        });
    }

    protected processGetTaskCode(response: Response): Promise<TaskCodeSetupModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <TaskCodeSetupModel[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TaskCodeSetupModel[]>(<any>null);
    }

    /**
     * @param model (optional) 
     * @return Success
     */
    insertPopQuiz(model: SetupPopUpQuizCreateModel | null | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/v1/setup-pop-quiz/insert-pop-quiz";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processInsertPopQuiz(_response);
        });
    }

    protected processInsertPopQuiz(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <boolean>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(<any>null);
    }

    /**
     * @param popQuizId (optional) 
     * @return Success
     */
    getPopQuizDetail(popQuizId: number | null | undefined): Promise<SetupPopQuizDetailModel> {
        let url_ = this.baseUrl + "/api/v1/setup-pop-quiz/get-pop-quiz-detail?";
        if (popQuizId !== undefined)
            url_ += "popQuizId=" + encodeURIComponent("" + popQuizId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetPopQuizDetail(_response);
        });
    }

    protected processGetPopQuizDetail(response: Response): Promise<SetupPopQuizDetailModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <SetupPopQuizDetailModel>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SetupPopQuizDetailModel>(<any>null);
    }

    /**
     * @param model (optional) 
     * @return Success
     */
    editPopQuiz(model: SetupPopQuizUpdateModel | null | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/v1/setup-pop-quiz/edit-pop-quiz";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processEditPopQuiz(_response);
        });
    }

    protected processEditPopQuiz(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <boolean>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(<any>null);
    }

    /**
     * @return Success
     */
    removePopQuiz(id: number): Promise<boolean> {
        let url_ = this.baseUrl + "/api/v1/setup-pop-quiz/remove-pop-quiz/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRemovePopQuiz(_response);
        });
    }

    protected processRemovePopQuiz(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <boolean>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(<any>null);
    }
}

export class SetupTimePointService {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param time (optional) 
     * @param points (optional) 
     * @param typeofPoints (optional) 
     * @param score (optional) 
     * @param sortBy (optional) 
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    getAllSetupTimePointPaginateAsync(startDate: Date | null | undefined, endDate: Date | null | undefined, time: number | null | undefined, points: number | null | undefined, typeofPoints: string | null | undefined, score: number | null | undefined, sortBy: string | null | undefined, pageIndex: number | null | undefined, pageSize: number | null | undefined): Promise<SetupTimePointPaginate> {
        let url_ = this.baseUrl + "/api/v1/setup-time-point/get-all-setup-time-point-paginate-async?";
        if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        if (time !== undefined)
            url_ += "Time=" + encodeURIComponent("" + time) + "&"; 
        if (points !== undefined)
            url_ += "Points=" + encodeURIComponent("" + points) + "&"; 
        if (typeofPoints !== undefined)
            url_ += "TypeofPoints=" + encodeURIComponent("" + typeofPoints) + "&"; 
        if (score !== undefined)
            url_ += "Score=" + encodeURIComponent("" + score) + "&"; 
        if (sortBy !== undefined)
            url_ += "SortBy=" + encodeURIComponent("" + sortBy) + "&"; 
        if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&"; 
        if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllSetupTimePointPaginateAsync(_response);
        });
    }

    protected processGetAllSetupTimePointPaginateAsync(response: Response): Promise<SetupTimePointPaginate> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <SetupTimePointPaginate>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SetupTimePointPaginate>(<any>null);
    }

    /**
     * @param timePointId (optional) 
     * @return Success
     */
    getSetupTimePointGetIdAsync(timePointId: number | null | undefined): Promise<SetupTimePoint> {
        let url_ = this.baseUrl + "/api/v1/setup-time-point/get-setup-time-point-get-id-async?";
        if (timePointId !== undefined)
            url_ += "timePointId=" + encodeURIComponent("" + timePointId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetSetupTimePointGetIdAsync(_response);
        });
    }

    protected processGetSetupTimePointGetIdAsync(response: Response): Promise<SetupTimePoint> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <SetupTimePoint>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SetupTimePoint>(<any>null);
    }

    /**
     * @param score (optional) 
     * @return Success
     */
    getSetupTimePointByScoreAsync(score: number | null | undefined): Promise<TimePointTaskModel> {
        let url_ = this.baseUrl + "/api/v1/setup-time-point/get-setup-time-point-by-score-async?";
        if (score !== undefined)
            url_ += "score=" + encodeURIComponent("" + score) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetSetupTimePointByScoreAsync(_response);
        });
    }

    protected processGetSetupTimePointByScoreAsync(response: Response): Promise<TimePointTaskModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <TimePointTaskModel>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TimePointTaskModel>(<any>null);
    }

    /**
     * @param insert (optional) 
     * @return Success
     */
    insertTimePointAsync(insert: SetupTimePointInsertModel | null | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/v1/setup-time-point/insert-time-point-async";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(insert);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processInsertTimePointAsync(_response);
        });
    }

    protected processInsertTimePointAsync(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <boolean>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param update (optional) 
     * @return Success
     */
    updateTimePointAsync(id: number | null | undefined, update: SetupTimePointInsertModel | null | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/v1/setup-time-point/update-time-point-async?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(update);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateTimePointAsync(_response);
        });
    }

    protected processUpdateTimePointAsync(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <boolean>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteTimePointAsync(id: number | null | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/v1/setup-time-point/delete-time-point-async?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteTimePointAsync(_response);
        });
    }

    protected processDeleteTimePointAsync(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <boolean>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(<any>null);
    }
}

export class SetupTop5CourseService {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param courseName (optional) 
     * @return Success
     */
    getAllSetupTop5Course(courseName: string | null | undefined): Promise<SetupTop5CourseViewModel> {
        let url_ = this.baseUrl + "/api/v1/setup-top-5-course/get-all-setup-top-5-course?";
        if (courseName !== undefined)
            url_ += "CourseName=" + encodeURIComponent("" + courseName) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllSetupTop5Course(_response);
        });
    }

    protected processGetAllSetupTop5Course(response: Response): Promise<SetupTop5CourseViewModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <SetupTop5CourseViewModel>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SetupTop5CourseViewModel>(<any>null);
    }

    /**
     * @return Success
     */
    getCourseListDropdown(): Promise<SetupTop5CourseDropdownList> {
        let url_ = this.baseUrl + "/api/v1/setup-top-5-course/get-course-list-dropdown";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetCourseListDropdown(_response);
        });
    }

    protected processGetCourseListDropdown(response: Response): Promise<SetupTop5CourseDropdownList> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <SetupTop5CourseDropdownList>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SetupTop5CourseDropdownList>(<any>null);
    }

    /**
     * @param model (optional) 
     * @return Success
     */
    insertIntoTop5Course(model: SetupTop5CourseDropdownData | null | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/v1/setup-top-5-course/insert-into-top-5-course";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processInsertIntoTop5Course(_response);
        });
    }

    protected processInsertIntoTop5Course(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <boolean>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(<any>null);
    }

    /**
     * @param model (optional) 
     * @return Success
     */
    rearrangeTop5Course(model: SetupTop5CourseViewModel | null | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/v1/setup-top-5-course/rearrange-top-5-course";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRearrangeTop5Course(_response);
        });
    }

    protected processRearrangeTop5Course(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <boolean>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(<any>null);
    }
}

export class SetupTslService {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllTrainingServiceLevelData(): Promise<SetupTSLViewModel> {
        let url_ = this.baseUrl + "/api/v1/setup-tsl/get-all-training-service-level-data";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllTrainingServiceLevelData(_response);
        });
    }

    protected processGetAllTrainingServiceLevelData(response: Response): Promise<SetupTSLViewModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <SetupTSLViewModel>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SetupTSLViewModel>(<any>null);
    }

    /**
     * @param model (optional) 
     * @return Success
     */
    updateTrainingServiceLevel(model: SetupTSLViewModel | null | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/v1/setup-tsl/update-training-service-level";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateTrainingServiceLevel(_response);
        });
    }

    protected processUpdateTrainingServiceLevel(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <boolean>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(<any>null);
    }
}

export class StagingService {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    employeePositionMapping(): Promise<void> {
        let url_ = this.baseUrl + "/api/v1/staging/employee-position-mapping";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processEmployeePositionMapping(_response);
        });
    }

    protected processEmployeePositionMapping(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @return Success
     */
    position(): Promise<void> {
        let url_ = this.baseUrl + "/api/v1/staging/position";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPosition(_response);
        });
    }

    protected processPosition(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @return Success
     */
    dealerEmployee(): Promise<void> {
        let url_ = this.baseUrl + "/api/v1/staging/dealer-employee";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDealerEmployee(_response);
        });
    }

    protected processDealerEmployee(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @return Success
     */
    user(): Promise<void> {
        let url_ = this.baseUrl + "/api/v1/staging/user";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUser(_response);
        });
    }

    protected processUser(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @return Success
     */
    outlet(): Promise<void> {
        let url_ = this.baseUrl + "/api/v1/staging/outlet";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processOutlet(_response);
        });
    }

    protected processOutlet(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @return Success
     */
    tamEmployeeStructure(): Promise<void> {
        let url_ = this.baseUrl + "/api/v1/staging/tam-employee-structure";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processTamEmployeeStructure(_response);
        });
    }

    protected processTamEmployeeStructure(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @return Success
     */
    all(): Promise<void> {
        let url_ = this.baseUrl + "/api/v1/staging/all";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAll(_response);
        });
    }

    protected processAll(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }
}

export class SurveyReportService {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param surveyTitle (optional) 
     * @param respondent (optional) 
     * @param respondentRate (optional) 
     * @param status (optional) 
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param sortBy (optional) 
     * @param pageNumber (optional) 
     * @return Success
     */
    getAllSurveyReport(surveyTitle: string | null | undefined, respondent: number | null | undefined, respondentRate: number | null | undefined, status: string | null | undefined, startDate: Date | null | undefined, endDate: Date | null | undefined, sortBy: string | null | undefined, pageNumber: number | null | undefined): Promise<SurveyReportViewModel> {
        let url_ = this.baseUrl + "/api/v1/survey-report/get-all-survey-report?";
        if (surveyTitle !== undefined)
            url_ += "SurveyTitle=" + encodeURIComponent("" + surveyTitle) + "&"; 
        if (respondent !== undefined)
            url_ += "Respondent=" + encodeURIComponent("" + respondent) + "&"; 
        if (respondentRate !== undefined)
            url_ += "RespondentRate=" + encodeURIComponent("" + respondentRate) + "&"; 
        if (status !== undefined)
            url_ += "Status=" + encodeURIComponent("" + status) + "&"; 
        if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        if (sortBy !== undefined)
            url_ += "SortBy=" + encodeURIComponent("" + sortBy) + "&"; 
        if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllSurveyReport(_response);
        });
    }

    protected processGetAllSurveyReport(response: Response): Promise<SurveyReportViewModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <SurveyReportViewModel>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SurveyReportViewModel>(<any>null);
    }

    /**
     * @return Success
     */
    generateExcel(surveyId: number): Promise<void> {
        let url_ = this.baseUrl + "/api/v1/survey-report/generate-excel/{surveyId}";
        if (surveyId === undefined || surveyId === null)
            throw new Error("The parameter 'surveyId' must be defined.");
        url_ = url_.replace("{surveyId}", encodeURIComponent("" + surveyId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGenerateExcel(_response);
        });
    }

    protected processGenerateExcel(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }
}

export class SurveysService {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param title (optional) 
     * @param position (optional) 
     * @param outlet (optional) 
     * @param statusId (optional) 
     * @param sortBy (optional) 
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    getAllSurveyPaginateAsync(startDate: Date | null | undefined, endDate: Date | null | undefined, title: string | null | undefined, position: string | null | undefined, outlet: string | null | undefined, statusId: number | null | undefined, sortBy: string | null | undefined, pageIndex: number | null | undefined, pageSize: number | null | undefined): Promise<SurveysPaginate> {
        let url_ = this.baseUrl + "/api/v1/surveys/get-all-survey-paginate-async?";
        if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        if (title !== undefined)
            url_ += "Title=" + encodeURIComponent("" + title) + "&"; 
        if (position !== undefined)
            url_ += "Position=" + encodeURIComponent("" + position) + "&"; 
        if (outlet !== undefined)
            url_ += "Outlet=" + encodeURIComponent("" + outlet) + "&"; 
        if (statusId !== undefined)
            url_ += "StatusId=" + encodeURIComponent("" + statusId) + "&"; 
        if (sortBy !== undefined)
            url_ += "SortBy=" + encodeURIComponent("" + sortBy) + "&"; 
        if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&"; 
        if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllSurveyPaginateAsync(_response);
        });
    }

    protected processGetAllSurveyPaginateAsync(response: Response): Promise<SurveysPaginate> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <SurveysPaginate>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SurveysPaginate>(<any>null);
    }

    /**
     * @return Success
     */
    getAllApprovalStatus(): Promise<ApprovalStatusModel[]> {
        let url_ = this.baseUrl + "/api/v1/surveys/get-all-approval-status";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllApprovalStatus(_response);
        });
    }

    protected processGetAllApprovalStatus(response: Response): Promise<ApprovalStatusModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ApprovalStatusModel[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApprovalStatusModel[]>(<any>null);
    }

    /**
     * @return Success
     */
    getAllSurveyQuestionType(): Promise<SurveyQuestionType[]> {
        let url_ = this.baseUrl + "/api/v1/surveys/get-all-survey-question-type";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllSurveyQuestionType(_response);
        });
    }

    protected processGetAllSurveyQuestionType(response: Response): Promise<SurveyQuestionType[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <SurveyQuestionType[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SurveyQuestionType[]>(<any>null);
    }

    /**
     * @return Success
     */
    getSurveyById(id: number): Promise<SurveyInitialize> {
        let url_ = this.baseUrl + "/api/v1/surveys/get-survey-by-id/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetSurveyById(_response);
        });
    }

    protected processGetSurveyById(response: Response): Promise<SurveyInitialize> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <SurveyInitialize>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SurveyInitialize>(<any>null);
    }

    /**
     * @param insert (optional) 
     * @return Success
     */
    submitSurvey(insert: SurveyInsert | null | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/v1/surveys/submit-survey";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(insert);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSubmitSurvey(_response);
        });
    }

    protected processSubmitSurvey(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <boolean>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(<any>null);
    }

    /**
     * @param insert (optional) 
     * @return Success
     */
    saveSurvey(insert: SurveyInsert | null | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/v1/surveys/save-survey";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(insert);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSaveSurvey(_response);
        });
    }

    protected processSaveSurvey(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <boolean>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(<any>null);
    }

    /**
     * @param insert (optional) 
     * @return Success
     */
    updateSubmitSurvey(insert: SurveyInsert | null | undefined, surveyId: number): Promise<boolean> {
        let url_ = this.baseUrl + "/api/v1/surveys/update-submit-survey/{surveyId}";
        if (surveyId === undefined || surveyId === null)
            throw new Error("The parameter 'surveyId' must be defined.");
        url_ = url_.replace("{surveyId}", encodeURIComponent("" + surveyId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(insert);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateSubmitSurvey(_response);
        });
    }

    protected processUpdateSubmitSurvey(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <boolean>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(<any>null);
    }

    /**
     * @param insert (optional) 
     * @return Success
     */
    updateSaveSurvey(insert: SurveyInsert | null | undefined, surveyId: number): Promise<boolean> {
        let url_ = this.baseUrl + "/api/v1/surveys/update-save-survey/{surveyId}";
        if (surveyId === undefined || surveyId === null)
            throw new Error("The parameter 'surveyId' must be defined.");
        url_ = url_.replace("{surveyId}", encodeURIComponent("" + surveyId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(insert);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateSaveSurvey(_response);
        });
    }

    protected processUpdateSaveSurvey(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <boolean>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(<any>null);
    }

    /**
     * @return Success
     */
    deleteSurvey(surveyId: number): Promise<boolean> {
        let url_ = this.baseUrl + "/api/v1/surveys/delete-survey/{surveyId}";
        if (surveyId === undefined || surveyId === null)
            throw new Error("The parameter 'surveyId' must be defined.");
        url_ = url_.replace("{surveyId}", encodeURIComponent("" + surveyId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteSurvey(_response);
        });
    }

    protected processDeleteSurvey(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <boolean>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(<any>null);
    }

    /**
     * @return Success
     */
    getAreaById(id: number): Promise<AreaViewModel[]> {
        let url_ = this.baseUrl + "/api/v1/surveys/get-area-by-id/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAreaById(_response);
        });
    }

    protected processGetAreaById(response: Response): Promise<AreaViewModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <AreaViewModel[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AreaViewModel[]>(<any>null);
    }

    /**
     * @return Success
     */
    getRegionById(id: number): Promise<RegionViewModel[]> {
        let url_ = this.baseUrl + "/api/v1/surveys/get-region-by-id/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetRegionById(_response);
        });
    }

    protected processGetRegionById(response: Response): Promise<RegionViewModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <RegionViewModel[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<RegionViewModel[]>(<any>null);
    }

    /**
     * @return Success
     */
    getDealerById(id: number): Promise<DealerViewModel[]> {
        let url_ = this.baseUrl + "/api/v1/surveys/get-dealer-by-id/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetDealerById(_response);
        });
    }

    protected processGetDealerById(response: Response): Promise<DealerViewModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <DealerViewModel[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DealerViewModel[]>(<any>null);
    }

    /**
     * @return Success
     */
    getProvinceById(id: number): Promise<ProvinceViewModel[]> {
        let url_ = this.baseUrl + "/api/v1/surveys/get-province-by-id/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetProvinceById(_response);
        });
    }

    protected processGetProvinceById(response: Response): Promise<ProvinceViewModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ProvinceViewModel[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ProvinceViewModel[]>(<any>null);
    }

    /**
     * @return Success
     */
    getCityById(id: number): Promise<CityViewModel[]> {
        let url_ = this.baseUrl + "/api/v1/surveys/get-city-by-id/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetCityById(_response);
        });
    }

    protected processGetCityById(response: Response): Promise<CityViewModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <CityViewModel[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CityViewModel[]>(<any>null);
    }
}

export class TaskService {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllCompetencies(): Promise<CompetencyMappingJoinModel[]> {
        let url_ = this.baseUrl + "/api/v1/task/get-all-competencies";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllCompetencies(_response);
        });
    }

    protected processGetAllCompetencies(response: Response): Promise<CompetencyMappingJoinModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <CompetencyMappingJoinModel[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CompetencyMappingJoinModel[]>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getTaskCodeByTaskId(id: number | null | undefined): Promise<CompetencyMappingJoinModel> {
        let url_ = this.baseUrl + "/api/v1/task/get-task-code-by-task-id?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetTaskCodeByTaskId(_response);
        });
    }

    protected processGetTaskCodeByTaskId(response: Response): Promise<CompetencyMappingJoinModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <CompetencyMappingJoinModel>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CompetencyMappingJoinModel>(<any>null);
    }

    /**
     * @return Success
     */
    getAllModulesForTask(): Promise<ModuleForTaskModel[]> {
        let url_ = this.baseUrl + "/api/v1/task/get-all-modules-for-task";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllModulesForTask(_response);
        });
    }

    protected processGetAllModulesForTask(response: Response): Promise<ModuleForTaskModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ModuleForTaskModel[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ModuleForTaskModel[]>(<any>null);
    }

    /**
     * @return Success
     */
    getAllTimePointsForTask(): Promise<TimePointTaskModel[]> {
        let url_ = this.baseUrl + "/api/v1/task/get-all-time-points-for-task";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllTimePointsForTask(_response);
        });
    }

    protected processGetAllTimePointsForTask(response: Response): Promise<TimePointTaskModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <TimePointTaskModel[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TimePointTaskModel[]>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getAllTimePointsForTaskUpdate(id: number[] | null | undefined): Promise<TimePointTaskModel[]> {
        let url_ = this.baseUrl + "/api/v1/task/get-all-time-points-for-task-update?";
        if (id !== undefined)
            id && id.forEach(item => { url_ += "id=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllTimePointsForTaskUpdate(_response);
        });
    }

    protected processGetAllTimePointsForTaskUpdate(response: Response): Promise<TimePointTaskModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <TimePointTaskModel[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TimePointTaskModel[]>(<any>null);
    }

    /**
     * @param competencyId (optional) 
     * @param moduleId (optional) 
     * @param evaluationTypeId (optional) 
     * @return Success
     */
    getNumber(competencyId: number | null | undefined, moduleId: number | null | undefined, evaluationTypeId: number | null | undefined): Promise<number> {
        let url_ = this.baseUrl + "/api/v1/task/get-number?";
        if (competencyId !== undefined)
            url_ += "CompetencyId=" + encodeURIComponent("" + competencyId) + "&"; 
        if (moduleId !== undefined)
            url_ += "ModuleId=" + encodeURIComponent("" + moduleId) + "&"; 
        if (evaluationTypeId !== undefined)
            url_ += "EvaluationTypeId=" + encodeURIComponent("" + evaluationTypeId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetNumber(_response);
        });
    }

    protected processGetNumber(response: Response): Promise<number> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <number>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<number>(<any>null);
    }

    /**
     * @return Success
     */
    getTaskById(id: number): Promise<TaskInsertModel> {
        let url_ = this.baseUrl + "/api/v1/task/get-task-by-id/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetTaskById(_response);
        });
    }

    protected processGetTaskById(response: Response): Promise<TaskInsertModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <TaskInsertModel>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TaskInsertModel>(<any>null);
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param taskCode (optional) 
     * @param questionTypeId (optional) 
     * @param moduleName (optional) 
     * @param createdBy (optional) 
     * @param taskId (optional) 
     * @param sortBy (optional) 
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    getViewData(startDate: Date | null | undefined, endDate: Date | null | undefined, taskCode: string | null | undefined, questionTypeId: number | null | undefined, moduleName: string | null | undefined, createdBy: string | null | undefined, taskId: number | null | undefined, sortBy: string | null | undefined, pageIndex: number | null | undefined, pageSize: number | null | undefined): Promise<TaskPaginationModel> {
        let url_ = this.baseUrl + "/api/v1/task/get-view-data?";
        if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        if (taskCode !== undefined)
            url_ += "TaskCode=" + encodeURIComponent("" + taskCode) + "&"; 
        if (questionTypeId !== undefined)
            url_ += "QuestionTypeId=" + encodeURIComponent("" + questionTypeId) + "&"; 
        if (moduleName !== undefined)
            url_ += "ModuleName=" + encodeURIComponent("" + moduleName) + "&"; 
        if (createdBy !== undefined)
            url_ += "CreatedBy=" + encodeURIComponent("" + createdBy) + "&"; 
        if (taskId !== undefined)
            url_ += "TaskId=" + encodeURIComponent("" + taskId) + "&"; 
        if (sortBy !== undefined)
            url_ += "SortBy=" + encodeURIComponent("" + sortBy) + "&"; 
        if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&"; 
        if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetViewData(_response);
        });
    }

    protected processGetViewData(response: Response): Promise<TaskPaginationModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <TaskPaginationModel>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TaskPaginationModel>(<any>null);
    }

    /**
     * @param taskId (optional) 
     * @return Success
     */
    deleteTask(taskId: number | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/v1/task/delete-task?";
        if (taskId !== undefined)
            url_ += "taskId=" + encodeURIComponent("" + taskId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteTask(_response);
        });
    }

    protected processDeleteTask(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }
}

export class ChecklistService {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getTaskCode(): Promise<CompetencyMappingJoinModel[]> {
        let url_ = this.baseUrl + "/api/v1/checklist/get-task-code";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetTaskCode(_response);
        });
    }

    protected processGetTaskCode(response: Response): Promise<CompetencyMappingJoinModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <CompetencyMappingJoinModel[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CompetencyMappingJoinModel[]>(<any>null);
    }

    /**
     * @return Success
     */
    getModule(): Promise<ModuleForTaskModel[]> {
        let url_ = this.baseUrl + "/api/v1/checklist/get-module";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetModule(_response);
        });
    }

    protected processGetModule(response: Response): Promise<ModuleForTaskModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ModuleForTaskModel[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ModuleForTaskModel[]>(<any>null);
    }

    /**
     * @return Success
     */
    getTimePoint(): Promise<TimePointTaskModel[]> {
        let url_ = this.baseUrl + "/api/v1/checklist/get-time-point";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetTimePoint(_response);
        });
    }

    protected processGetTimePoint(response: Response): Promise<TimePointTaskModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <TimePointTaskModel[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TimePointTaskModel[]>(<any>null);
    }

    /**
     * @param competencyId (optional) 
     * @param moduleId (optional) 
     * @param evaluationTypeId (optional) 
     * @return Success
     */
    getNumber(competencyId: number | null | undefined, moduleId: number | null | undefined, evaluationTypeId: number | null | undefined): Promise<number> {
        let url_ = this.baseUrl + "/api/v1/checklist/get-number?";
        if (competencyId !== undefined)
            url_ += "CompetencyId=" + encodeURIComponent("" + competencyId) + "&"; 
        if (moduleId !== undefined)
            url_ += "ModuleId=" + encodeURIComponent("" + moduleId) + "&"; 
        if (evaluationTypeId !== undefined)
            url_ += "EvaluationTypeId=" + encodeURIComponent("" + evaluationTypeId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetNumber(_response);
        });
    }

    protected processGetNumber(response: Response): Promise<number> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <number>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<number>(<any>null);
    }

    /**
     * @param model (optional) 
     * @return Success
     */
    insertChecklistTask(model: ChecklistCreateModel | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/v1/checklist/insert-checklist-task";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processInsertChecklistTask(_response);
        });
    }

    protected processInsertChecklistTask(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param taskId (optional) 
     * @return Success
     */
    getTaskChecklist(taskId: number | null | undefined): Promise<ChecklistViewDetailModel> {
        let url_ = this.baseUrl + "/api/v1/checklist/get-task-checklist?";
        if (taskId !== undefined)
            url_ += "taskId=" + encodeURIComponent("" + taskId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetTaskChecklist(_response);
        });
    }

    protected processGetTaskChecklist(response: Response): Promise<ChecklistViewDetailModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ChecklistViewDetailModel>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ChecklistViewDetailModel>(<any>null);
    }

    /**
     * @param model (optional) 
     * @param taskId (optional) 
     * @return Success
     */
    updateChecklistTask(model: ChecklistUpdateModel | null | undefined, taskId: number | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/v1/checklist/update-checklist-task?";
        if (taskId !== undefined)
            url_ += "taskId=" + encodeURIComponent("" + taskId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateChecklistTask(_response);
        });
    }

    protected processUpdateChecklistTask(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }
}

export class EssayService {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getTaskEssayTypeById(id: number): Promise<TaskEssayTypeFormModel> {
        let url_ = this.baseUrl + "/api/v1/essay/get-task-essay-type-by-id/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetTaskEssayTypeById(_response);
        });
    }

    protected processGetTaskEssayTypeById(response: Response): Promise<TaskEssayTypeFormModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <TaskEssayTypeFormModel>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TaskEssayTypeFormModel>(<any>null);
    }

    /**
     * @param model (optional) 
     * @return Success
     */
    create(model: TaskEssayTypeFormModel | null | undefined): Promise<number> {
        let url_ = this.baseUrl + "/api/v1/essay/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: Response): Promise<number> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <number>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<number>(<any>null);
    }

    /**
     * @param model (optional) 
     * @return Success
     */
    update(model: TaskEssayTypeFormModel | null | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/v1/essay/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <boolean>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(<any>null);
    }
}

export class FileUploadService {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param model (optional) 
     * @return Success
     */
    insertFileUpload(model: TaskFileUploadFormModel | null | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/v1/file-upload/insert-file-upload";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processInsertFileUpload(_response);
        });
    }

    protected processInsertFileUpload(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <boolean>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(<any>null);
    }

    /**
     * @return Success
     */
    getFileUploadDetails(id: number): Promise<TaskFileUploadViewDetail> {
        let url_ = this.baseUrl + "/api/v1/file-upload/get-file-upload-details/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetFileUploadDetails(_response);
        });
    }

    protected processGetFileUploadDetails(response: Response): Promise<TaskFileUploadViewDetail> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <TaskFileUploadViewDetail>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TaskFileUploadViewDetail>(<any>null);
    }

    /**
     * @param model (optional) 
     * @return Success
     */
    updateFileUpload(model: TaskFileUploadFormModel | null | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/v1/file-upload/update-file-upload";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateFileUpload(_response);
        });
    }

    protected processUpdateFileUpload(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <boolean>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(<any>null);
    }
}

export class HotSpotService {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getTaskHotspotTypeById(id: number): Promise<TaskTebakGambarTypesModel> {
        let url_ = this.baseUrl + "/api/v1/hot-spot/get-task-hotspot-type-by-id/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetTaskHotspotTypeById(_response);
        });
    }

    protected processGetTaskHotspotTypeById(response: Response): Promise<TaskTebakGambarTypesModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <TaskTebakGambarTypesModel>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TaskTebakGambarTypesModel>(<any>null);
    }

    /**
     * @return Success
     */
    getTaskHotspotChoiceById(id: number): Promise<TaskHotSpotAnswerModel[]> {
        let url_ = this.baseUrl + "/api/v1/hot-spot/get-task-hotspot-choice-by-id/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetTaskHotspotChoiceById(_response);
        });
    }

    protected processGetTaskHotspotChoiceById(response: Response): Promise<TaskHotSpotAnswerModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <TaskHotSpotAnswerModel[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TaskHotSpotAnswerModel[]>(<any>null);
    }

    /**
     * @param insert (optional) 
     * @return Success
     */
    insertTaskHotspot(insert: TaskHotSpotModel | null | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/v1/hot-spot/insert-task-hotspot";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(insert);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processInsertTaskHotspot(_response);
        });
    }

    protected processInsertTaskHotspot(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <boolean>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(<any>null);
    }

    /**
     * @param insert (optional) 
     * @return Success
     */
    updateTaskHotspot(id: number, insert: TaskHotSpotModel | null | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/v1/hot-spot/update-task-hotspot/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(insert);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateTaskHotspot(_response);
        });
    }

    protected processUpdateTaskHotspot(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <boolean>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(<any>null);
    }
}

export class MatchingService {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getTaskMatchingTypeById(id: number): Promise<TaskMatchingTypeFormModel> {
        let url_ = this.baseUrl + "/api/v1/matching/get-task-matching-type-by-id/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetTaskMatchingTypeById(_response);
        });
    }

    protected processGetTaskMatchingTypeById(response: Response): Promise<TaskMatchingTypeFormModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <TaskMatchingTypeFormModel>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TaskMatchingTypeFormModel>(<any>null);
    }

    /**
     * @param model (optional) 
     * @return Success
     */
    create(model: TaskMatchingTypeFormModel | null | undefined): Promise<number> {
        let url_ = this.baseUrl + "/api/v1/matching/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: Response): Promise<number> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <number>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<number>(<any>null);
    }

    /**
     * @param model (optional) 
     * @return Success
     */
    update(model: TaskMatchingTypeFormModel | null | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/v1/matching/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <boolean>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(<any>null);
    }
}

export class MatrixService {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getTaskMatrixTypeById(id: number): Promise<TaskMatrixTypeFormModel> {
        let url_ = this.baseUrl + "/api/v1/matrix/get-task-matrix-type-by-id/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetTaskMatrixTypeById(_response);
        });
    }

    protected processGetTaskMatrixTypeById(response: Response): Promise<TaskMatrixTypeFormModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <TaskMatrixTypeFormModel>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TaskMatrixTypeFormModel>(<any>null);
    }

    /**
     * @param model (optional) 
     * @return Success
     */
    create(model: TaskMatrixTypeFormModel | null | undefined): Promise<number> {
        let url_ = this.baseUrl + "/api/v1/matrix/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: Response): Promise<number> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <number>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<number>(<any>null);
    }

    /**
     * @param model (optional) 
     * @return Success
     */
    update(model: TaskMatrixTypeFormModel | null | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/v1/matrix/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <boolean>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(<any>null);
    }
}

export class MultipleChoiceService {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getTaskMultipleChoiceTypeById(id: number): Promise<TaskMultipleChoiceTypeModel> {
        let url_ = this.baseUrl + "/api/v1/multiple-choice/get-task-multiple-choice-type-by-id/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetTaskMultipleChoiceTypeById(_response);
        });
    }

    protected processGetTaskMultipleChoiceTypeById(response: Response): Promise<TaskMultipleChoiceTypeModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <TaskMultipleChoiceTypeModel>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TaskMultipleChoiceTypeModel>(<any>null);
    }

    /**
     * @return Success
     */
    getTaskMultipleChoiceChoiceById(id: number): Promise<TaskMultipleChoiceTypeModel[]> {
        let url_ = this.baseUrl + "/api/v1/multiple-choice/get-task-multiple-choice-choice-by-id/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetTaskMultipleChoiceChoiceById(_response);
        });
    }

    protected processGetTaskMultipleChoiceChoiceById(response: Response): Promise<TaskMultipleChoiceTypeModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <TaskMultipleChoiceTypeModel[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TaskMultipleChoiceTypeModel[]>(<any>null);
    }

    /**
     * @param insert (optional) 
     * @return Success
     */
    insertTaskMultipleChoice(insert: TaskMultipleChoiceModel | null | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/v1/multiple-choice/insert-task-multiple-choice";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(insert);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processInsertTaskMultipleChoice(_response);
        });
    }

    protected processInsertTaskMultipleChoice(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <boolean>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(<any>null);
    }

    /**
     * @param insert (optional) 
     * @return Success
     */
    updateTaskMultipleChoice(id: number, insert: TaskMultipleChoiceModel | null | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/v1/multiple-choice/update-task-multiple-choice/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(insert);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateTaskMultipleChoice(_response);
        });
    }

    protected processUpdateTaskMultipleChoice(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <boolean>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(<any>null);
    }
}

export class RatingService {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param insert (optional) 
     * @return Success
     */
    insertTaskRating(insert: TaskRatingModel | null | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/v1/rating/insert-task-rating";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(insert);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processInsertTaskRating(_response);
        });
    }

    protected processInsertTaskRating(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <boolean>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(<any>null);
    }

    /**
     * @param insert (optional) 
     * @return Success
     */
    updateTaskRating(id: number, insert: TaskRatingModel | null | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/v1/rating/update-task-rating/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(insert);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateTaskRating(_response);
        });
    }

    protected processUpdateTaskRating(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <boolean>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(<any>null);
    }

    /**
     * @return Success
     */
    getTaskRatingTypeById(id: number): Promise<TaskRatingTypeModel> {
        let url_ = this.baseUrl + "/api/v1/rating/get-task-rating-type-by-id/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetTaskRatingTypeById(_response);
        });
    }

    protected processGetTaskRatingTypeById(response: Response): Promise<TaskRatingTypeModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <TaskRatingTypeModel>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TaskRatingTypeModel>(<any>null);
    }

    /**
     * @return Success
     */
    getTaskRatingChoiceById(id: number): Promise<TaskRatingTypeModel[]> {
        let url_ = this.baseUrl + "/api/v1/rating/get-task-rating-choice-by-id/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetTaskRatingChoiceById(_response);
        });
    }

    protected processGetTaskRatingChoiceById(response: Response): Promise<TaskRatingTypeModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <TaskRatingTypeModel[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TaskRatingTypeModel[]>(<any>null);
    }

    /**
     * @return Success
     */
    deleteTaskRatingAsync(id: number): Promise<boolean> {
        let url_ = this.baseUrl + "/api/v1/rating/delete-task-rating-async/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteTaskRatingAsync(_response);
        });
    }

    protected processDeleteTaskRatingAsync(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <boolean>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(<any>null);
    }
}

export class SequenceService {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getTaskCode(): Promise<CompetencyMappingJoinModel[]> {
        let url_ = this.baseUrl + "/api/v1/sequence/get-task-code";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetTaskCode(_response);
        });
    }

    protected processGetTaskCode(response: Response): Promise<CompetencyMappingJoinModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <CompetencyMappingJoinModel[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CompetencyMappingJoinModel[]>(<any>null);
    }

    /**
     * @return Success
     */
    getModuleOption(): Promise<ModuleForTaskModel[]> {
        let url_ = this.baseUrl + "/api/v1/sequence/get-module-option";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetModuleOption(_response);
        });
    }

    protected processGetModuleOption(response: Response): Promise<ModuleForTaskModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ModuleForTaskModel[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ModuleForTaskModel[]>(<any>null);
    }

    /**
     * @param competencyId (optional) 
     * @param moduleId (optional) 
     * @param evaluationTypeId (optional) 
     * @return Success
     */
    getTaskNumber(competencyId: number | null | undefined, moduleId: number | null | undefined, evaluationTypeId: number | null | undefined): Promise<number> {
        let url_ = this.baseUrl + "/api/v1/sequence/get-task-number?";
        if (competencyId !== undefined)
            url_ += "CompetencyId=" + encodeURIComponent("" + competencyId) + "&"; 
        if (moduleId !== undefined)
            url_ += "ModuleId=" + encodeURIComponent("" + moduleId) + "&"; 
        if (evaluationTypeId !== undefined)
            url_ += "EvaluationTypeId=" + encodeURIComponent("" + evaluationTypeId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetTaskNumber(_response);
        });
    }

    protected processGetTaskNumber(response: Response): Promise<number> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <number>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<number>(<any>null);
    }

    /**
     * @return Success
     */
    getTimePoint(): Promise<TimePointTaskModel[]> {
        let url_ = this.baseUrl + "/api/v1/sequence/get-time-point";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetTimePoint(_response);
        });
    }

    protected processGetTimePoint(response: Response): Promise<TimePointTaskModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <TimePointTaskModel[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TimePointTaskModel[]>(<any>null);
    }

    /**
     * @param model (optional) 
     * @return Success
     */
    insertSequenceTask(model: SequenceCreateModel | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/v1/sequence/insert-sequence-task";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processInsertSequenceTask(_response);
        });
    }

    protected processInsertSequenceTask(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param taskId (optional) 
     * @return Success
     */
    getTaskSequence(taskId: number | null | undefined): Promise<SequenceViewDetailModel> {
        let url_ = this.baseUrl + "/api/v1/sequence/get-task-sequence?";
        if (taskId !== undefined)
            url_ += "taskId=" + encodeURIComponent("" + taskId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetTaskSequence(_response);
        });
    }

    protected processGetTaskSequence(response: Response): Promise<SequenceViewDetailModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <SequenceViewDetailModel>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SequenceViewDetailModel>(<any>null);
    }

    /**
     * @param model (optional) 
     * @param taskId (optional) 
     * @return Success
     */
    updateTaskSequence(model: SequenceUpdateModel | null | undefined, taskId: number | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/v1/sequence/update-task-sequence?";
        if (taskId !== undefined)
            url_ += "taskId=" + encodeURIComponent("" + taskId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateTaskSequence(_response);
        });
    }

    protected processUpdateTaskSequence(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }
}

export class ShortAnswerService {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param model (optional) 
     * @return Success
     */
    insertShortAnswer(model: TaskShortAnswerForm | null | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/v1/short-answer/insert-short-answer";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processInsertShortAnswer(_response);
        });
    }

    protected processInsertShortAnswer(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <boolean>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(<any>null);
    }

    /**
     * @return Success
     */
    getShortAnswerDetails(id: number): Promise<TaskShortAnswerViewDetail> {
        let url_ = this.baseUrl + "/api/v1/short-answer/get-short-answer-details/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetShortAnswerDetails(_response);
        });
    }

    protected processGetShortAnswerDetails(response: Response): Promise<TaskShortAnswerViewDetail> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <TaskShortAnswerViewDetail>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TaskShortAnswerViewDetail>(<any>null);
    }

    /**
     * @param model (optional) 
     * @return Success
     */
    updateShortAnswer(model: TaskShortAnswerForm | null | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/v1/short-answer/update-short-answer";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateShortAnswer(_response);
        });
    }

    protected processUpdateShortAnswer(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <boolean>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(<any>null);
    }
}

export class TebakGambarService {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getTaskTebakGambarTypeById(id: number): Promise<TaskTebakGambarTypesModel> {
        let url_ = this.baseUrl + "/api/v1/tebak-gambar/get-task-tebak-gambar-type-by-id/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetTaskTebakGambarTypeById(_response);
        });
    }

    protected processGetTaskTebakGambarTypeById(response: Response): Promise<TaskTebakGambarTypesModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <TaskTebakGambarTypesModel>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TaskTebakGambarTypesModel>(<any>null);
    }

    /**
     * @return Success
     */
    getTaskTebakGambarPictureById(id: number): Promise<TaskTebakGambarPicturesModel[]> {
        let url_ = this.baseUrl + "/api/v1/tebak-gambar/get-task-tebak-gambar-picture-by-id/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetTaskTebakGambarPictureById(_response);
        });
    }

    protected processGetTaskTebakGambarPictureById(response: Response): Promise<TaskTebakGambarPicturesModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <TaskTebakGambarPicturesModel[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TaskTebakGambarPicturesModel[]>(<any>null);
    }

    /**
     * @param t (optional) 
     * @return Success
     */
    insertTaskTebakGambar(t: TaskTebakGambarModel | null | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/v1/tebak-gambar/insert-task-tebak-gambar";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(t);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processInsertTaskTebakGambar(_response);
        });
    }

    protected processInsertTaskTebakGambar(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <boolean>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(<any>null);
    }

    /**
     * @param t (optional) 
     * @return Success
     */
    updateTaskTebakGambar(id: number, t: TaskTebakGambarModel | null | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/v1/tebak-gambar/update-task-tebak-gambar/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(t);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateTaskTebakGambar(_response);
        });
    }

    protected processUpdateTaskTebakGambar(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <boolean>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(<any>null);
    }
}

export class TrueFalseService {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getTaskTrue(id: number): Promise<TrueFalseTypeViewDetails> {
        let url_ = this.baseUrl + "/api/v1/true-false/get-task-true/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetTaskTrue(_response);
        });
    }

    protected processGetTaskTrue(response: Response): Promise<TrueFalseTypeViewDetails> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <TrueFalseTypeViewDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TrueFalseTypeViewDetails>(<any>null);
    }

    /**
     * @param model (optional) 
     * @return Success
     */
    insertTrueFalse(model: TaskTrueFalseFormModel | null | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/v1/true-false/insert-true-false";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processInsertTrueFalse(_response);
        });
    }

    protected processInsertTrueFalse(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <boolean>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(<any>null);
    }

    /**
     * @param model (optional) 
     * @return Success
     */
    updateTrueFalse(model: TaskTrueFalseFormModel | null | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/v1/true-false/update-true-false";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateTrueFalse(_response);
        });
    }

    protected processUpdateTrueFalse(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <boolean>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(<any>null);
    }
}

export class TopicService {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param dateStart (optional) 
     * @param dateEnd (optional) 
     * @param topicName (optional) 
     * @param ebadge (optional) 
     * @param minPoint (optional) 
     * @param sortBy (optional) 
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    getAllTopic(dateStart: Date | null | undefined, dateEnd: Date | null | undefined, topicName: string | null | undefined, ebadge: number | null | undefined, minPoint: number | null | undefined, sortBy: string | null | undefined, pageIndex: number | null | undefined, pageSize: number | null | undefined): Promise<GridTopicModel> {
        let url_ = this.baseUrl + "/api/v1/topic/get-all-topic?";
        if (dateStart !== undefined)
            url_ += "DateStart=" + encodeURIComponent(dateStart ? "" + dateStart.toJSON() : "") + "&"; 
        if (dateEnd !== undefined)
            url_ += "DateEnd=" + encodeURIComponent(dateEnd ? "" + dateEnd.toJSON() : "") + "&"; 
        if (topicName !== undefined)
            url_ += "TopicName=" + encodeURIComponent("" + topicName) + "&"; 
        if (ebadge !== undefined)
            url_ += "Ebadge=" + encodeURIComponent("" + ebadge) + "&"; 
        if (minPoint !== undefined)
            url_ += "MinPoint=" + encodeURIComponent("" + minPoint) + "&"; 
        if (sortBy !== undefined)
            url_ += "SortBy=" + encodeURIComponent("" + sortBy) + "&"; 
        if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&"; 
        if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllTopic(_response);
        });
    }

    protected processGetAllTopic(response: Response): Promise<GridTopicModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <GridTopicModel>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GridTopicModel>(<any>null);
    }

    /**
     * @param name (optional) 
     * @return Success
     */
    validateTopicName(name: string | null | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/v1/topic/validate-topic-name?";
        if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processValidateTopicName(_response);
        });
    }

    protected processValidateTopicName(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <boolean>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(<any>null);
    }

    /**
     * @param createModel (optional) 
     * @return Success
     */
    createNewTopic(createModel: TopicCreateModel | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/v1/topic/create-new-topic";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(createModel);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateNewTopic(_response);
        });
    }

    protected processCreateNewTopic(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param topicId (optional) 
     * @return Success
     */
    getTopicById(topicId: number | null | undefined): Promise<TopicViewDetailModel> {
        let url_ = this.baseUrl + "/api/v1/topic/get-topic-by-id?";
        if (topicId !== undefined)
            url_ += "topicId=" + encodeURIComponent("" + topicId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetTopicById(_response);
        });
    }

    protected processGetTopicById(response: Response): Promise<TopicViewDetailModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <TopicViewDetailModel>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TopicViewDetailModel>(<any>null);
    }

    /**
     * @param topicName (optional) 
     * @param topicId (optional) 
     * @return Success
     */
    validateUpdateTopicName(topicName: string | null | undefined, topicId: number | null | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/v1/topic/validate-update-topic-name?";
        if (topicName !== undefined)
            url_ += "topicName=" + encodeURIComponent("" + topicName) + "&"; 
        if (topicId !== undefined)
            url_ += "topicId=" + encodeURIComponent("" + topicId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processValidateUpdateTopicName(_response);
        });
    }

    protected processValidateUpdateTopicName(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <boolean>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(<any>null);
    }

    /**
     * @param updateModel (optional) 
     * @param topicId (optional) 
     * @return Success
     */
    updateTopic(updateModel: TopicUpdateModel | null | undefined, topicId: number | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/v1/topic/update-topic?";
        if (topicId !== undefined)
            url_ += "topicId=" + encodeURIComponent("" + topicId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updateModel);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateTopic(_response);
        });
    }

    protected processUpdateTopic(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param topicId (optional) 
     * @return Success
     */
    deleteTopic(topicId: number | null | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/v1/topic/delete-topic?";
        if (topicId !== undefined)
            url_ += "topicId=" + encodeURIComponent("" + topicId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteTopic(_response);
        });
    }

    protected processDeleteTopic(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <boolean>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(<any>null);
    }

    /**
     * @return Success
     */
    getOption(): Promise<TopicCoachOptionModel[]> {
        let url_ = this.baseUrl + "/api/v1/topic/get-option";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetOption(_response);
        });
    }

    protected processGetOption(response: Response): Promise<TopicCoachOptionModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <TopicCoachOptionModel[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TopicCoachOptionModel[]>(<any>null);
    }

    /**
     * @return Success
     */
    getEbadgeOption(): Promise<TopicEbadgeOptionModel[]> {
        let url_ = this.baseUrl + "/api/v1/topic/get-ebadge-option";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetEbadgeOption(_response);
        });
    }

    protected processGetEbadgeOption(response: Response): Promise<TopicEbadgeOptionModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <TopicEbadgeOptionModel[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TopicEbadgeOptionModel[]>(<any>null);
    }
}

export class TrainingProcessService {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param courseName (optional) 
     * @param programTypeName (optional) 
     * @param batch (optional) 
     * @param confirmed (optional) 
     * @param quota (optional) 
     * @param sortBy (optional) 
     * @param pageNumber (optional) 
     * @return Success
     */
    getTrainingProcess(startDate: Date | null | undefined, endDate: Date | null | undefined, courseName: string | null | undefined, programTypeName: string | null | undefined, batch: number | null | undefined, confirmed: number | null | undefined, quota: number | null | undefined, sortBy: string | null | undefined, pageNumber: number | null | undefined): Promise<TrainingProcessViewModel> {
        let url_ = this.baseUrl + "/api/v1/training-process/get-training-process?";
        if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        if (courseName !== undefined)
            url_ += "CourseName=" + encodeURIComponent("" + courseName) + "&"; 
        if (programTypeName !== undefined)
            url_ += "ProgramTypeName=" + encodeURIComponent("" + programTypeName) + "&"; 
        if (batch !== undefined)
            url_ += "Batch=" + encodeURIComponent("" + batch) + "&"; 
        if (confirmed !== undefined)
            url_ += "Confirmed=" + encodeURIComponent("" + confirmed) + "&"; 
        if (quota !== undefined)
            url_ += "Quota=" + encodeURIComponent("" + quota) + "&"; 
        if (sortBy !== undefined)
            url_ += "SortBy=" + encodeURIComponent("" + sortBy) + "&"; 
        if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetTrainingProcess(_response);
        });
    }

    protected processGetTrainingProcess(response: Response): Promise<TrainingProcessViewModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <TrainingProcessViewModel>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TrainingProcessViewModel>(<any>null);
    }

    /**
     * @param trainingId (optional) 
     * @return Success
     */
    getTrainingProcessById(trainingId: number | null | undefined): Promise<TrainingProcessDetailViewModel> {
        let url_ = this.baseUrl + "/api/v1/training-process/get-training-process-by-id?";
        if (trainingId !== undefined)
            url_ += "trainingId=" + encodeURIComponent("" + trainingId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetTrainingProcessById(_response);
        });
    }

    protected processGetTrainingProcessById(response: Response): Promise<TrainingProcessDetailViewModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <TrainingProcessDetailViewModel>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TrainingProcessDetailViewModel>(<any>null);
    }

    /**
     * @param model (optional) 
     * @param trainingId (optional) 
     * @return Success
     */
    updateTrainingProcessById(model: TrainingProcessDetailViewModel | null | undefined, trainingId: number | null | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/v1/training-process/update-training-process-by-id?";
        if (trainingId !== undefined)
            url_ += "trainingId=" + encodeURIComponent("" + trainingId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateTrainingProcessById(_response);
        });
    }

    protected processUpdateTrainingProcessById(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <boolean>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(<any>null);
    }

    /**
     * @param model (optional) 
     * @param trainingId (optional) 
     * @return Success
     */
    saveDraftTrainingProcess(model: TrainingProcessDetailViewModel | null | undefined, trainingId: number | null | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/v1/training-process/save-draft-training-process?";
        if (trainingId !== undefined)
            url_ += "trainingId=" + encodeURIComponent("" + trainingId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSaveDraftTrainingProcess(_response);
        });
    }

    protected processSaveDraftTrainingProcess(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <boolean>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(<any>null);
    }

    /**
     * @param page (optional) 
     * @param pageSize (optional) 
     * @param name (optional) 
     * @param type (optional) 
     * @param isOrderedByDateAscending (optional) 
     * @return Success
     */
    getPaginate(page: number | null | undefined, pageSize: number | null | undefined, name: string | null | undefined, type: string | null | undefined, isOrderedByDateAscending: boolean | null | undefined): Promise<UserSideTrainingProcessViewModel[]> {
        let url_ = this.baseUrl + "/api/v1/mobile/training-process/get-paginate?";
        if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&"; 
        if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&"; 
        if (name !== undefined)
            url_ += "Name=" + encodeURIComponent("" + name) + "&"; 
        if (type !== undefined)
            url_ += "Type=" + encodeURIComponent("" + type) + "&"; 
        if (isOrderedByDateAscending !== undefined)
            url_ += "IsOrderedByDateAscending=" + encodeURIComponent("" + isOrderedByDateAscending) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetPaginate(_response);
        });
    }

    protected processGetPaginate(response: Response): Promise<UserSideTrainingProcessViewModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <UserSideTrainingProcessViewModel[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserSideTrainingProcessViewModel[]>(<any>null);
    }

    /**
     * @return Success
     */
    getAccomodation(): Promise<UserSideAcomodationListModel[]> {
        let url_ = this.baseUrl + "/api/v1/mobile/training-process/get-accomodation";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAccomodation(_response);
        });
    }

    protected processGetAccomodation(response: Response): Promise<UserSideAcomodationListModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <UserSideAcomodationListModel[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserSideAcomodationListModel[]>(<any>null);
    }

    /**
     * @return Success
     */
    getDetail(id: number): Promise<UserSideTrainingProcessDetailModel> {
        let url_ = this.baseUrl + "/api/v1/mobile/training-process/get-detail/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetDetail(_response);
        });
    }

    protected processGetDetail(response: Response): Promise<UserSideTrainingProcessDetailModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <UserSideTrainingProcessDetailModel>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserSideTrainingProcessDetailModel>(<any>null);
    }

    /**
     * @param model (optional) 
     * @return Success
     */
    confirmTraining(model: UserSideTrainingProcessConfirmModel | null | undefined): Promise<string> {
        let url_ = this.baseUrl + "/api/v1/mobile/training-process/confirm-training";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processConfirmTraining(_response);
        });
    }

    protected processConfirmTraining(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <string>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(<any>null);
    }
}

export class TrainingScoreReportService {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param dateStart (optional) 
     * @param dateEnd (optional) 
     * @param programTypeId (optional) 
     * @param participant (optional) 
     * @param status (optional) 
     * @param courseName (optional) 
     * @param batch (optional) 
     * @param participantRate (optional) 
     * @param sortBy (optional) 
     * @param pageNumber (optional) 
     * @return Success
     */
    getTrainingScoreReport(dateStart: Date | null | undefined, dateEnd: Date | null | undefined, programTypeId: number | null | undefined, participant: number | null | undefined, status: string | null | undefined, courseName: string | null | undefined, batch: number | null | undefined, participantRate: number | null | undefined, sortBy: string | null | undefined, pageNumber: number | null | undefined): Promise<ReportTrainingScoreViewModel> {
        let url_ = this.baseUrl + "/api/v1/training-score-report/get-training-score-report?";
        if (dateStart !== undefined)
            url_ += "DateStart=" + encodeURIComponent(dateStart ? "" + dateStart.toJSON() : "") + "&"; 
        if (dateEnd !== undefined)
            url_ += "DateEnd=" + encodeURIComponent(dateEnd ? "" + dateEnd.toJSON() : "") + "&"; 
        if (programTypeId !== undefined)
            url_ += "ProgramTypeId=" + encodeURIComponent("" + programTypeId) + "&"; 
        if (participant !== undefined)
            url_ += "Participant=" + encodeURIComponent("" + participant) + "&"; 
        if (status !== undefined)
            url_ += "Status=" + encodeURIComponent("" + status) + "&"; 
        if (courseName !== undefined)
            url_ += "CourseName=" + encodeURIComponent("" + courseName) + "&"; 
        if (batch !== undefined)
            url_ += "Batch=" + encodeURIComponent("" + batch) + "&"; 
        if (participantRate !== undefined)
            url_ += "ParticipantRate=" + encodeURIComponent("" + participantRate) + "&"; 
        if (sortBy !== undefined)
            url_ += "SortBy=" + encodeURIComponent("" + sortBy) + "&"; 
        if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetTrainingScoreReport(_response);
        });
    }

    protected processGetTrainingScoreReport(response: Response): Promise<ReportTrainingScoreViewModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ReportTrainingScoreViewModel>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ReportTrainingScoreViewModel>(<any>null);
    }

    /**
     * @return Success
     */
    getProgramTypes(): Promise<ProgramTypeModel[]> {
        let url_ = this.baseUrl + "/api/v1/training-score-report/get-program-types";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetProgramTypes(_response);
        });
    }

    protected processGetProgramTypes(response: Response): Promise<ProgramTypeModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ProgramTypeModel[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ProgramTypeModel[]>(<any>null);
    }

    /**
     * @return Success
     */
    downloadTrainingScoreReport(id: number): Promise<void> {
        let url_ = this.baseUrl + "/api/v1/training-score-report/download-training-score-report/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDownloadTrainingScoreReport(_response);
        });
    }

    protected processDownloadTrainingScoreReport(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }
}

export class UserPrivilegeSettingsService {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param menuId (optional) 
     * @param userRole (optional) 
     * @param pageId (optional) 
     * @param sortBy (optional) 
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    getAllUserPrivilegeSettingsPaginate(startDate: Date | null | undefined, endDate: Date | null | undefined, menuId: string | null | undefined, userRole: string | null | undefined, pageId: string | null | undefined, sortBy: string | null | undefined, pageIndex: number | null | undefined, pageSize: number | null | undefined): Promise<UserPrivilegeSettingsPaginateModel> {
        let url_ = this.baseUrl + "/api/v1/user-privilege-settings/get-all-user-privilege-settings-paginate?";
        if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        if (menuId !== undefined)
            url_ += "MenuId=" + encodeURIComponent("" + menuId) + "&"; 
        if (userRole !== undefined)
            url_ += "UserRole=" + encodeURIComponent("" + userRole) + "&"; 
        if (pageId !== undefined)
            url_ += "PageId=" + encodeURIComponent("" + pageId) + "&"; 
        if (sortBy !== undefined)
            url_ += "SortBy=" + encodeURIComponent("" + sortBy) + "&"; 
        if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&"; 
        if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllUserPrivilegeSettingsPaginate(_response);
        });
    }

    protected processGetAllUserPrivilegeSettingsPaginate(response: Response): Promise<UserPrivilegeSettingsPaginateModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <UserPrivilegeSettingsPaginateModel>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserPrivilegeSettingsPaginateModel>(<any>null);
    }

    /**
     * @return Success
     */
    getAllUserPrivilegeSettingsUserRoleNotYetSet(): Promise<UserPrivilegeSettingsUserRoleModel[]> {
        let url_ = this.baseUrl + "/api/v1/user-privilege-settings/get-all-user-privilege-settings-user-role-not-yet-set";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllUserPrivilegeSettingsUserRoleNotYetSet(_response);
        });
    }

    protected processGetAllUserPrivilegeSettingsUserRoleNotYetSet(response: Response): Promise<UserPrivilegeSettingsUserRoleModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <UserPrivilegeSettingsUserRoleModel[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserPrivilegeSettingsUserRoleModel[]>(<any>null);
    }

    /**
     * @return Success
     */
    getAllUserPrivilegeSettingsUserRoleNotYetSetExceptSelf(id: number): Promise<UserPrivilegeSettingsUserRoleModel[]> {
        let url_ = this.baseUrl + "/api/v1/user-privilege-settings/get-all-user-privilege-settings-user-role-not-yet-set-except-self/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllUserPrivilegeSettingsUserRoleNotYetSetExceptSelf(_response);
        });
    }

    protected processGetAllUserPrivilegeSettingsUserRoleNotYetSetExceptSelf(response: Response): Promise<UserPrivilegeSettingsUserRoleModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <UserPrivilegeSettingsUserRoleModel[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserPrivilegeSettingsUserRoleModel[]>(<any>null);
    }

    /**
     * @return Success
     */
    getAllUserPrivilegeSettingsMenu(): Promise<UserPrivilegeSettingsMenuModel[]> {
        let url_ = this.baseUrl + "/api/v1/user-privilege-settings/get-all-user-privilege-settings-menu";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllUserPrivilegeSettingsMenu(_response);
        });
    }

    protected processGetAllUserPrivilegeSettingsMenu(response: Response): Promise<UserPrivilegeSettingsMenuModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <UserPrivilegeSettingsMenuModel[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserPrivilegeSettingsMenuModel[]>(<any>null);
    }

    /**
     * @return Success
     */
    getAllUserPrivilegeSettingsPage(): Promise<UserPrivilegeSettingsPageModel[]> {
        let url_ = this.baseUrl + "/api/v1/user-privilege-settings/get-all-user-privilege-settings-page";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllUserPrivilegeSettingsPage(_response);
        });
    }

    protected processGetAllUserPrivilegeSettingsPage(response: Response): Promise<UserPrivilegeSettingsPageModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <UserPrivilegeSettingsPageModel[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserPrivilegeSettingsPageModel[]>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getAllUserPrivilegeSettingsMenuPageCrudById(id: string | null | undefined): Promise<UserPrivilegeSettingPageCRUD[]> {
        let url_ = this.baseUrl + "/api/v1/user-privilege-settings/get-all-user-privilege-settings-menu-page-crud-by-id?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllUserPrivilegeSettingsMenuPageCrudById(_response);
        });
    }

    protected processGetAllUserPrivilegeSettingsMenuPageCrudById(response: Response): Promise<UserPrivilegeSettingPageCRUD[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <UserPrivilegeSettingPageCRUD[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserPrivilegeSettingPageCRUD[]>(<any>null);
    }

    /**
     * @return Success
     */
    getUserPrivilegeSettingsByUserRoleId(id: number): Promise<UserPrivilegeSettingGetByUserId> {
        let url_ = this.baseUrl + "/api/v1/user-privilege-settings/get-user-privilege-settings-by-user-role-id/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetUserPrivilegeSettingsByUserRoleId(_response);
        });
    }

    protected processGetUserPrivilegeSettingsByUserRoleId(response: Response): Promise<UserPrivilegeSettingGetByUserId> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <UserPrivilegeSettingGetByUserId>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserPrivilegeSettingGetByUserId>(<any>null);
    }

    /**
     * @return Success
     */
    getUserRoleIdFromPrivilegePageMappingsId(id: number): Promise<number> {
        let url_ = this.baseUrl + "/api/v1/user-privilege-settings/get-user-role-id-from-privilege-page-mappings-id/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetUserRoleIdFromPrivilegePageMappingsId(_response);
        });
    }

    protected processGetUserRoleIdFromPrivilegePageMappingsId(response: Response): Promise<number> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <number>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<number>(<any>null);
    }

    /**
     * @param insert (optional) 
     * @return Success
     */
    insertUserPrivilegeSettings(insert: UserPrivilegeSettingsInsertModel[] | null | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/v1/user-privilege-settings/insert-user-privilege-settings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(insert);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processInsertUserPrivilegeSettings(_response);
        });
    }

    protected processInsertUserPrivilegeSettings(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <boolean>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param update (optional) 
     * @return Success
     */
    updateUserPrivilegeSettings(id: number | null | undefined, update: UserPrivilegeSettingsInsertModel[] | null | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/v1/user-privilege-settings/update-user-privilege-settings?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(update);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateUserPrivilegeSettings(_response);
        });
    }

    protected processUpdateUserPrivilegeSettings(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <boolean>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(<any>null);
    }

    /**
     * @param userRoleId (optional) 
     * @param id (optional) 
     * @return Success
     */
    deleteUserPrivilegeSettings(userRoleId: number | null | undefined, id: string[] | null | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/v1/user-privilege-settings/delete-user-privilege-settings?";
        if (userRoleId !== undefined)
            url_ += "userRoleId=" + encodeURIComponent("" + userRoleId) + "&"; 
        if (id !== undefined)
            id && id.forEach(item => { url_ += "id=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteUserPrivilegeSettings(_response);
        });
    }

    protected processDeleteUserPrivilegeSettings(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <boolean>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(<any>null);
    }

    /**
     * @param pageId (optional) 
     * @return Success
     */
    crudAccessPage(pageId: string | null | undefined): Promise<UserAccessCRUD> {
        let url_ = this.baseUrl + "/api/v1/user-privilege-settings/crud-access-page?";
        if (pageId !== undefined)
            url_ += "pageId=" + encodeURIComponent("" + pageId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCrudAccessPage(_response);
        });
    }

    protected processCrudAccessPage(response: Response): Promise<UserAccessCRUD> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <UserAccessCRUD>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserAccessCRUD>(<any>null);
    }

    /**
     * @return Success
     */
    pageAccess(): Promise<string[]> {
        let url_ = this.baseUrl + "/api/v1/user-privilege-settings/page-access";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPageAccess(_response);
        });
    }

    protected processPageAccess(response: Response): Promise<string[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <string[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string[]>(<any>null);
    }
}

export class UserRoleService {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param userRole (optional) 
     * @param typeofPeople (optional) 
     * @param position (optional) 
     * @param createdAt (optional) 
     * @param updatedAt (optional) 
     * @param sortBy (optional) 
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    getRole(userRole: string | null | undefined, typeofPeople: boolean | null | undefined, position: string | null | undefined, createdAt: Date | null | undefined, updatedAt: Date | null | undefined, sortBy: string | null | undefined, pageIndex: number | null | undefined, pageSize: number | null | undefined): Promise<UserRoleGridModel> {
        let url_ = this.baseUrl + "/api/v1/user-role/get-role?";
        if (userRole !== undefined)
            url_ += "UserRole=" + encodeURIComponent("" + userRole) + "&"; 
        if (typeofPeople !== undefined)
            url_ += "TypeofPeople=" + encodeURIComponent("" + typeofPeople) + "&"; 
        if (position !== undefined)
            url_ += "Position=" + encodeURIComponent("" + position) + "&"; 
        if (createdAt !== undefined)
            url_ += "CreatedAt=" + encodeURIComponent(createdAt ? "" + createdAt.toJSON() : "") + "&"; 
        if (updatedAt !== undefined)
            url_ += "UpdatedAt=" + encodeURIComponent(updatedAt ? "" + updatedAt.toJSON() : "") + "&"; 
        if (sortBy !== undefined)
            url_ += "SortBy=" + encodeURIComponent("" + sortBy) + "&"; 
        if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&"; 
        if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetRole(_response);
        });
    }

    protected processGetRole(response: Response): Promise<UserRoleGridModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <UserRoleGridModel>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserRoleGridModel>(<any>null);
    }

    /**
     * @param model (optional) 
     * @return Success
     */
    postUserRole(model: UserRoleModelCreate | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/v1/user-role/post-user-role";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPostUserRole(_response);
        });
    }

    protected processPostUserRole(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteUserRole(id: number | null | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/v1/user-role/delete-user-role?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteUserRole(_response);
        });
    }

    protected processDeleteUserRole(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <boolean>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(<any>null);
    }

    /**
     * @param model (optional) 
     * @return Success
     */
    updateUserRole(model: UserRoleModelUpdate | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/v1/user-role/update-user-role";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateUserRole(_response);
        });
    }

    protected processUpdateUserRole(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @return Success
     */
    tamPositionDropdown(): Promise<PositionDropdownModel[]> {
        let url_ = this.baseUrl + "/api/v1/user-role/tam-position-dropdown";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processTamPositionDropdown(_response);
        });
    }

    protected processTamPositionDropdown(response: Response): Promise<PositionDropdownModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <PositionDropdownModel[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PositionDropdownModel[]>(<any>null);
    }

    /**
     * @return Success
     */
    dealerPositionDropdown(): Promise<PositionDropdownModel[]> {
        let url_ = this.baseUrl + "/api/v1/user-role/dealer-position-dropdown";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDealerPositionDropdown(_response);
        });
    }

    protected processDealerPositionDropdown(response: Response): Promise<PositionDropdownModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <PositionDropdownModel[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PositionDropdownModel[]>(<any>null);
    }

    /**
     * @return Success
     */
    userRoleDropdown(): Promise<UserRoleDropdownModel[]> {
        let url_ = this.baseUrl + "/api/v1/user-role/user-role-dropdown";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUserRoleDropdown(_response);
        });
    }

    protected processUserRoleDropdown(response: Response): Promise<UserRoleDropdownModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <UserRoleDropdownModel[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserRoleDropdownModel[]>(<any>null);
    }

    /**
     * @return Success
     */
    categoryDropdown(): Promise<CategoryDropdownModel[]> {
        let url_ = this.baseUrl + "/api/v1/user-role/category-dropdown";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCategoryDropdown(_response);
        });
    }

    protected processCategoryDropdown(response: Response): Promise<CategoryDropdownModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <CategoryDropdownModel[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CategoryDropdownModel[]>(<any>null);
    }

    /**
     * @param userRoleId (optional) 
     * @return Success
     */
    getUserRoleData(userRoleId: number | null | undefined): Promise<UserRoleModelUpdate> {
        let url_ = this.baseUrl + "/api/v1/user-role/get-user-role-data?";
        if (userRoleId !== undefined)
            url_ += "userRoleId=" + encodeURIComponent("" + userRoleId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetUserRoleData(_response);
        });
    }

    protected processGetUserRoleData(response: Response): Promise<UserRoleModelUpdate> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <UserRoleModelUpdate>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserRoleModelUpdate>(<any>null);
    }

    /**
     * @param roleName (optional) 
     * @return Success
     */
    getUserRoleName(roleName: string | null | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/v1/user-role/get-user-role-name?";
        if (roleName !== undefined)
            url_ += "roleName=" + encodeURIComponent("" + roleName) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetUserRoleName(_response);
        });
    }

    protected processGetUserRoleName(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <boolean>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(<any>null);
    }

    /**
     * @param roleId (optional) 
     * @param roleName (optional) 
     * @return Success
     */
    getUserRoleNameById(roleId: number | null | undefined, roleName: string | null | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/v1/user-role/get-user-role-name-by-id?";
        if (roleId !== undefined)
            url_ += "roleId=" + encodeURIComponent("" + roleId) + "&"; 
        if (roleName !== undefined)
            url_ += "roleName=" + encodeURIComponent("" + roleName) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetUserRoleNameById(_response);
        });
    }

    protected processGetUserRoleNameById(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <boolean>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(<any>null);
    }

    /**
     * @param roleId (optional) 
     * @return Success
     */
    viewUserRoleDetail(roleId: number | null | undefined): Promise<UserRoleModelViewDetail> {
        let url_ = this.baseUrl + "/api/v1/user-role/view-user-role-detail?";
        if (roleId !== undefined)
            url_ += "roleId=" + encodeURIComponent("" + roleId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processViewUserRoleDetail(_response);
        });
    }

    protected processViewUserRoleDetail(response: Response): Promise<UserRoleModelViewDetail> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <UserRoleModelViewDetail>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserRoleModelViewDetail>(<any>null);
    }
}

export class UsersideAccessService {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    start(): Promise<void> {
        let url_ = this.baseUrl + "/api/userside-access/start";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processStart(_response);
        });
    }

    protected processStart(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param employeeAccessTimeId (optional) 
     * @return Success
     */
    end(employeeAccessTimeId: number | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/userside-access/end?";
        if (employeeAccessTimeId !== undefined)
            url_ += "employeeAccessTimeId=" + encodeURIComponent("" + employeeAccessTimeId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processEnd(_response);
        });
    }

    protected processEnd(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }
}

export class UsersideBadgesService {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param employeeId (optional) 
     * @return Success
     */
    getBadges(employeeId: string | null | undefined): Promise<UserSideBadgesViewModel> {
        let url_ = this.baseUrl + "/api/v1/userside-badges/get-badges?";
        if (employeeId !== undefined)
            url_ += "employeeId=" + encodeURIComponent("" + employeeId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetBadges(_response);
        });
    }

    protected processGetBadges(response: Response): Promise<UserSideBadgesViewModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <UserSideBadgesViewModel>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserSideBadgesViewModel>(<any>null);
    }

    /**
     * @return Success
     */
    getBadgesByToken(): Promise<UserSideBadgesViewModel> {
        let url_ = this.baseUrl + "/api/v1/userside-badges/get-badges-by-token";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetBadgesByToken(_response);
        });
    }

    protected processGetBadgesByToken(response: Response): Promise<UserSideBadgesViewModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <UserSideBadgesViewModel>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserSideBadgesViewModel>(<any>null);
    }
}

//export class V1Service {
//    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
//    private baseUrl: string;
//    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

//    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
//        this.http = http ? http : <any>window;
//        this.baseUrl = baseUrl ? baseUrl : "";
//    }

//    /**
//     * @param itemPerPage (optional) 
//     * @param pageIndex (optional) 
//     * @return Success
//     */
//    usersideBanners(itemPerPage: number | null | undefined, pageIndex: number | null | undefined): Promise<UserSideBannerModel[]> {
//        let url_ = this.baseUrl + "/api/v1/userside-banners?";
//        if (itemPerPage !== undefined)
//            url_ += "itemPerPage=" + encodeURIComponent("" + itemPerPage) + "&"; 
//        if (pageIndex !== undefined)
//            url_ += "pageIndex=" + encodeURIComponent("" + pageIndex) + "&"; 
//        url_ = url_.replace(/[?&]$/, "");

//        let options_ = <RequestInit>{
//            method: "GET",
//            headers: {
//                "Accept": "application/json"
//            }
//        };

//        return this.http.fetch(url_, options_).then((_response: Response) => {
//            return this.processUsersideBanners(_response);
//        });
//    }

//    protected processUsersideBanners(response: Response): Promise<UserSideBannerModel[]> {
//        const status = response.status;
//        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
//        if (status === 200) {
//            return response.text().then((_responseText) => {
//            let result200: any = null;
//            result200 = _responseText === "" ? null : <UserSideBannerModel[]>JSON.parse(_responseText, this.jsonParseReviver);
//            return result200;
//            });
//        } else if (status !== 200 && status !== 204) {
//            return response.text().then((_responseText) => {
//            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
//            });
//        }
//        return Promise.resolve<UserSideBannerModel[]>(<any>null);
//    }

//    /**
//     * @param pageIndex (optional) 
//     * @param pageSize (optional) 
//     * @param keyword (optional) 
//     * @return Success
//     */
//    usersideCoach(pageIndex: number | null | undefined, pageSize: number | null | undefined, keyword: string | null | undefined): Promise<UserSideCoachResponseModel> {
//        let url_ = this.baseUrl + "/api/v1/userside-coach?";
//        if (pageIndex !== undefined)
//            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&"; 
//        if (pageSize !== undefined)
//            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&"; 
//        if (keyword !== undefined)
//            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&"; 
//        url_ = url_.replace(/[?&]$/, "");

//        let options_ = <RequestInit>{
//            method: "GET",
//            headers: {
//                "Accept": "application/json"
//            }
//        };

//        return this.http.fetch(url_, options_).then((_response: Response) => {
//            return this.processUsersideCoach(_response);
//        });
//    }

//    protected processUsersideCoach(response: Response): Promise<UserSideCoachResponseModel> {
//        const status = response.status;
//        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
//        if (status === 200) {
//            return response.text().then((_responseText) => {
//            let result200: any = null;
//            result200 = _responseText === "" ? null : <UserSideCoachResponseModel>JSON.parse(_responseText, this.jsonParseReviver);
//            return result200;
//            });
//        } else if (status !== 200 && status !== 204) {
//            return response.text().then((_responseText) => {
//            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
//            });
//        }
//        return Promise.resolve<UserSideCoachResponseModel>(<any>null);
//    }

//    /**
//     * @return Success
//     */
//    usersideHobby(): Promise<UserSideHobbyModel[]> {
//        let url_ = this.baseUrl + "/api/v1/userside-hobby";
//        url_ = url_.replace(/[?&]$/, "");

//        let options_ = <RequestInit>{
//            method: "GET",
//            headers: {
//                "Accept": "application/json"
//            }
//        };

//        return this.http.fetch(url_, options_).then((_response: Response) => {
//            return this.processUsersideHobby(_response);
//        });
//    }

//    protected processUsersideHobby(response: Response): Promise<UserSideHobbyModel[]> {
//        const status = response.status;
//        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
//        if (status === 200) {
//            return response.text().then((_responseText) => {
//            let result200: any = null;
//            result200 = _responseText === "" ? null : <UserSideHobbyModel[]>JSON.parse(_responseText, this.jsonParseReviver);
//            return result200;
//            });
//        } else if (status !== 200 && status !== 204) {
//            return response.text().then((_responseText) => {
//            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
//            });
//        }
//        return Promise.resolve<UserSideHobbyModel[]>(<any>null);
//    }

//    /**
//     * @param itemPerPage (optional) 
//     * @param pageIndex (optional) 
//     * @param search (optional) 
//     * @return Success
//     */
//    usersideInboxes(itemPerPage: number | null | undefined, pageIndex: number | null | undefined, search: string | null | undefined): Promise<UserSideInboxModel[]> {
//        let url_ = this.baseUrl + "/api/v1/userside-inboxes?";
//        if (itemPerPage !== undefined)
//            url_ += "itemPerPage=" + encodeURIComponent("" + itemPerPage) + "&"; 
//        if (pageIndex !== undefined)
//            url_ += "pageIndex=" + encodeURIComponent("" + pageIndex) + "&"; 
//        if (search !== undefined)
//            url_ += "search=" + encodeURIComponent("" + search) + "&"; 
//        url_ = url_.replace(/[?&]$/, "");

//        let options_ = <RequestInit>{
//            method: "GET",
//            headers: {
//                "Accept": "application/json"
//            }
//        };

//        return this.http.fetch(url_, options_).then((_response: Response) => {
//            return this.processUsersideInboxes(_response);
//        });
//    }

//    protected processUsersideInboxes(response: Response): Promise<UserSideInboxModel[]> {
//        const status = response.status;
//        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
//        if (status === 200) {
//            return response.text().then((_responseText) => {
//            let result200: any = null;
//            result200 = _responseText === "" ? null : <UserSideInboxModel[]>JSON.parse(_responseText, this.jsonParseReviver);
//            return result200;
//            });
//        } else if (status !== 200 && status !== 204) {
//            return response.text().then((_responseText) => {
//            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
//            });
//        }
//        return Promise.resolve<UserSideInboxModel[]>(<any>null);
//    }

//    /**
//     * @return Success
//     */
//    usersideInterest(): Promise<UserSideInterestModel[]> {
//        let url_ = this.baseUrl + "/api/v1/userside-interest";
//        url_ = url_.replace(/[?&]$/, "");

//        let options_ = <RequestInit>{
//            method: "GET",
//            headers: {
//                "Accept": "application/json"
//            }
//        };

//        return this.http.fetch(url_, options_).then((_response: Response) => {
//            return this.processUsersideInterest(_response);
//        });
//    }

//    protected processUsersideInterest(response: Response): Promise<UserSideInterestModel[]> {
//        const status = response.status;
//        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
//        if (status === 200) {
//            return response.text().then((_responseText) => {
//            let result200: any = null;
//            result200 = _responseText === "" ? null : <UserSideInterestModel[]>JSON.parse(_responseText, this.jsonParseReviver);
//            return result200;
//            });
//        } else if (status !== 200 && status !== 204) {
//            return response.text().then((_responseText) => {
//            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
//            });
//        }
//        return Promise.resolve<UserSideInterestModel[]>(<any>null);
//    }

//    /**
//     * @param pageIndex (optional) 
//     * @param pageSize (optional) 
//     * @param keyword (optional) 
//     * @param programTypeIds (optional) 
//     * @param learningTypeIds (optional) 
//     * @param materialTypeIds (optional) 
//     * @param isFree (optional) 
//     * @param isNotFree (optional) 
//     * @return Success
//     */
//    usersideLearningHistory(employeeId: string, pageIndex: number | null | undefined, pageSize: number | null | undefined, keyword: string | null | undefined, programTypeIds: number[] | null | undefined, learningTypeIds: number[] | null | undefined, materialTypeIds: number[] | null | undefined, isFree: boolean | null | undefined, isNotFree: boolean | null | undefined): Promise<UserSideLearningHistoryResponseModel> {
//        let url_ = this.baseUrl + "/api/v1/userside-learning-history/{employeeId}?";
//        if (employeeId === undefined || employeeId === null)
//            throw new Error("The parameter 'employeeId' must be defined.");
//        url_ = url_.replace("{employeeId}", encodeURIComponent("" + employeeId)); 
//        if (pageIndex !== undefined)
//            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&"; 
//        if (pageSize !== undefined)
//            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&"; 
//        if (keyword !== undefined)
//            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&"; 
//        if (programTypeIds !== undefined)
//            programTypeIds && programTypeIds.forEach(item => { url_ += "ProgramTypeIds=" + encodeURIComponent("" + item) + "&"; });
//        if (learningTypeIds !== undefined)
//            learningTypeIds && learningTypeIds.forEach(item => { url_ += "LearningTypeIds=" + encodeURIComponent("" + item) + "&"; });
//        if (materialTypeIds !== undefined)
//            materialTypeIds && materialTypeIds.forEach(item => { url_ += "MaterialTypeIds=" + encodeURIComponent("" + item) + "&"; });
//        if (isFree !== undefined)
//            url_ += "IsFree=" + encodeURIComponent("" + isFree) + "&"; 
//        if (isNotFree !== undefined)
//            url_ += "IsNotFree=" + encodeURIComponent("" + isNotFree) + "&"; 
//        url_ = url_.replace(/[?&]$/, "");

//        let options_ = <RequestInit>{
//            method: "GET",
//            headers: {
//                "Accept": "application/json"
//            }
//        };

//        return this.http.fetch(url_, options_).then((_response: Response) => {
//            return this.processUsersideLearningHistory(_response);
//        });
//    }

//    protected processUsersideLearningHistory(response: Response): Promise<UserSideLearningHistoryResponseModel> {
//        const status = response.status;
//        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
//        if (status === 200) {
//            return response.text().then((_responseText) => {
//            let result200: any = null;
//            result200 = _responseText === "" ? null : <UserSideLearningHistoryResponseModel>JSON.parse(_responseText, this.jsonParseReviver);
//            return result200;
//            });
//        } else if (status !== 200 && status !== 204) {
//            return response.text().then((_responseText) => {
//            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
//            });
//        }
//        return Promise.resolve<UserSideLearningHistoryResponseModel>(<any>null);
//    }

//    /**
//     * @param pageIndex (optional) 
//     * @param pageSize (optional) 
//     * @param keyword (optional) 
//     * @return Success
//     */
//    usersideTeamCourseGet(pageIndex: number | null | undefined, pageSize: number | null | undefined, keyword: string | null | undefined, employeeId: string): Promise<UserSideMyProfileCourseResponseModel> {
//        let url_ = this.baseUrl + "/api/v1/userside-team-course/{employeeId}?";
//        if (employeeId === undefined || employeeId === null)
//            throw new Error("The parameter 'employeeId' must be defined.");
//        url_ = url_.replace("{employeeId}", encodeURIComponent("" + employeeId)); 
//        if (pageIndex !== undefined)
//            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&"; 
//        if (pageSize !== undefined)
//            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&"; 
//        if (keyword !== undefined)
//            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&"; 
//        url_ = url_.replace(/[?&]$/, "");

//        let options_ = <RequestInit>{
//            method: "GET",
//            headers: {
//                "Accept": "application/json"
//            }
//        };

//        return this.http.fetch(url_, options_).then((_response: Response) => {
//            return this.processUsersideTeamCourseGet(_response);
//        });
//    }

//    protected processUsersideTeamCourseGet(response: Response): Promise<UserSideMyProfileCourseResponseModel> {
//        const status = response.status;
//        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
//        if (status === 200) {
//            return response.text().then((_responseText) => {
//            let result200: any = null;
//            result200 = _responseText === "" ? null : <UserSideMyProfileCourseResponseModel>JSON.parse(_responseText, this.jsonParseReviver);
//            return result200;
//            });
//        } else if (status !== 200 && status !== 204) {
//            return response.text().then((_responseText) => {
//            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
//            });
//        }
//        return Promise.resolve<UserSideMyProfileCourseResponseModel>(<any>null);
//    }

//    /**
//     * @param trainingId (optional) 
//     * @param assignedTo (optional) 
//     * @return Success
//     */
//    usersideTeamCoursePost(trainingId: number | null | undefined, assignedTo: string | null | undefined): Promise<void> {
//        let url_ = this.baseUrl + "/api/v1/userside-team-course";
//        url_ = url_.replace(/[?&]$/, "");

//        const content_ = new FormData();
//        if (trainingId !== null && trainingId !== undefined)
//            content_.append("TrainingId", trainingId.toString());
//        if (assignedTo !== null && assignedTo !== undefined)
//            content_.append("AssignedTo", assignedTo.toString());

//        let options_ = <RequestInit>{
//            body: content_,
//            method: "POST",
//            headers: {
//            }
//        };

//        return this.http.fetch(url_, options_).then((_response: Response) => {
//            return this.processUsersideTeamCoursePost(_response);
//        });
//    }

//    protected processUsersideTeamCoursePost(response: Response): Promise<void> {
//        const status = response.status;
//        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
//        if (status === 200) {
//            return response.text().then((_responseText) => {
//            return;
//            });
//        } else if (status !== 200 && status !== 204) {
//            return response.text().then((_responseText) => {
//            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
//            });
//        }
//        return Promise.resolve<void>(<any>null);
//    }

//    /**
//     * @param trainingId (optional) 
//     * @param assignedTo (optional) 
//     * @return Success
//     */
//    usersideTeamCoursePost(trainingId: number | null | undefined, assignedTo: string | null | undefined, assignedBy: string): Promise<void> {
//        let url_ = this.baseUrl + "/api/v1/userside-team-course/{assignedBy}";
//        if (assignedBy === undefined || assignedBy === null)
//            throw new Error("The parameter 'assignedBy' must be defined.");
//        url_ = url_.replace("{assignedBy}", encodeURIComponent("" + assignedBy)); 
//        url_ = url_.replace(/[?&]$/, "");

//        const content_ = new FormData();
//        if (trainingId !== null && trainingId !== undefined)
//            content_.append("TrainingId", trainingId.toString());
//        if (assignedTo !== null && assignedTo !== undefined)
//            content_.append("AssignedTo", assignedTo.toString());

//        let options_ = <RequestInit>{
//            body: content_,
//            method: "POST",
//            headers: {
//            }
//        };

//        return this.http.fetch(url_, options_).then((_response: Response) => {
//            return this.processUsersideTeamCoursePost(_response);
//        });
//    }

//    protected processUsersideTeamCoursePost(response: Response): Promise<void> {
//        const status = response.status;
//        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
//        if (status === 200) {
//            return response.text().then((_responseText) => {
//            return;
//            });
//        } else if (status !== 200 && status !== 204) {
//            return response.text().then((_responseText) => {
//            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
//            });
//        }
//        return Promise.resolve<void>(<any>null);
//    }

//    /**
//     * @param trainingId (optional) 
//     * @param assignedTo (optional) 
//     * @return Success
//     */
//    usersideTeamCoursePut(assignedLearningId: number, trainingId: number | null | undefined, assignedTo: string | null | undefined): Promise<void> {
//        let url_ = this.baseUrl + "/api/v1/userside-team-course/{assignedLearningId}";
//        if (assignedLearningId === undefined || assignedLearningId === null)
//            throw new Error("The parameter 'assignedLearningId' must be defined.");
//        url_ = url_.replace("{assignedLearningId}", encodeURIComponent("" + assignedLearningId)); 
//        url_ = url_.replace(/[?&]$/, "");

//        const content_ = new FormData();
//        if (trainingId !== null && trainingId !== undefined)
//            content_.append("TrainingId", trainingId.toString());
//        if (assignedTo !== null && assignedTo !== undefined)
//            content_.append("AssignedTo", assignedTo.toString());

//        let options_ = <RequestInit>{
//            body: content_,
//            method: "PUT",
//            headers: {
//            }
//        };

//        return this.http.fetch(url_, options_).then((_response: Response) => {
//            return this.processUsersideTeamCoursePut(_response);
//        });
//    }

//    protected processUsersideTeamCoursePut(response: Response): Promise<void> {
//        const status = response.status;
//        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
//        if (status === 200) {
//            return response.text().then((_responseText) => {
//            return;
//            });
//        } else if (status !== 200 && status !== 204) {
//            return response.text().then((_responseText) => {
//            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
//            });
//        }
//        return Promise.resolve<void>(<any>null);
//    }

//    /**
//     * @param filter (optional) 
//     * @return Success
//     */
//    usersideTimeTable(filter: string | null | undefined): Promise<UserSideTimeTableResponseModel> {
//        let url_ = this.baseUrl + "/api/v1/userside-time-table?";
//        if (filter !== undefined)
//            url_ += "filter=" + encodeURIComponent("" + filter) + "&"; 
//        url_ = url_.replace(/[?&]$/, "");

//        let options_ = <RequestInit>{
//            method: "GET",
//            headers: {
//                "Accept": "application/json"
//            }
//        };

//        return this.http.fetch(url_, options_).then((_response: Response) => {
//            return this.processUsersideTimeTable(_response);
//        });
//    }

//    protected processUsersideTimeTable(response: Response): Promise<UserSideTimeTableResponseModel> {
//        const status = response.status;
//        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
//        if (status === 200) {
//            return response.text().then((_responseText) => {
//            let result200: any = null;
//            result200 = _responseText === "" ? null : <UserSideTimeTableResponseModel>JSON.parse(_responseText, this.jsonParseReviver);
//            return result200;
//            });
//        } else if (status !== 200 && status !== 204) {
//            return response.text().then((_responseText) => {
//            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
//            });
//        }
//        return Promise.resolve<UserSideTimeTableResponseModel>(<any>null);
//    }

//    /**
//     * @param fileUploaded_Base64 (optional) 
//     * @param fileUploaded_FileName (optional) 
//     * @param fileUploaded_ContentType (optional) 
//     * @param employeeId (optional) 
//     * @return Success
//     */
//    usersideUploadCertificate(title: string, type: string, eventDate: Date, trainingName: string, host: string, venue: string, fileUploaded_Base64: string | null | undefined, fileUploaded_FileName: string | null | undefined, fileUploaded_ContentType: string | null | undefined, employeeId: string | null | undefined): Promise<void> {
//        let url_ = this.baseUrl + "/api/v1/userside-upload-certificate?";
//        if (employeeId !== undefined)
//            url_ += "employeeId=" + encodeURIComponent("" + employeeId) + "&"; 
//        url_ = url_.replace(/[?&]$/, "");

//        const content_ = new FormData();
//        if (title === null || title === undefined)
//            throw new Error("The parameter 'title' cannot be null.");
//        else
//            content_.append("Title", title.toString());
//        if (type === null || type === undefined)
//            throw new Error("The parameter 'type' cannot be null.");
//        else
//            content_.append("Type", type.toString());
//        if (eventDate === null || eventDate === undefined)
//            throw new Error("The parameter 'eventDate' cannot be null.");
//        else
//            content_.append("EventDate", eventDate.toJSON());
//        if (trainingName === null || trainingName === undefined)
//            throw new Error("The parameter 'trainingName' cannot be null.");
//        else
//            content_.append("TrainingName", trainingName.toString());
//        if (host === null || host === undefined)
//            throw new Error("The parameter 'host' cannot be null.");
//        else
//            content_.append("Host", host.toString());
//        if (venue === null || venue === undefined)
//            throw new Error("The parameter 'venue' cannot be null.");
//        else
//            content_.append("Venue", venue.toString());
//        if (fileUploaded_Base64 !== null && fileUploaded_Base64 !== undefined)
//            content_.append("FileUploaded.Base64", fileUploaded_Base64.toString());
//        if (fileUploaded_FileName !== null && fileUploaded_FileName !== undefined)
//            content_.append("FileUploaded.FileName", fileUploaded_FileName.toString());
//        if (fileUploaded_ContentType !== null && fileUploaded_ContentType !== undefined)
//            content_.append("FileUploaded.ContentType", fileUploaded_ContentType.toString());

//        let options_ = <RequestInit>{
//            body: content_,
//            method: "POST",
//            headers: {
//            }
//        };

//        return this.http.fetch(url_, options_).then((_response: Response) => {
//            return this.processUsersideUploadCertificate(_response);
//        });
//    }

//    protected processUsersideUploadCertificate(response: Response): Promise<void> {
//        const status = response.status;
//        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
//        if (status === 200) {
//            return response.text().then((_responseText) => {
//            return;
//            });
//        } else if (status !== 200 && status !== 204) {
//            return response.text().then((_responseText) => {
//            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
//            });
//        }
//        return Promise.resolve<void>(<any>null);
//    }
//}

export class UsersideCertificateService {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param employeeId (optional) 
     * @return Success
     */
    getCertificateById(employeeId: string | null | undefined): Promise<UserSideCertificateModel> {
        let url_ = this.baseUrl + "/api/v1/userside-certificate/get-certificate-by-id?";
        if (employeeId !== undefined)
            url_ += "employeeId=" + encodeURIComponent("" + employeeId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetCertificateById(_response);
        });
    }

    protected processGetCertificateById(response: Response): Promise<UserSideCertificateModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <UserSideCertificateModel>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserSideCertificateModel>(<any>null);
    }

    /**
     * @return Success
     */
    getCertificateByToken(): Promise<UserSideCertificateModel> {
        let url_ = this.baseUrl + "/api/v1/userside-certificate/get-certificate-by-token";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetCertificateByToken(_response);
        });
    }

    protected processGetCertificateByToken(response: Response): Promise<UserSideCertificateModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <UserSideCertificateModel>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserSideCertificateModel>(<any>null);
    }

    /**
     * @return Success
     */
    getSingleCertificate(certificateId: number): Promise<string> {
        let url_ = this.baseUrl + "/api/v1/userside-certificate/get-single-certificate/{certificateId}";
        if (certificateId === undefined || certificateId === null)
            throw new Error("The parameter 'certificateId' must be defined.");
        url_ = url_.replace("{certificateId}", encodeURIComponent("" + certificateId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetSingleCertificate(_response);
        });
    }

    protected processGetSingleCertificate(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <string>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(<any>null);
    }
}

export class UsersideCoachService {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    coachScheduleBooking(coachId: number): Promise<UserSideCoachScheduleBookingModel> {
        let url_ = this.baseUrl + "/api/v1/userside-coach/coach-schedule-booking/{coachId}";
        if (coachId === undefined || coachId === null)
            throw new Error("The parameter 'coachId' must be defined.");
        url_ = url_.replace("{coachId}", encodeURIComponent("" + coachId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCoachScheduleBooking(_response);
        });
    }

    protected processCoachScheduleBooking(response: Response): Promise<UserSideCoachScheduleBookingModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <UserSideCoachScheduleBookingModel>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserSideCoachScheduleBookingModel>(<any>null);
    }
}

export class UsersideCoachScheduleService {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getScheduleById(employeeId: string): Promise<UserSideCoachScheduleViewModel[]> {
        let url_ = this.baseUrl + "/api/v1/userside-coach-schedule/get-schedule-by-id/{employeeId}";
        if (employeeId === undefined || employeeId === null)
            throw new Error("The parameter 'employeeId' must be defined.");
        url_ = url_.replace("{employeeId}", encodeURIComponent("" + employeeId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetScheduleById(_response);
        });
    }

    protected processGetScheduleById(response: Response): Promise<UserSideCoachScheduleViewModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <UserSideCoachScheduleViewModel[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserSideCoachScheduleViewModel[]>(<any>null);
    }

    /**
     * @return Success
     */
    getScheduleByToken(): Promise<UserSideCoachScheduleViewModel[]> {
        let url_ = this.baseUrl + "/api/v1/userside-coach-schedule/get-schedule-by-token";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetScheduleByToken(_response);
        });
    }

    protected processGetScheduleByToken(response: Response): Promise<UserSideCoachScheduleViewModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <UserSideCoachScheduleViewModel[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserSideCoachScheduleViewModel[]>(<any>null);
    }

    /**
     * @param coachId (optional) 
     * @return Success
     */
    createSchedule(scheduleName: string, startDateTime: Date, endDateTime: Date, coachId: number | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/v1/userside-coach-schedule/create-schedule?";
        if (coachId !== undefined)
            url_ += "coachId=" + encodeURIComponent("" + coachId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (scheduleName === null || scheduleName === undefined)
            throw new Error("The parameter 'scheduleName' cannot be null.");
        else
            content_.append("ScheduleName", scheduleName.toString());
        if (startDateTime === null || startDateTime === undefined)
            throw new Error("The parameter 'startDateTime' cannot be null.");
        else
            content_.append("StartDateTime", startDateTime.toJSON());
        if (endDateTime === null || endDateTime === undefined)
            throw new Error("The parameter 'endDateTime' cannot be null.");
        else
            content_.append("EndDateTime", endDateTime.toJSON());

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateSchedule(_response);
        });
    }

    protected processCreateSchedule(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param coachScheduleId (optional) 
     * @return Success
     */
    deleteSchedule(coachScheduleId: number | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/v1/userside-coach-schedule/delete-schedule?";
        if (coachScheduleId !== undefined)
            url_ += "coachScheduleId=" + encodeURIComponent("" + coachScheduleId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteSchedule(_response);
        });
    }

    protected processDeleteSchedule(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param coachScheduleId (optional) 
     * @return Success
     */
    updateSchedule(coachScheduleId: number | null | undefined, scheduleName: string, startDateTime: Date, endDateTime: Date): Promise<void> {
        let url_ = this.baseUrl + "/api/v1/userside-coach-schedule/update-schedule";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (coachScheduleId !== null && coachScheduleId !== undefined)
            content_.append("CoachScheduleId", coachScheduleId.toString());
        if (scheduleName === null || scheduleName === undefined)
            throw new Error("The parameter 'scheduleName' cannot be null.");
        else
            content_.append("ScheduleName", scheduleName.toString());
        if (startDateTime === null || startDateTime === undefined)
            throw new Error("The parameter 'startDateTime' cannot be null.");
        else
            content_.append("StartDateTime", startDateTime.toJSON());
        if (endDateTime === null || endDateTime === undefined)
            throw new Error("The parameter 'endDateTime' cannot be null.");
        else
            content_.append("EndDateTime", endDateTime.toJSON());

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateSchedule(_response);
        });
    }

    protected processUpdateSchedule(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }
}

export class UsersideFilterlistService {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param outletPageSize (optional) 
     * @param outletKeyword (optional) 
     * @param positionPageSize (optional) 
     * @param positionKeyword (optional) 
     * @return Success
     */
    getMyTeamFilter(outletPageSize: number | null | undefined, outletKeyword: string | null | undefined, positionPageSize: number | null | undefined, positionKeyword: string | null | undefined): Promise<UserSideMyTeamFilterListModel> {
        let url_ = this.baseUrl + "/api/v1/userside-filterlist/get-my-team-filter?";
        if (outletPageSize !== undefined)
            url_ += "outletPageSize=" + encodeURIComponent("" + outletPageSize) + "&"; 
        if (outletKeyword !== undefined)
            url_ += "outletKeyword=" + encodeURIComponent("" + outletKeyword) + "&"; 
        if (positionPageSize !== undefined)
            url_ += "positionPageSize=" + encodeURIComponent("" + positionPageSize) + "&"; 
        if (positionKeyword !== undefined)
            url_ += "positionKeyword=" + encodeURIComponent("" + positionKeyword) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetMyTeamFilter(_response);
        });
    }

    protected processGetMyTeamFilter(response: Response): Promise<UserSideMyTeamFilterListModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <UserSideMyTeamFilterListModel>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserSideMyTeamFilterListModel>(<any>null);
    }

    /**
     * @param areaPageSize (optional) 
     * @param positionPageSize (optional) 
     * @param dealerPageSize (optional) 
     * @param areaKeyword (optional) 
     * @param postionKeyword (optional) 
     * @param dealerKeyword (optional) 
     * @return Success
     */
    getMyRankFilter(areaPageSize: number | null | undefined, positionPageSize: number | null | undefined, dealerPageSize: number | null | undefined, areaKeyword: string | null | undefined, postionKeyword: string | null | undefined, dealerKeyword: string | null | undefined): Promise<UserSideMyRankFilterListModel> {
        let url_ = this.baseUrl + "/api/v1/userside-filterlist/get-my-rank-filter?";
        if (areaPageSize !== undefined)
            url_ += "AreaPageSize=" + encodeURIComponent("" + areaPageSize) + "&"; 
        if (positionPageSize !== undefined)
            url_ += "PositionPageSize=" + encodeURIComponent("" + positionPageSize) + "&"; 
        if (dealerPageSize !== undefined)
            url_ += "DealerPageSize=" + encodeURIComponent("" + dealerPageSize) + "&"; 
        if (areaKeyword !== undefined)
            url_ += "AreaKeyword=" + encodeURIComponent("" + areaKeyword) + "&"; 
        if (postionKeyword !== undefined)
            url_ += "PostionKeyword=" + encodeURIComponent("" + postionKeyword) + "&"; 
        if (dealerKeyword !== undefined)
            url_ += "DealerKeyword=" + encodeURIComponent("" + dealerKeyword) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetMyRankFilter(_response);
        });
    }

    protected processGetMyRankFilter(response: Response): Promise<UserSideMyRankFilterListModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <UserSideMyRankFilterListModel>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserSideMyRankFilterListModel>(<any>null);
    }

    /**
     * @param outletPageSize (optional) 
     * @param areaPageSize (optional) 
     * @param dealerPageSize (optional) 
     * @param provincePageSize (optional) 
     * @param cityPageSize (optional) 
     * @param positionPageSize (optional) 
     * @return Success
     */
    getGeneralFilter(outletPageSize: number | null | undefined, areaPageSize: number | null | undefined, dealerPageSize: number | null | undefined, provincePageSize: number | null | undefined, cityPageSize: number | null | undefined, positionPageSize: number | null | undefined): Promise<UserSideGeneralFilterListModel> {
        let url_ = this.baseUrl + "/api/v1/userside-filterlist/get-general-filter?";
        if (outletPageSize !== undefined)
            url_ += "OutletPageSize=" + encodeURIComponent("" + outletPageSize) + "&"; 
        if (areaPageSize !== undefined)
            url_ += "AreaPageSize=" + encodeURIComponent("" + areaPageSize) + "&"; 
        if (dealerPageSize !== undefined)
            url_ += "DealerPageSize=" + encodeURIComponent("" + dealerPageSize) + "&"; 
        if (provincePageSize !== undefined)
            url_ += "ProvincePageSize=" + encodeURIComponent("" + provincePageSize) + "&"; 
        if (cityPageSize !== undefined)
            url_ += "CityPageSize=" + encodeURIComponent("" + cityPageSize) + "&"; 
        if (positionPageSize !== undefined)
            url_ += "PositionPageSize=" + encodeURIComponent("" + positionPageSize) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetGeneralFilter(_response);
        });
    }

    protected processGetGeneralFilter(response: Response): Promise<UserSideGeneralFilterListModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <UserSideGeneralFilterListModel>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserSideGeneralFilterListModel>(<any>null);
    }

    /**
     * @return Success
     */
    getMyLearningFilter(): Promise<UserSideMyLearningFilterListModel> {
        let url_ = this.baseUrl + "/api/v1/userside-filterlist/get-my-learning-filter";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetMyLearningFilter(_response);
        });
    }

    protected processGetMyLearningFilter(response: Response): Promise<UserSideMyLearningFilterListModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <UserSideMyLearningFilterListModel>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserSideMyLearningFilterListModel>(<any>null);
    }

    /**
     * @return Success
     */
    getMyNewsFilter(): Promise<UserSideMyNewsFilterListModel> {
        let url_ = this.baseUrl + "/api/v1/userside-filterlist/get-my-news-filter";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetMyNewsFilter(_response);
        });
    }

    protected processGetMyNewsFilter(response: Response): Promise<UserSideMyNewsFilterListModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <UserSideMyNewsFilterListModel>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserSideMyNewsFilterListModel>(<any>null);
    }

    /**
     * @return Success
     */
    getMyEventFilter(): Promise<UserSideMyEventFilterListModel> {
        let url_ = this.baseUrl + "/api/v1/userside-filterlist/get-my-event-filter";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetMyEventFilter(_response);
        });
    }

    protected processGetMyEventFilter(response: Response): Promise<UserSideMyEventFilterListModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <UserSideMyEventFilterListModel>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserSideMyEventFilterListModel>(<any>null);
    }

    /**
     * @param topicPageSize (optional) 
     * @param topicPageIndex (optional) 
     * @return Success
     */
    getMyCoachFilter(topicPageSize: number | null | undefined, topicPageIndex: number | null | undefined): Promise<UserSideMyCoachFilterListModel> {
        let url_ = this.baseUrl + "/api/v1/userside-filterlist/get-my-coach-filter?";
        if (topicPageSize !== undefined)
            url_ += "TopicPageSize=" + encodeURIComponent("" + topicPageSize) + "&"; 
        if (topicPageIndex !== undefined)
            url_ += "TopicPageIndex=" + encodeURIComponent("" + topicPageIndex) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetMyCoachFilter(_response);
        });
    }

    protected processGetMyCoachFilter(response: Response): Promise<UserSideMyCoachFilterListModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <UserSideMyCoachFilterListModel>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserSideMyCoachFilterListModel>(<any>null);
    }
}

export class UsersideGenerateCertificatePdfService {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    generateEmployeeCertificate(trainingId: number): Promise<boolean> {
        let url_ = this.baseUrl + "/api/v1/userside-generate-certificate-pdf/generate-employee-certificate/{trainingId}";
        if (trainingId === undefined || trainingId === null)
            throw new Error("The parameter 'trainingId' must be defined.");
        url_ = url_.replace("{trainingId}", encodeURIComponent("" + trainingId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGenerateEmployeeCertificate(_response);
        });
    }

    protected processGenerateEmployeeCertificate(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <boolean>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(<any>null);
    }
}

export class UsersideInboxesService {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    detailInbox(inboxId: number): Promise<UserSideInboxModel[]> {
        let url_ = this.baseUrl + "/api/v1/userside-inboxes/detail-inbox/{inboxId}";
        if (inboxId === undefined || inboxId === null)
            throw new Error("The parameter 'inboxId' must be defined.");
        url_ = url_.replace("{inboxId}", encodeURIComponent("" + inboxId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDetailInbox(_response);
        });
    }

    protected processDetailInbox(response: Response): Promise<UserSideInboxModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <UserSideInboxModel[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserSideInboxModel[]>(<any>null);
    }

    /**
     * @param model (optional) 
     * @return Success
     */
    updateRequestRotation(model: UserSideUpdateStatusRequestRotationModel | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/v1/userside-inboxes/update-request-rotation";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateRequestRotation(_response);
        });
    }

    protected processUpdateRequestRotation(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param model (optional) 
     * @return Success
     */
    updateRequestTeamMember(model: UserSideUpdateStatusRequestTeamMemberModel | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/v1/userside-inboxes/update-request-team-member";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateRequestTeamMember(_response);
        });
    }

    protected processUpdateRequestTeamMember(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @return Success
     */
    checkUnreadInbox(): Promise<boolean> {
        let url_ = this.baseUrl + "/api/v1/userside-inboxes/check-unread-inbox";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCheckUnreadInbox(_response);
        });
    }

    protected processCheckUnreadInbox(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <boolean>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(<any>null);
    }
}

export class UsersideLearningHistoryService {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @param keyword (optional) 
     * @param programTypeIds (optional) 
     * @param learningTypeIds (optional) 
     * @param materialTypeIds (optional) 
     * @param isFree (optional) 
     * @param isNotFree (optional) 
     * @return Success
     */
    byToken(pageIndex: number | null | undefined, pageSize: number | null | undefined, keyword: string | null | undefined, programTypeIds: number[] | null | undefined, learningTypeIds: number[] | null | undefined, materialTypeIds: number[] | null | undefined, isFree: boolean | null | undefined, isNotFree: boolean | null | undefined): Promise<UserSideLearningHistoryResponseModel> {
        let url_ = this.baseUrl + "/api/v1/userside-learning-history/by-token?";
        if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&"; 
        if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&"; 
        if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&"; 
        if (programTypeIds !== undefined)
            programTypeIds && programTypeIds.forEach(item => { url_ += "ProgramTypeIds=" + encodeURIComponent("" + item) + "&"; });
        if (learningTypeIds !== undefined)
            learningTypeIds && learningTypeIds.forEach(item => { url_ += "LearningTypeIds=" + encodeURIComponent("" + item) + "&"; });
        if (materialTypeIds !== undefined)
            materialTypeIds && materialTypeIds.forEach(item => { url_ += "MaterialTypeIds=" + encodeURIComponent("" + item) + "&"; });
        if (isFree !== undefined)
            url_ += "IsFree=" + encodeURIComponent("" + isFree) + "&"; 
        if (isNotFree !== undefined)
            url_ += "IsNotFree=" + encodeURIComponent("" + isNotFree) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processByToken(_response);
        });
    }

    protected processByToken(response: Response): Promise<UserSideLearningHistoryResponseModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <UserSideLearningHistoryResponseModel>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserSideLearningHistoryResponseModel>(<any>null);
    }

    /**
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @param keyword (optional) 
     * @param programTypeIds (optional) 
     * @param learningTypeIds (optional) 
     * @param materialTypeIds (optional) 
     * @param isFree (optional) 
     * @param isNotFree (optional) 
     * @return Success
     */
    complete(employeeId: string, pageIndex: number | null | undefined, pageSize: number | null | undefined, keyword: string | null | undefined, programTypeIds: number[] | null | undefined, learningTypeIds: number[] | null | undefined, materialTypeIds: number[] | null | undefined, isFree: boolean | null | undefined, isNotFree: boolean | null | undefined): Promise<UserSideLearningHistoryResponseModel> {
        let url_ = this.baseUrl + "/api/v1/userside-learning-history/complete/{employeeId}?";
        if (employeeId === undefined || employeeId === null)
            throw new Error("The parameter 'employeeId' must be defined.");
        url_ = url_.replace("{employeeId}", encodeURIComponent("" + employeeId)); 
        if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&"; 
        if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&"; 
        if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&"; 
        if (programTypeIds !== undefined)
            programTypeIds && programTypeIds.forEach(item => { url_ += "ProgramTypeIds=" + encodeURIComponent("" + item) + "&"; });
        if (learningTypeIds !== undefined)
            learningTypeIds && learningTypeIds.forEach(item => { url_ += "LearningTypeIds=" + encodeURIComponent("" + item) + "&"; });
        if (materialTypeIds !== undefined)
            materialTypeIds && materialTypeIds.forEach(item => { url_ += "MaterialTypeIds=" + encodeURIComponent("" + item) + "&"; });
        if (isFree !== undefined)
            url_ += "IsFree=" + encodeURIComponent("" + isFree) + "&"; 
        if (isNotFree !== undefined)
            url_ += "IsNotFree=" + encodeURIComponent("" + isNotFree) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processComplete(_response);
        });
    }

    protected processComplete(response: Response): Promise<UserSideLearningHistoryResponseModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <UserSideLearningHistoryResponseModel>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserSideLearningHistoryResponseModel>(<any>null);
    }

    /**
     * @return Success
     */
    detail(employeeId: string, learningHistoryId: number): Promise<UserSideDetailLearningHistoryModel> {
        let url_ = this.baseUrl + "/api/v1/userside-learning-history/detail/{employeeId}/{learningHistoryId}";
        if (employeeId === undefined || employeeId === null)
            throw new Error("The parameter 'employeeId' must be defined.");
        url_ = url_.replace("{employeeId}", encodeURIComponent("" + employeeId)); 
        if (learningHistoryId === undefined || learningHistoryId === null)
            throw new Error("The parameter 'learningHistoryId' must be defined.");
        url_ = url_.replace("{learningHistoryId}", encodeURIComponent("" + learningHistoryId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDetail(_response);
        });
    }

    protected processDetail(response: Response): Promise<UserSideDetailLearningHistoryModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <UserSideDetailLearningHistoryModel>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserSideDetailLearningHistoryModel>(<any>null);
    }

    /**
     * @return Success
     */
    detailByToken(learningHistoryId: number): Promise<UserSideDetailLearningHistoryModel> {
        let url_ = this.baseUrl + "/api/v1/userside-learning-history/detail-by-token/{learningHistoryId}";
        if (learningHistoryId === undefined || learningHistoryId === null)
            throw new Error("The parameter 'learningHistoryId' must be defined.");
        url_ = url_.replace("{learningHistoryId}", encodeURIComponent("" + learningHistoryId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDetailByToken(_response);
        });
    }

    protected processDetailByToken(response: Response): Promise<UserSideDetailLearningHistoryModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <UserSideDetailLearningHistoryModel>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserSideDetailLearningHistoryModel>(<any>null);
    }

    /**
     * @return Success
     */
    filterValue(): Promise<UserSideLearningHistoryFilterValueModel> {
        let url_ = this.baseUrl + "/api/v1/userside-learning-history/filter-value";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFilterValue(_response);
        });
    }

    protected processFilterValue(response: Response): Promise<UserSideLearningHistoryFilterValueModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <UserSideLearningHistoryFilterValueModel>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserSideLearningHistoryFilterValueModel>(<any>null);
    }
}

export class CompleteService {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @param keyword (optional) 
     * @param programTypeIds (optional) 
     * @param learningTypeIds (optional) 
     * @param materialTypeIds (optional) 
     * @param isFree (optional) 
     * @param isNotFree (optional) 
     * @return Success
     */
    byToken(pageIndex: number | null | undefined, pageSize: number | null | undefined, keyword: string | null | undefined, programTypeIds: number[] | null | undefined, learningTypeIds: number[] | null | undefined, materialTypeIds: number[] | null | undefined, isFree: boolean | null | undefined, isNotFree: boolean | null | undefined): Promise<UserSideLearningHistoryResponseModel> {
        let url_ = this.baseUrl + "/api/v1/userside-learning-history/complete/by-token?";
        if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&"; 
        if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&"; 
        if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&"; 
        if (programTypeIds !== undefined)
            programTypeIds && programTypeIds.forEach(item => { url_ += "ProgramTypeIds=" + encodeURIComponent("" + item) + "&"; });
        if (learningTypeIds !== undefined)
            learningTypeIds && learningTypeIds.forEach(item => { url_ += "LearningTypeIds=" + encodeURIComponent("" + item) + "&"; });
        if (materialTypeIds !== undefined)
            materialTypeIds && materialTypeIds.forEach(item => { url_ += "MaterialTypeIds=" + encodeURIComponent("" + item) + "&"; });
        if (isFree !== undefined)
            url_ += "IsFree=" + encodeURIComponent("" + isFree) + "&"; 
        if (isNotFree !== undefined)
            url_ += "IsNotFree=" + encodeURIComponent("" + isNotFree) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processByToken(_response);
        });
    }

    protected processByToken(response: Response): Promise<UserSideLearningHistoryResponseModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <UserSideLearningHistoryResponseModel>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserSideLearningHistoryResponseModel>(<any>null);
    }
}

export class UsersideLevelService {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getNextLevel(): Promise<void> {
        let url_ = this.baseUrl + "/api/v1/userside-level/get-next-level";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetNextLevel(_response);
        });
    }

    protected processGetNextLevel(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }
}

export class UsersideLoginService {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getUserInfo(): Promise<UserSideLoginReturnModel> {
        let url_ = this.baseUrl + "/api/v1/userside-login/get-user-info";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetUserInfo(_response);
        });
    }

    protected processGetUserInfo(response: Response): Promise<UserSideLoginReturnModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <UserSideLoginReturnModel>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserSideLoginReturnModel>(<any>null);
    }
}

export class MyEventService {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param page (optional) 
     * @param itemSize (optional) 
     * @param name (optional) 
     * @return Success
     */
    getMainPage(page: number | null | undefined, itemSize: number | null | undefined, name: string | null | undefined): Promise<MainPageModel> {
        let url_ = this.baseUrl + "/api/v1/mobile/my-event/get-main-page?";
        if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&"; 
        if (itemSize !== undefined)
            url_ += "ItemSize=" + encodeURIComponent("" + itemSize) + "&"; 
        if (name !== undefined)
            url_ += "Name=" + encodeURIComponent("" + name) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetMainPage(_response);
        });
    }

    protected processGetMainPage(response: Response): Promise<MainPageModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <MainPageModel>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<MainPageModel>(<any>null);
    }

    /**
     * @param page (optional) 
     * @param itemSize (optional) 
     * @param name (optional) 
     * @return Success
     */
    getSave(page: number | null | undefined, itemSize: number | null | undefined, name: string | null | undefined): Promise<SingleViewEventModel[]> {
        let url_ = this.baseUrl + "/api/v1/mobile/my-event/get-save?";
        if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&"; 
        if (itemSize !== undefined)
            url_ += "ItemSize=" + encodeURIComponent("" + itemSize) + "&"; 
        if (name !== undefined)
            url_ += "Name=" + encodeURIComponent("" + name) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetSave(_response);
        });
    }

    protected processGetSave(response: Response): Promise<SingleViewEventModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <SingleViewEventModel[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SingleViewEventModel[]>(<any>null);
    }

    /**
     * @param page (optional) 
     * @param itemSize (optional) 
     * @param name (optional) 
     * @return Success
     */
    getPopular(page: number | null | undefined, itemSize: number | null | undefined, name: string | null | undefined): Promise<SingleViewEventModel[]> {
        let url_ = this.baseUrl + "/api/v1/mobile/my-event/get-popular?";
        if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&"; 
        if (itemSize !== undefined)
            url_ += "ItemSize=" + encodeURIComponent("" + itemSize) + "&"; 
        if (name !== undefined)
            url_ += "Name=" + encodeURIComponent("" + name) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetPopular(_response);
        });
    }

    protected processGetPopular(response: Response): Promise<SingleViewEventModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <SingleViewEventModel[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SingleViewEventModel[]>(<any>null);
    }

    /**
     * @param page (optional) 
     * @param itemSize (optional) 
     * @param name (optional) 
     * @return Success
     */
    getRecomend(page: number | null | undefined, itemSize: number | null | undefined, name: string | null | undefined): Promise<SingleViewEventModel[]> {
        let url_ = this.baseUrl + "/api/v1/mobile/my-event/get-recomend?";
        if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&"; 
        if (itemSize !== undefined)
            url_ += "ItemSize=" + encodeURIComponent("" + itemSize) + "&"; 
        if (name !== undefined)
            url_ += "Name=" + encodeURIComponent("" + name) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetRecomend(_response);
        });
    }

    protected processGetRecomend(response: Response): Promise<SingleViewEventModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <SingleViewEventModel[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SingleViewEventModel[]>(<any>null);
    }

    /**
     * @return Success
     */
    eventForm(id: number): Promise<MyEventFormModel> {
        let url_ = this.baseUrl + "/api/v1/mobile/my-event/event-form/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processEventForm(_response);
        });
    }

    protected processEventForm(response: Response): Promise<MyEventFormModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <MyEventFormModel>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<MyEventFormModel>(<any>null);
    }

    /**
     * @return Success
     */
    detailView(id: number): Promise<SingleViewEventModel> {
        let url_ = this.baseUrl + "/api/v1/mobile/my-event/detail-view/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDetailView(_response);
        });
    }

    protected processDetailView(response: Response): Promise<SingleViewEventModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <SingleViewEventModel>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SingleViewEventModel>(<any>null);
    }

    /**
     * @param page (optional) 
     * @param itemSize (optional) 
     * @param name (optional) 
     * @return Success
     */
    getOutletList(page: number | null | undefined, itemSize: number | null | undefined, name: string | null | undefined): Promise<DropDownStringModel[]> {
        let url_ = this.baseUrl + "/api/v1/mobile/my-event/get-outlet-list?";
        if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&"; 
        if (itemSize !== undefined)
            url_ += "ItemSize=" + encodeURIComponent("" + itemSize) + "&"; 
        if (name !== undefined)
            url_ += "Name=" + encodeURIComponent("" + name) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetOutletList(_response);
        });
    }

    protected processGetOutletList(response: Response): Promise<DropDownStringModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <DropDownStringModel[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DropDownStringModel[]>(<any>null);
    }

    /**
     * @return Success
     */
    getEventCategoryList(): Promise<DropDownModel[]> {
        let url_ = this.baseUrl + "/api/v1/mobile/my-event/get-event-category-list";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetEventCategoryList(_response);
        });
    }

    protected processGetEventCategoryList(response: Response): Promise<DropDownModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <DropDownModel[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DropDownModel[]>(<any>null);
    }

    /**
     * @param page (optional) 
     * @param itemSize (optional) 
     * @param name (optional) 
     * @return Success
     */
    inviteFriendEvent(page: number | null | undefined, itemSize: number | null | undefined, name: string | null | undefined, id: number): Promise<DropdownWithImage[]> {
        let url_ = this.baseUrl + "/api/v1/mobile/my-event/invite-friend-event/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&"; 
        if (itemSize !== undefined)
            url_ += "ItemSize=" + encodeURIComponent("" + itemSize) + "&"; 
        if (name !== undefined)
            url_ += "Name=" + encodeURIComponent("" + name) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processInviteFriendEvent(_response);
        });
    }

    protected processInviteFriendEvent(response: Response): Promise<DropdownWithImage[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <DropdownWithImage[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DropdownWithImage[]>(<any>null);
    }

    /**
     * @param model (optional) 
     * @return Success
     */
    insert(model: MyEventFormModel | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/v1/mobile/my-event/insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processInsert(_response);
        });
    }

    protected processInsert(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param model (optional) 
     * @return Success
     */
    changeAttadence(model: EventAttendModel | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/v1/mobile/my-event/change-attadence";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processChangeAttadence(_response);
        });
    }

    protected processChangeAttadence(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param employeeList (optional) 
     * @return Success
     */
    joinInvitedEmployee(id: number, employeeList: string[] | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/v1/mobile/my-event/join-invited-employee/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(employeeList);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processJoinInvitedEmployee(_response);
        });
    }

    protected processJoinInvitedEmployee(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }
}

export class UsersideMyguideService {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllGuide(): Promise<UserSideMyGuideAPIModel> {
        let url_ = this.baseUrl + "/api/v1/userside-myguide/get-all-guide";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllGuide(_response);
        });
    }

    protected processGetAllGuide(response: Response): Promise<UserSideMyGuideAPIModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <UserSideMyGuideAPIModel>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserSideMyGuideAPIModel>(<any>null);
    }

    /**
     * @return Success
     */
    getTutorialGuide(): Promise<UserSideTutorialGuideModel> {
        let url_ = this.baseUrl + "/api/v1/userside-myguide/get-tutorial-guide";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetTutorialGuide(_response);
        });
    }

    protected processGetTutorialGuide(response: Response): Promise<UserSideTutorialGuideModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <UserSideTutorialGuideModel>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserSideTutorialGuideModel>(<any>null);
    }
}

export class UsersideMyinsightService {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param json (optional) 
     * @param userPositionId (optional) 
     * @return Success
     */
    getAllSurvey(json: string | null | undefined, userPositionId: number[] | null | undefined): Promise<UserSideMyInsightModel[]> {
        let url_ = this.baseUrl + "/api/v1/userside-myinsight/get-all-survey?";
        if (json !== undefined)
            url_ += "json=" + encodeURIComponent("" + json) + "&"; 
        if (userPositionId !== undefined)
            userPositionId && userPositionId.forEach(item => { url_ += "userPositionId=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllSurvey(_response);
        });
    }

    protected processGetAllSurvey(response: Response): Promise<UserSideMyInsightModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <UserSideMyInsightModel[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserSideMyInsightModel[]>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    userSideGetSurveyById(id: number | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/v1/userside-myinsight/user-side-get-survey-by-id?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUserSideGetSurveyById(_response);
        });
    }

    protected processUserSideGetSurveyById(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param surveyId (optional) 
     * @return Success
     */
    userSideGetSurveyQuestionById(surveyId: number | null | undefined): Promise<number[]> {
        let url_ = this.baseUrl + "/api/v1/userside-myinsight/user-side-get-survey-question-by-id?";
        if (surveyId !== undefined)
            url_ += "surveyId=" + encodeURIComponent("" + surveyId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUserSideGetSurveyQuestionById(_response);
        });
    }

    protected processUserSideGetSurveyQuestionById(response: Response): Promise<number[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <number[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<number[]>(<any>null);
    }
}

export class UsersideMyinsightanswerService {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param insert (optional) 
     * @return Success
     */
    surveyTaskAnswer(insert: SurveyAnswerInsertModel | null | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/v1/userside-myinsightanswer/survey-task-answer";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(insert);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSurveyTaskAnswer(_response);
        });
    }

    protected processSurveyTaskAnswer(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <boolean>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(<any>null);
    }
}

export class UsersideMylearningService {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param trainingId (optional) 
     * @param courseId (optional) 
     * @return Success
     */
    getTrainingById(trainingId: number | null | undefined, courseId: number | null | undefined): Promise<UserSideCourseViewModel> {
        let url_ = this.baseUrl + "/api/v1/userside-mylearning/get-training-by-id?";
        if (trainingId !== undefined)
            url_ += "trainingId=" + encodeURIComponent("" + trainingId) + "&"; 
        if (courseId !== undefined)
            url_ += "courseId=" + encodeURIComponent("" + courseId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetTrainingById(_response);
        });
    }

    protected processGetTrainingById(response: Response): Promise<UserSideCourseViewModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <UserSideCourseViewModel>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserSideCourseViewModel>(<any>null);
    }

    /**
     * @param setupModuleId (optional) 
     * @return Success
     */
    getModuleById(setupModuleId: number | null | undefined): Promise<UserSideModuleViewModel> {
        let url_ = this.baseUrl + "/api/v1/userside-mylearning/get-module-by-id?";
        if (setupModuleId !== undefined)
            url_ += "setupModuleId=" + encodeURIComponent("" + setupModuleId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetModuleById(_response);
        });
    }

    protected processGetModuleById(response: Response): Promise<UserSideModuleViewModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <UserSideModuleViewModel>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserSideModuleViewModel>(<any>null);
    }

    /**
     * @param pageSize (optional) 
     * @param pageIndex (optional) 
     * @return Success
     */
    getAllTrainings(pageSize: number | null | undefined, pageIndex: number | null | undefined): Promise<UserSideMyLearningHomepageCourseModel[]> {
        let url_ = this.baseUrl + "/api/v1/userside-mylearning/get-all-trainings?";
        if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&"; 
        if (pageIndex !== undefined)
            url_ += "pageIndex=" + encodeURIComponent("" + pageIndex) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllTrainings(_response);
        });
    }

    protected processGetAllTrainings(response: Response): Promise<UserSideMyLearningHomepageCourseModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <UserSideMyLearningHomepageCourseModel[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserSideMyLearningHomepageCourseModel[]>(<any>null);
    }

    /**
     * @param pageSize (optional) 
     * @param pageIndex (optional) 
     * @return Success
     */
    getAllPopularTrainings(pageSize: number | null | undefined, pageIndex: number | null | undefined): Promise<UserSideMyLearningHomepageCourseModel[]> {
        let url_ = this.baseUrl + "/api/v1/userside-mylearning/get-all-popular-trainings?";
        if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&"; 
        if (pageIndex !== undefined)
            url_ += "pageIndex=" + encodeURIComponent("" + pageIndex) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllPopularTrainings(_response);
        });
    }

    protected processGetAllPopularTrainings(response: Response): Promise<UserSideMyLearningHomepageCourseModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <UserSideMyLearningHomepageCourseModel[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserSideMyLearningHomepageCourseModel[]>(<any>null);
    }

    /**
     * @param pageSize (optional) 
     * @param pageIndex (optional) 
     * @return Success
     */
    getAllPopQuizBySetupLearningId(pageSize: number | null | undefined, pageIndex: number | null | undefined): Promise<UserSidePopQuizModel[]> {
        let url_ = this.baseUrl + "/api/v1/userside-mylearning/get-all-pop-quiz-by-setup-learning-id?";
        if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&"; 
        if (pageIndex !== undefined)
            url_ += "pageIndex=" + encodeURIComponent("" + pageIndex) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllPopQuizBySetupLearningId(_response);
        });
    }

    protected processGetAllPopQuizBySetupLearningId(response: Response): Promise<UserSidePopQuizModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <UserSidePopQuizModel[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserSidePopQuizModel[]>(<any>null);
    }

    /**
     * @param insert (optional) 
     * @return Success
     */
    insertTaskAnswer(insert: TaskAnswerInsertModel | null | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/v1/userside-mylearning/insert-task-answer";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(insert);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processInsertTaskAnswer(_response);
        });
    }

    protected processInsertTaskAnswer(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <boolean>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(<any>null);
    }

    /**
     * @param pageSize (optional) 
     * @param pageIndex (optional) 
     * @return Success
     */
    getAllRecommendedTrainings(pageSize: number | null | undefined, pageIndex: number | null | undefined): Promise<UserSideMyLearningHomepageCourseModel[]> {
        let url_ = this.baseUrl + "/api/v1/userside-mylearning/get-all-recommended-trainings?";
        if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&"; 
        if (pageIndex !== undefined)
            url_ += "pageIndex=" + encodeURIComponent("" + pageIndex) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllRecommendedTrainings(_response);
        });
    }

    protected processGetAllRecommendedTrainings(response: Response): Promise<UserSideMyLearningHomepageCourseModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <UserSideMyLearningHomepageCourseModel[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserSideMyLearningHomepageCourseModel[]>(<any>null);
    }

    /**
     * @param pageSize (optional) 
     * @param pageIndex (optional) 
     * @return Success
     */
    getAllQueuedTrainings(pageSize: number | null | undefined, pageIndex: number | null | undefined): Promise<UserSideMyLearningHomepageCourseModel[]> {
        let url_ = this.baseUrl + "/api/v1/userside-mylearning/get-all-queued-trainings?";
        if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&"; 
        if (pageIndex !== undefined)
            url_ += "pageIndex=" + encodeURIComponent("" + pageIndex) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllQueuedTrainings(_response);
        });
    }

    protected processGetAllQueuedTrainings(response: Response): Promise<UserSideMyLearningHomepageCourseModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <UserSideMyLearningHomepageCourseModel[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserSideMyLearningHomepageCourseModel[]>(<any>null);
    }

    /**
     * @param pageSize (optional) 
     * @param pageIndex (optional) 
     * @return Success
     */
    getAllContinuedTrainings(pageSize: number | null | undefined, pageIndex: number | null | undefined): Promise<UserSideMyLearningHomepageCourseModel[]> {
        let url_ = this.baseUrl + "/api/v1/userside-mylearning/get-all-continued-trainings?";
        if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&"; 
        if (pageIndex !== undefined)
            url_ += "pageIndex=" + encodeURIComponent("" + pageIndex) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllContinuedTrainings(_response);
        });
    }

    protected processGetAllContinuedTrainings(response: Response): Promise<UserSideMyLearningHomepageCourseModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <UserSideMyLearningHomepageCourseModel[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserSideMyLearningHomepageCourseModel[]>(<any>null);
    }

    /**
     * @param pageSize (optional) 
     * @param pageIndex (optional) 
     * @return Success
     */
    getAllCompletedTrainings(pageSize: number | null | undefined, pageIndex: number | null | undefined): Promise<UserSideMyLearningHomepageCourseModel[]> {
        let url_ = this.baseUrl + "/api/v1/userside-mylearning/get-all-completed-trainings?";
        if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&"; 
        if (pageIndex !== undefined)
            url_ += "pageIndex=" + encodeURIComponent("" + pageIndex) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllCompletedTrainings(_response);
        });
    }

    protected processGetAllCompletedTrainings(response: Response): Promise<UserSideMyLearningHomepageCourseModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <UserSideMyLearningHomepageCourseModel[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserSideMyLearningHomepageCourseModel[]>(<any>null);
    }

    /**
     * @param pageSize (optional) 
     * @param pageIndex (optional) 
     * @return Success
     */
    getAllPopularModules(pageSize: number | null | undefined, pageIndex: number | null | undefined): Promise<UserSideMyLearningHomepageModuleModel[]> {
        let url_ = this.baseUrl + "/api/v1/userside-mylearning/get-all-popular-modules?";
        if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&"; 
        if (pageIndex !== undefined)
            url_ += "pageIndex=" + encodeURIComponent("" + pageIndex) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllPopularModules(_response);
        });
    }

    protected processGetAllPopularModules(response: Response): Promise<UserSideMyLearningHomepageModuleModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <UserSideMyLearningHomepageModuleModel[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserSideMyLearningHomepageModuleModel[]>(<any>null);
    }

    /**
     * @param pageSize (optional) 
     * @param pageIndex (optional) 
     * @return Success
     */
    getAllRecommendedModules(pageSize: number | null | undefined, pageIndex: number | null | undefined): Promise<UserSideMyLearningHomepageModuleModel[]> {
        let url_ = this.baseUrl + "/api/v1/userside-mylearning/get-all-recommended-modules?";
        if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&"; 
        if (pageIndex !== undefined)
            url_ += "pageIndex=" + encodeURIComponent("" + pageIndex) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllRecommendedModules(_response);
        });
    }

    protected processGetAllRecommendedModules(response: Response): Promise<UserSideMyLearningHomepageModuleModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <UserSideMyLearningHomepageModuleModel[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserSideMyLearningHomepageModuleModel[]>(<any>null);
    }

    /**
     * @param pageSize (optional) 
     * @param pageIndex (optional) 
     * @return Success
     */
    getAllQueuedModules(pageSize: number | null | undefined, pageIndex: number | null | undefined): Promise<UserSideMyLearningHomepageModuleModel[]> {
        let url_ = this.baseUrl + "/api/v1/userside-mylearning/get-all-queued-modules?";
        if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&"; 
        if (pageIndex !== undefined)
            url_ += "pageIndex=" + encodeURIComponent("" + pageIndex) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllQueuedModules(_response);
        });
    }

    protected processGetAllQueuedModules(response: Response): Promise<UserSideMyLearningHomepageModuleModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <UserSideMyLearningHomepageModuleModel[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserSideMyLearningHomepageModuleModel[]>(<any>null);
    }

    /**
     * @param pageSize (optional) 
     * @param pageIndex (optional) 
     * @return Success
     */
    getAllContinuedModules(pageSize: number | null | undefined, pageIndex: number | null | undefined): Promise<UserSideMyLearningHomepageModuleModel[]> {
        let url_ = this.baseUrl + "/api/v1/userside-mylearning/get-all-continued-modules?";
        if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&"; 
        if (pageIndex !== undefined)
            url_ += "pageIndex=" + encodeURIComponent("" + pageIndex) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllContinuedModules(_response);
        });
    }

    protected processGetAllContinuedModules(response: Response): Promise<UserSideMyLearningHomepageModuleModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <UserSideMyLearningHomepageModuleModel[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserSideMyLearningHomepageModuleModel[]>(<any>null);
    }

    /**
     * @param pageSize (optional) 
     * @param pageIndex (optional) 
     * @return Success
     */
    getAllCompletedModules(pageSize: number | null | undefined, pageIndex: number | null | undefined): Promise<UserSideMyLearningHomepageModuleModel[]> {
        let url_ = this.baseUrl + "/api/v1/userside-mylearning/get-all-completed-modules?";
        if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&"; 
        if (pageIndex !== undefined)
            url_ += "pageIndex=" + encodeURIComponent("" + pageIndex) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllCompletedModules(_response);
        });
    }

    protected processGetAllCompletedModules(response: Response): Promise<UserSideMyLearningHomepageModuleModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <UserSideMyLearningHomepageModuleModel[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserSideMyLearningHomepageModuleModel[]>(<any>null);
    }

    /**
     * @param pageSize (optional) 
     * @param pageIndex (optional) 
     * @return Success
     */
    getAllQueuedBadges(pageSize: number | null | undefined, pageIndex: number | null | undefined): Promise<UserSideMyLearningHomepageCourseBadgeModelNew[]> {
        let url_ = this.baseUrl + "/api/v1/userside-mylearning/get-all-queued-badges?";
        if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&"; 
        if (pageIndex !== undefined)
            url_ += "pageIndex=" + encodeURIComponent("" + pageIndex) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllQueuedBadges(_response);
        });
    }

    protected processGetAllQueuedBadges(response: Response): Promise<UserSideMyLearningHomepageCourseBadgeModelNew[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <UserSideMyLearningHomepageCourseBadgeModelNew[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserSideMyLearningHomepageCourseBadgeModelNew[]>(<any>null);
    }

    /**
     * @param pageSize (optional) 
     * @param pageIndex (optional) 
     * @return Success
     */
    getAllContinuedBadges(pageSize: number | null | undefined, pageIndex: number | null | undefined): Promise<UserSideMyLearningHomepageCourseBadgeModelNew[]> {
        let url_ = this.baseUrl + "/api/v1/userside-mylearning/get-all-continued-badges?";
        if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&"; 
        if (pageIndex !== undefined)
            url_ += "pageIndex=" + encodeURIComponent("" + pageIndex) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllContinuedBadges(_response);
        });
    }

    protected processGetAllContinuedBadges(response: Response): Promise<UserSideMyLearningHomepageCourseBadgeModelNew[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <UserSideMyLearningHomepageCourseBadgeModelNew[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserSideMyLearningHomepageCourseBadgeModelNew[]>(<any>null);
    }

    /**
     * @param pageSize (optional) 
     * @param pageIndex (optional) 
     * @return Success
     */
    getAllCompletedBadges(pageSize: number | null | undefined, pageIndex: number | null | undefined): Promise<UserSideMyLearningHomepageCourseBadgeModelNew[]> {
        let url_ = this.baseUrl + "/api/v1/userside-mylearning/get-all-completed-badges?";
        if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&"; 
        if (pageIndex !== undefined)
            url_ += "pageIndex=" + encodeURIComponent("" + pageIndex) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllCompletedBadges(_response);
        });
    }

    protected processGetAllCompletedBadges(response: Response): Promise<UserSideMyLearningHomepageCourseBadgeModelNew[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <UserSideMyLearningHomepageCourseBadgeModelNew[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserSideMyLearningHomepageCourseBadgeModelNew[]>(<any>null);
    }

    /**
     * @param courseId (optional) 
     * @return Success
     */
    getCourseOverview(courseId: number | null | undefined): Promise<UserSideCourseOverviewModel> {
        let url_ = this.baseUrl + "/api/v1/userside-mylearning/get-course-overview?";
        if (courseId !== undefined)
            url_ += "courseId=" + encodeURIComponent("" + courseId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetCourseOverview(_response);
        });
    }

    protected processGetCourseOverview(response: Response): Promise<UserSideCourseOverviewModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <UserSideCourseOverviewModel>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserSideCourseOverviewModel>(<any>null);
    }

    /**
     * @param courseId (optional) 
     * @return Success
     */
    getCourseTrainingScheme(courseId: number | null | undefined): Promise<UserSideCourseTrainingViewModel> {
        let url_ = this.baseUrl + "/api/v1/userside-mylearning/get-course-training-scheme?";
        if (courseId !== undefined)
            url_ += "courseId=" + encodeURIComponent("" + courseId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetCourseTrainingScheme(_response);
        });
    }

    protected processGetCourseTrainingScheme(response: Response): Promise<UserSideCourseTrainingViewModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <UserSideCourseTrainingViewModel>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserSideCourseTrainingViewModel>(<any>null);
    }

    /**
     * @param trainingId (optional) 
     * @return Success
     */
    getCourseCoach(trainingId: number | null | undefined): Promise<UserSideCourseCoachViewModel> {
        let url_ = this.baseUrl + "/api/v1/userside-mylearning/get-course-coach?";
        if (trainingId !== undefined)
            url_ += "trainingId=" + encodeURIComponent("" + trainingId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetCourseCoach(_response);
        });
    }

    protected processGetCourseCoach(response: Response): Promise<UserSideCourseCoachViewModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <UserSideCourseCoachViewModel>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserSideCourseCoachViewModel>(<any>null);
    }

    /**
     * @param trainingId (optional) 
     * @param pageSize (optional) 
     * @param pageIndex (optional) 
     * @return Success
     */
    getPeopleWhoLikeTheCourseList(trainingId: number | null | undefined, pageSize: number | null | undefined, pageIndex: number | null | undefined): Promise<UserSideCourseLikePeopleListModel> {
        let url_ = this.baseUrl + "/api/v1/userside-mylearning/get-people-who-like-the-course-list?";
        if (trainingId !== undefined)
            url_ += "trainingId=" + encodeURIComponent("" + trainingId) + "&"; 
        if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&"; 
        if (pageIndex !== undefined)
            url_ += "pageIndex=" + encodeURIComponent("" + pageIndex) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetPeopleWhoLikeTheCourseList(_response);
        });
    }

    protected processGetPeopleWhoLikeTheCourseList(response: Response): Promise<UserSideCourseLikePeopleListModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <UserSideCourseLikePeopleListModel>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserSideCourseLikePeopleListModel>(<any>null);
    }

    /**
     * @param trainingId (optional) 
     * @return Success
     */
    getPeopleWhoLikeTheCourseSampleImage(trainingId: number | null | undefined): Promise<UserSideCourseLikePeopleSampleImage> {
        let url_ = this.baseUrl + "/api/v1/userside-mylearning/get-people-who-like-the-course-sample-image?";
        if (trainingId !== undefined)
            url_ += "trainingId=" + encodeURIComponent("" + trainingId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetPeopleWhoLikeTheCourseSampleImage(_response);
        });
    }

    protected processGetPeopleWhoLikeTheCourseSampleImage(response: Response): Promise<UserSideCourseLikePeopleSampleImage> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <UserSideCourseLikePeopleSampleImage>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserSideCourseLikePeopleSampleImage>(<any>null);
    }

    /**
     * @param trainingId (optional) 
     * @return Success
     */
    getPeopleWhoLikeTheCourseCount(trainingId: number | null | undefined): Promise<number> {
        let url_ = this.baseUrl + "/api/v1/userside-mylearning/get-people-who-like-the-course-count?";
        if (trainingId !== undefined)
            url_ += "trainingId=" + encodeURIComponent("" + trainingId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetPeopleWhoLikeTheCourseCount(_response);
        });
    }

    protected processGetPeopleWhoLikeTheCourseCount(response: Response): Promise<number> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <number>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<number>(<any>null);
    }

    /**
     * @param trainingId (optional) 
     * @return Success
     */
    getPeopleWhoTookTheCourseSampleImage(trainingId: number | null | undefined): Promise<UserSideWhoTookTheCourseSampleImage> {
        let url_ = this.baseUrl + "/api/v1/userside-mylearning/get-people-who-took-the-course-sample-image?";
        if (trainingId !== undefined)
            url_ += "trainingId=" + encodeURIComponent("" + trainingId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetPeopleWhoTookTheCourseSampleImage(_response);
        });
    }

    protected processGetPeopleWhoTookTheCourseSampleImage(response: Response): Promise<UserSideWhoTookTheCourseSampleImage> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <UserSideWhoTookTheCourseSampleImage>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserSideWhoTookTheCourseSampleImage>(<any>null);
    }

    /**
     * @param trainingId (optional) 
     * @param pageSize (optional) 
     * @param pageIndex (optional) 
     * @return Success
     */
    getPeopleWhoTookTheCourseList(trainingId: number | null | undefined, pageSize: number | null | undefined, pageIndex: number | null | undefined): Promise<UserSidePeopleWhoTookTheCourseListModel> {
        let url_ = this.baseUrl + "/api/v1/userside-mylearning/get-people-who-took-the-course-list?";
        if (trainingId !== undefined)
            url_ += "trainingId=" + encodeURIComponent("" + trainingId) + "&"; 
        if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&"; 
        if (pageIndex !== undefined)
            url_ += "pageIndex=" + encodeURIComponent("" + pageIndex) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetPeopleWhoTookTheCourseList(_response);
        });
    }

    protected processGetPeopleWhoTookTheCourseList(response: Response): Promise<UserSidePeopleWhoTookTheCourseListModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <UserSidePeopleWhoTookTheCourseListModel>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserSidePeopleWhoTookTheCourseListModel>(<any>null);
    }

    /**
     * @param trainingId (optional) 
     * @return Success
     */
    getPeoleWhoTookTheCourseCount(trainingId: number | null | undefined): Promise<number> {
        let url_ = this.baseUrl + "/api/v1/userside-mylearning/get-peole-who-took-the-course-count?";
        if (trainingId !== undefined)
            url_ += "trainingId=" + encodeURIComponent("" + trainingId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetPeoleWhoTookTheCourseCount(_response);
        });
    }

    protected processGetPeoleWhoTookTheCourseCount(response: Response): Promise<number> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <number>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<number>(<any>null);
    }

    /**
     * @param trainingId (optional) 
     * @param setupModuleId (optional) 
     * @return Success
     */
    getModuleContent(trainingId: number | null | undefined, setupModuleId: number | null | undefined): Promise<ModuleContentViewModel> {
        let url_ = this.baseUrl + "/api/v1/userside-mylearning/get-module-content?";
        if (trainingId !== undefined)
            url_ += "trainingId=" + encodeURIComponent("" + trainingId) + "&"; 
        if (setupModuleId !== undefined)
            url_ += "setupModuleId=" + encodeURIComponent("" + setupModuleId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetModuleContent(_response);
        });
    }

    protected processGetModuleContent(response: Response): Promise<ModuleContentViewModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ModuleContentViewModel>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ModuleContentViewModel>(<any>null);
    }

    /**
     * @param trainingId (optional) 
     * @return Success
     */
    getModuleReview(trainingId: number | null | undefined): Promise<CourseReviewViewModel> {
        let url_ = this.baseUrl + "/api/v1/userside-mylearning/get-module-review?";
        if (trainingId !== undefined)
            url_ += "trainingId=" + encodeURIComponent("" + trainingId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetModuleReview(_response);
        });
    }

    protected processGetModuleReview(response: Response): Promise<CourseReviewViewModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <CourseReviewViewModel>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CourseReviewViewModel>(<any>null);
    }

    /**
     * @param model (optional) 
     * @return Success
     */
    postMemberAssignTraining(model: TeamMemberAssignModel | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/v1/userside-mylearning/post-member-assign-training";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPostMemberAssignTraining(_response);
        });
    }

    protected processPostMemberAssignTraining(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param model (optional) 
     * @return Success
     */
    postMemberAssignModule(model: TeamMemberAssignModel | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/v1/userside-mylearning/post-member-assign-module";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPostMemberAssignModule(_response);
        });
    }

    protected processPostMemberAssignModule(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param trainingId (optional) 
     * @param employeeName (optional) 
     * @param sortBy (optional) 
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    getMemberFilter(trainingId: number | null | undefined, employeeName: string | null | undefined, sortBy: string | null | undefined, pageIndex: number | null | undefined, pageSize: number | null | undefined): Promise<TeamMemberDetail> {
        let url_ = this.baseUrl + "/api/v1/userside-mylearning/get-member-filter?";
        if (trainingId !== undefined)
            url_ += "TrainingId=" + encodeURIComponent("" + trainingId) + "&"; 
        if (employeeName !== undefined)
            url_ += "EmployeeName=" + encodeURIComponent("" + employeeName) + "&"; 
        if (sortBy !== undefined)
            url_ += "SortBy=" + encodeURIComponent("" + sortBy) + "&"; 
        if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&"; 
        if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetMemberFilter(_response);
        });
    }

    protected processGetMemberFilter(response: Response): Promise<TeamMemberDetail> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <TeamMemberDetail>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TeamMemberDetail>(<any>null);
    }

    /**
     * @param moduleId (optional) 
     * @param setupModuleId (optional) 
     * @param trainingId (optional) 
     * @return Success
     */
    getTrainingModule(moduleId: number | null | undefined, setupModuleId: number | null | undefined, trainingId: number | null | undefined): Promise<GetModule> {
        let url_ = this.baseUrl + "/api/v1/userside-mylearning/get-training-module?";
        if (moduleId !== undefined)
            url_ += "moduleId=" + encodeURIComponent("" + moduleId) + "&"; 
        if (setupModuleId !== undefined)
            url_ += "setupModuleId=" + encodeURIComponent("" + setupModuleId) + "&"; 
        if (trainingId !== undefined)
            url_ += "trainingId=" + encodeURIComponent("" + trainingId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetTrainingModule(_response);
        });
    }

    protected processGetTrainingModule(response: Response): Promise<GetModule> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <GetModule>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GetModule>(<any>null);
    }

    /**
     * @param trainingId (optional) 
     * @return Success
     */
    postEnrollTraining(trainingId: number | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/v1/userside-mylearning/post-enroll-training?";
        if (trainingId !== undefined)
            url_ += "TrainingId=" + encodeURIComponent("" + trainingId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPostEnrollTraining(_response);
        });
    }

    protected processPostEnrollTraining(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param setupModuleId (optional) 
     * @return Success
     */
    postEnrollModule(setupModuleId: number | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/v1/userside-mylearning/post-enroll-module?";
        if (setupModuleId !== undefined)
            url_ += "setupModuleId=" + encodeURIComponent("" + setupModuleId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPostEnrollModule(_response);
        });
    }

    protected processPostEnrollModule(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param trainingId (optional) 
     * @return Success
     */
    postAddToQueueTraining(trainingId: number | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/v1/userside-mylearning/post-add-to-queue-training?";
        if (trainingId !== undefined)
            url_ += "TrainingId=" + encodeURIComponent("" + trainingId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPostAddToQueueTraining(_response);
        });
    }

    protected processPostAddToQueueTraining(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param trainingId (optional) 
     * @return Success
     */
    postUnqueueTraining(trainingId: number | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/v1/userside-mylearning/post-unqueue-training?";
        if (trainingId !== undefined)
            url_ += "TrainingId=" + encodeURIComponent("" + trainingId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPostUnqueueTraining(_response);
        });
    }

    protected processPostUnqueueTraining(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param trainingId (optional) 
     * @return Success
     */
    updateQueueToEnrollTraining(trainingId: number | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/v1/userside-mylearning/update-queue-to-enroll-training?";
        if (trainingId !== undefined)
            url_ += "TrainingId=" + encodeURIComponent("" + trainingId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateQueueToEnrollTraining(_response);
        });
    }

    protected processUpdateQueueToEnrollTraining(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param model (optional) 
     * @return Success
     */
    startTrainingModule(model: CheckModuleStartModel | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/v1/userside-mylearning/start-training-module";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processStartTrainingModule(_response);
        });
    }

    protected processStartTrainingModule(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param trainingId (optional) 
     * @param setupModuleId (optional) 
     * @return Success
     */
    getIspassById(trainingId: number | null | undefined, setupModuleId: number | null | undefined): Promise<UserSideIsLearningPassModel> {
        let url_ = this.baseUrl + "/api/v1/userside-mylearning/get-ispass-by-id?";
        if (trainingId !== undefined)
            url_ += "TrainingId=" + encodeURIComponent("" + trainingId) + "&"; 
        if (setupModuleId !== undefined)
            url_ += "SetupModuleId=" + encodeURIComponent("" + setupModuleId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetIspassById(_response);
        });
    }

    protected processGetIspassById(response: Response): Promise<UserSideIsLearningPassModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <UserSideIsLearningPassModel>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserSideIsLearningPassModel>(<any>null);
    }

    /**
     * @param trainingId (optional) 
     * @return Success
     */
    getScoreModuleListById(trainingId: number | null | undefined): Promise<ModuleScoreModel[]> {
        let url_ = this.baseUrl + "/api/v1/userside-mylearning/get-score-Module-list-by-id?";
        if (trainingId !== undefined)
            url_ += "trainingId=" + encodeURIComponent("" + trainingId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetScoreModuleListById(_response);
        });
    }

    protected processGetScoreModuleListById(response: Response): Promise<ModuleScoreModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ModuleScoreModel[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ModuleScoreModel[]>(<any>null);
    }
}

export class UsersidePointRewardService {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    point(): Promise<UserSideMyPointModel> {
        let url_ = this.baseUrl + "/api/v1/userside-point-reward/point";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPoint(_response);
        });
    }

    protected processPoint(response: Response): Promise<UserSideMyPointModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <UserSideMyPointModel>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserSideMyPointModel>(<any>null);
    }

    /**
     * @return Success
     */
    historyPoints(): Promise<UserSideHistoryPointModel> {
        let url_ = this.baseUrl + "/api/v1/userside-point-reward/history-points";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processHistoryPoints(_response);
        });
    }

    protected processHistoryPoints(response: Response): Promise<UserSideHistoryPointModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <UserSideHistoryPointModel>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserSideHistoryPointModel>(<any>null);
    }

    /**
     * @param sortBy (optional) 
     * @param name (optional) 
     * @param typeId (optional) 
     * @param isUseTeachingPoint (optional) 
     * @param itemPerPage (optional) 
     * @param pageIndex (optional) 
     * @return Success
     */
    rewards(sortBy: string | null | undefined, name: string | null | undefined, typeId: number | null | undefined, isUseTeachingPoint: boolean | null | undefined, itemPerPage: number | null | undefined, pageIndex: number | null | undefined): Promise<UserSideRewardModel[]> {
        let url_ = this.baseUrl + "/api/v1/userside-point-reward/rewards?";
        if (sortBy !== undefined)
            url_ += "SortBy=" + encodeURIComponent("" + sortBy) + "&"; 
        if (name !== undefined)
            url_ += "Name=" + encodeURIComponent("" + name) + "&"; 
        if (typeId !== undefined)
            url_ += "TypeId=" + encodeURIComponent("" + typeId) + "&"; 
        if (isUseTeachingPoint !== undefined)
            url_ += "IsUseTeachingPoint=" + encodeURIComponent("" + isUseTeachingPoint) + "&"; 
        if (itemPerPage !== undefined)
            url_ += "ItemPerPage=" + encodeURIComponent("" + itemPerPage) + "&"; 
        if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRewards(_response);
        });
    }

    protected processRewards(response: Response): Promise<UserSideRewardModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <UserSideRewardModel[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserSideRewardModel[]>(<any>null);
    }

    /**
     * @return Success
     */
    detailReward(rewardId: number): Promise<UserSideRewardModel> {
        let url_ = this.baseUrl + "/api/v1/userside-point-reward/detail-reward/{rewardId}";
        if (rewardId === undefined || rewardId === null)
            throw new Error("The parameter 'rewardId' must be defined.");
        url_ = url_.replace("{rewardId}", encodeURIComponent("" + rewardId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDetailReward(_response);
        });
    }

    protected processDetailReward(response: Response): Promise<UserSideRewardModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <UserSideRewardModel>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserSideRewardModel>(<any>null);
    }

    /**
     * @return Success
     */
    redeemReward(rewardId: number): Promise<UserSideMyPointModel> {
        let url_ = this.baseUrl + "/api/v1/userside-point-reward/redeem-reward/{rewardId}";
        if (rewardId === undefined || rewardId === null)
            throw new Error("The parameter 'rewardId' must be defined.");
        url_ = url_.replace("{rewardId}", encodeURIComponent("" + rewardId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRedeemReward(_response);
        });
    }

    protected processRedeemReward(response: Response): Promise<UserSideMyPointModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <UserSideMyPointModel>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserSideMyPointModel>(<any>null);
    }
}

export class UsersideMyteamService {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param json (optional) 
     * @return Success
     */
    getAllTeamEmployee(json: string | null | undefined): Promise<UserSideValidAddModel> {
        let url_ = this.baseUrl + "/api/v1/userside-myteam/get-all-team-employee?";
        if (json !== undefined)
            url_ += "json=" + encodeURIComponent("" + json) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllTeamEmployee(_response);
        });
    }

    protected processGetAllTeamEmployee(response: Response): Promise<UserSideValidAddModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <UserSideValidAddModel>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserSideValidAddModel>(<any>null);
    }

    /**
     * @param newEmployeeId (optional) 
     * @return Success
     */
    requestNewMember(newEmployeeId: string | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/v1/userside-myteam/request-new-member";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(newEmployeeId);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRequestNewMember(_response);
        });
    }

    protected processRequestNewMember(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }
}

export class UsersideNewsService {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    newsCategories(): Promise<UserSideNewsCategoryModel[]> {
        let url_ = this.baseUrl + "/api/v1/userside-news/news-categories";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processNewsCategories(_response);
        });
    }

    protected processNewsCategories(response: Response): Promise<UserSideNewsCategoryModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <UserSideNewsCategoryModel[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserSideNewsCategoryModel[]>(<any>null);
    }

    /**
     * @param itemPerPage (optional) 
     * @param pageIndex (optional) 
     * @return Success
     */
    popularNews(itemPerPage: number | null | undefined, pageIndex: number | null | undefined): Promise<UserSideNewsModel[]> {
        let url_ = this.baseUrl + "/api/v1/userside-news/popular-news?";
        if (itemPerPage !== undefined)
            url_ += "itemPerPage=" + encodeURIComponent("" + itemPerPage) + "&"; 
        if (pageIndex !== undefined)
            url_ += "pageIndex=" + encodeURIComponent("" + pageIndex) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPopularNews(_response);
        });
    }

    protected processPopularNews(response: Response): Promise<UserSideNewsModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <UserSideNewsModel[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserSideNewsModel[]>(<any>null);
    }

    /**
     * @param sortBy (optional) 
     * @param itemPerPage (optional) 
     * @param pageIndex (optional) 
     * @param author (optional) 
     * @param category (optional) 
     * @return Success
     */
    news(sortBy: string | null | undefined, itemPerPage: number | null | undefined, pageIndex: number | null | undefined, author: string | null | undefined, category: string | null | undefined): Promise<UserSideNewsModel[]> {
        let url_ = this.baseUrl + "/api/v1/userside-news/news?";
        if (sortBy !== undefined)
            url_ += "SortBy=" + encodeURIComponent("" + sortBy) + "&"; 
        if (itemPerPage !== undefined)
            url_ += "ItemPerPage=" + encodeURIComponent("" + itemPerPage) + "&"; 
        if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&"; 
        if (author !== undefined)
            url_ += "Author=" + encodeURIComponent("" + author) + "&"; 
        if (category !== undefined)
            url_ += "Category=" + encodeURIComponent("" + category) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processNews(_response);
        });
    }

    protected processNews(response: Response): Promise<UserSideNewsModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <UserSideNewsModel[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserSideNewsModel[]>(<any>null);
    }

    /**
     * @param itemPerPageRelatedNews (optional) 
     * @param pageIndexRelatedNews (optional) 
     * @return Success
     */
    detailNews(newsId: number, itemPerPageRelatedNews: number | null | undefined, pageIndexRelatedNews: number | null | undefined): Promise<UserSideNewsModel[]> {
        let url_ = this.baseUrl + "/api/v1/userside-news/detail-news/{newsId}?";
        if (newsId === undefined || newsId === null)
            throw new Error("The parameter 'newsId' must be defined.");
        url_ = url_.replace("{newsId}", encodeURIComponent("" + newsId)); 
        if (itemPerPageRelatedNews !== undefined)
            url_ += "itemPerPageRelatedNews=" + encodeURIComponent("" + itemPerPageRelatedNews) + "&"; 
        if (pageIndexRelatedNews !== undefined)
            url_ += "pageIndexRelatedNews=" + encodeURIComponent("" + pageIndexRelatedNews) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDetailNews(_response);
        });
    }

    protected processDetailNews(response: Response): Promise<UserSideNewsModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <UserSideNewsModel[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserSideNewsModel[]>(<any>null);
    }

    /**
     * @param itemPerPage (optional) 
     * @param pageIndex (optional) 
     * @return Success
     */
    newsByCategory(newsCategoryId: number, itemPerPage: number | null | undefined, pageIndex: number | null | undefined): Promise<UserSideNewsModel[]> {
        let url_ = this.baseUrl + "/api/v1/userside-news/news-by-category/{newsCategoryId}?";
        if (newsCategoryId === undefined || newsCategoryId === null)
            throw new Error("The parameter 'newsCategoryId' must be defined.");
        url_ = url_.replace("{newsCategoryId}", encodeURIComponent("" + newsCategoryId)); 
        if (itemPerPage !== undefined)
            url_ += "itemPerPage=" + encodeURIComponent("" + itemPerPage) + "&"; 
        if (pageIndex !== undefined)
            url_ += "pageIndex=" + encodeURIComponent("" + pageIndex) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processNewsByCategory(_response);
        });
    }

    protected processNewsByCategory(response: Response): Promise<UserSideNewsModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <UserSideNewsModel[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserSideNewsModel[]>(<any>null);
    }

    /**
     * @param newsId (optional) 
     * @return Success
     */
    addTotalView(newsId: number | null | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/v1/userside-news/add-total-view?";
        if (newsId !== undefined)
            url_ += "newsId=" + encodeURIComponent("" + newsId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAddTotalView(_response);
        });
    }

    protected processAddTotalView(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <boolean>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(<any>null);
    }
}

export class UsersidePersonalMappingService {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param employeeId (optional) 
     * @return Success
     */
    getPersonalMappingByEmployeeId(employeeId: string | null | undefined): Promise<UserSidePersonalMappingModel> {
        let url_ = this.baseUrl + "/api/v1/userside-personal-mapping/get-personal-mapping-by-employee-id?";
        if (employeeId !== undefined)
            url_ += "employeeId=" + encodeURIComponent("" + employeeId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetPersonalMappingByEmployeeId(_response);
        });
    }

    protected processGetPersonalMappingByEmployeeId(response: Response): Promise<UserSidePersonalMappingModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <UserSidePersonalMappingModel>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserSidePersonalMappingModel>(<any>null);
    }

    /**
     * @return Success
     */
    getPersonalMappingByToken(): Promise<UserSidePersonalMappingModel> {
        let url_ = this.baseUrl + "/api/v1/userside-personal-mapping/get-personal-mapping-by-token";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetPersonalMappingByToken(_response);
        });
    }

    protected processGetPersonalMappingByToken(response: Response): Promise<UserSidePersonalMappingModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <UserSidePersonalMappingModel>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserSidePersonalMappingModel>(<any>null);
    }
}

export class UsersidePopquizService {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param pageSize (optional) 
     * @param pageIndex (optional) 
     * @param sortBy (optional) 
     * @return Success
     */
    getAllPopquiz(pageSize: number | null | undefined, pageIndex: number | null | undefined, sortBy: string | null | undefined): Promise<UserSidePopQuizModel[]> {
        let url_ = this.baseUrl + "/api/v1/userside-popquiz/get-all-popquiz?";
        if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&"; 
        if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&"; 
        if (sortBy !== undefined)
            url_ += "SortBy=" + encodeURIComponent("" + sortBy) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllPopquiz(_response);
        });
    }

    protected processGetAllPopquiz(response: Response): Promise<UserSidePopQuizModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <UserSidePopQuizModel[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserSidePopQuizModel[]>(<any>null);
    }
}

//export class UsersideProfileService {
//    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
//    private baseUrl: string;
//    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

//    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
//        this.http = http ? http : <any>window;
//        this.baseUrl = baseUrl ? baseUrl : "";
//    }

//    /**
//     * @return Success
//     */
//    getProfileGet(employeeId: string): Promise<ProfileViewModel> {
//        let url_ = this.baseUrl + "/api/v1/userside-profile/get-profile/{employeeId}";
//        if (employeeId === undefined || employeeId === null)
//            throw new Error("The parameter 'employeeId' must be defined.");
//        url_ = url_.replace("{employeeId}", encodeURIComponent("" + employeeId)); 
//        url_ = url_.replace(/[?&]$/, "");

//        let options_ = <RequestInit>{
//            method: "GET",
//            headers: {
//                "Accept": "application/json"
//            }
//        };

//        return this.http.fetch(url_, options_).then((_response: Response) => {
//            return this.processGetProfileGet(_response);
//        });
//    }

//    protected processGetProfileGet(response: Response): Promise<ProfileViewModel> {
//        const status = response.status;
//        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
//        if (status === 200) {
//            return response.text().then((_responseText) => {
//            let result200: any = null;
//            result200 = _responseText === "" ? null : <ProfileViewModel>JSON.parse(_responseText, this.jsonParseReviver);
//            return result200;
//            });
//        } else if (status !== 200 && status !== 204) {
//            return response.text().then((_responseText) => {
//            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
//            });
//        }
//        return Promise.resolve<ProfileViewModel>(<any>null);
//    }

//    /**
//     * @return Success
//     */
//    getProfileGet(): Promise<ProfileViewModel> {
//        let url_ = this.baseUrl + "/api/v1/userside-profile/get-profile";
//        url_ = url_.replace(/[?&]$/, "");

//        let options_ = <RequestInit>{
//            method: "GET",
//            headers: {
//                "Accept": "application/json"
//            }
//        };

//        return this.http.fetch(url_, options_).then((_response: Response) => {
//            return this.processGetProfileGet(_response);
//        });
//    }

//    protected processGetProfileGet(response: Response): Promise<ProfileViewModel> {
//        const status = response.status;
//        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
//        if (status === 200) {
//            return response.text().then((_responseText) => {
//            let result200: any = null;
//            result200 = _responseText === "" ? null : <ProfileViewModel>JSON.parse(_responseText, this.jsonParseReviver);
//            return result200;
//            });
//        } else if (status !== 200 && status !== 204) {
//            return response.text().then((_responseText) => {
//            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
//            });
//        }
//        return Promise.resolve<ProfileViewModel>(<any>null);
//    }

//    /**
//     * @param employeeId (optional) 
//     * @param nickName (optional) 
//     * @param bioDescription (optional) 
//     * @param fileUploaded_Base64 (optional) 
//     * @param fileUploaded_FileName (optional) 
//     * @param fileUploaded_ContentType (optional) 
//     * @return Success
//     */
//    updateProfile(employeeId: string | null | undefined, nickName: string | null | undefined, bioDescription: string | null | undefined, fileUploaded_Base64: string | null | undefined, fileUploaded_FileName: string | null | undefined, fileUploaded_ContentType: string | null | undefined): Promise<void> {
//        let url_ = this.baseUrl + "/api/v1/userside-profile/update-profile";
//        url_ = url_.replace(/[?&]$/, "");

//        const content_ = new FormData();
//        if (employeeId !== null && employeeId !== undefined)
//            content_.append("EmployeeId", employeeId.toString());
//        if (nickName !== null && nickName !== undefined)
//            content_.append("NickName", nickName.toString());
//        if (bioDescription !== null && bioDescription !== undefined)
//            content_.append("BioDescription", bioDescription.toString());
//        if (fileUploaded_Base64 !== null && fileUploaded_Base64 !== undefined)
//            content_.append("FileUploaded.Base64", fileUploaded_Base64.toString());
//        if (fileUploaded_FileName !== null && fileUploaded_FileName !== undefined)
//            content_.append("FileUploaded.FileName", fileUploaded_FileName.toString());
//        if (fileUploaded_ContentType !== null && fileUploaded_ContentType !== undefined)
//            content_.append("FileUploaded.ContentType", fileUploaded_ContentType.toString());

//        let options_ = <RequestInit>{
//            body: content_,
//            method: "PUT",
//            headers: {
//            }
//        };

//        return this.http.fetch(url_, options_).then((_response: Response) => {
//            return this.processUpdateProfile(_response);
//        });
//    }

//    protected processUpdateProfile(response: Response): Promise<void> {
//        const status = response.status;
//        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
//        if (status === 200) {
//            return response.text().then((_responseText) => {
//            return;
//            });
//        } else if (status !== 200 && status !== 204) {
//            return response.text().then((_responseText) => {
//            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
//            });
//        }
//        return Promise.resolve<void>(<any>null);
//    }

//    /**
//     * @return Success
//     */
//    interestProfileGet(employeeId: string): Promise<UserSideInterestProfileFormModel[]> {
//        let url_ = this.baseUrl + "/api/v1/userside-profile/interest-profile/{employeeId}";
//        if (employeeId === undefined || employeeId === null)
//            throw new Error("The parameter 'employeeId' must be defined.");
//        url_ = url_.replace("{employeeId}", encodeURIComponent("" + employeeId)); 
//        url_ = url_.replace(/[?&]$/, "");

//        let options_ = <RequestInit>{
//            method: "GET",
//            headers: {
//                "Accept": "application/json"
//            }
//        };

//        return this.http.fetch(url_, options_).then((_response: Response) => {
//            return this.processInterestProfileGet(_response);
//        });
//    }

//    protected processInterestProfileGet(response: Response): Promise<UserSideInterestProfileFormModel[]> {
//        const status = response.status;
//        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
//        if (status === 200) {
//            return response.text().then((_responseText) => {
//            let result200: any = null;
//            result200 = _responseText === "" ? null : <UserSideInterestProfileFormModel[]>JSON.parse(_responseText, this.jsonParseReviver);
//            return result200;
//            });
//        } else if (status !== 200 && status !== 204) {
//            return response.text().then((_responseText) => {
//            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
//            });
//        }
//        return Promise.resolve<UserSideInterestProfileFormModel[]>(<any>null);
//    }

//    /**
//     * @param interestIds (optional) 
//     * @return Success
//     */
//    interestProfilePost(employeeId: string, interestIds: number[] | null | undefined): Promise<void> {
//        let url_ = this.baseUrl + "/api/v1/userside-profile/interest-profile/{employeeId}";
//        if (employeeId === undefined || employeeId === null)
//            throw new Error("The parameter 'employeeId' must be defined.");
//        url_ = url_.replace("{employeeId}", encodeURIComponent("" + employeeId)); 
//        url_ = url_.replace(/[?&]$/, "");

//        const content_ = JSON.stringify(interestIds);

//        let options_ = <RequestInit>{
//            body: content_,
//            method: "POST",
//            headers: {
//                "Content-Type": "application/json",
//            }
//        };

//        return this.http.fetch(url_, options_).then((_response: Response) => {
//            return this.processInterestProfilePost(_response);
//        });
//    }

//    protected processInterestProfilePost(response: Response): Promise<void> {
//        const status = response.status;
//        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
//        if (status === 200) {
//            return response.text().then((_responseText) => {
//            return;
//            });
//        } else if (status !== 200 && status !== 204) {
//            return response.text().then((_responseText) => {
//            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
//            });
//        }
//        return Promise.resolve<void>(<any>null);
//    }

//    /**
//     * @return Success
//     */
//    interestProfileByTokenGet(): Promise<UserSideInterestProfileFormModel[]> {
//        let url_ = this.baseUrl + "/api/v1/userside-profile/interest-profile-by-token";
//        url_ = url_.replace(/[?&]$/, "");

//        let options_ = <RequestInit>{
//            method: "GET",
//            headers: {
//                "Accept": "application/json"
//            }
//        };

//        return this.http.fetch(url_, options_).then((_response: Response) => {
//            return this.processInterestProfileByTokenGet(_response);
//        });
//    }

//    protected processInterestProfileByTokenGet(response: Response): Promise<UserSideInterestProfileFormModel[]> {
//        const status = response.status;
//        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
//        if (status === 200) {
//            return response.text().then((_responseText) => {
//            let result200: any = null;
//            result200 = _responseText === "" ? null : <UserSideInterestProfileFormModel[]>JSON.parse(_responseText, this.jsonParseReviver);
//            return result200;
//            });
//        } else if (status !== 200 && status !== 204) {
//            return response.text().then((_responseText) => {
//            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
//            });
//        }
//        return Promise.resolve<UserSideInterestProfileFormModel[]>(<any>null);
//    }

//    /**
//     * @param interestIds (optional) 
//     * @return Success
//     */
//    interestProfileByTokenPost(interestIds: number[] | null | undefined): Promise<void> {
//        let url_ = this.baseUrl + "/api/v1/userside-profile/interest-profile-by-token";
//        url_ = url_.replace(/[?&]$/, "");

//        const content_ = JSON.stringify(interestIds);

//        let options_ = <RequestInit>{
//            body: content_,
//            method: "POST",
//            headers: {
//                "Content-Type": "application/json",
//            }
//        };

//        return this.http.fetch(url_, options_).then((_response: Response) => {
//            return this.processInterestProfileByTokenPost(_response);
//        });
//    }

//    protected processInterestProfileByTokenPost(response: Response): Promise<void> {
//        const status = response.status;
//        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
//        if (status === 200) {
//            return response.text().then((_responseText) => {
//            return;
//            });
//        } else if (status !== 200 && status !== 204) {
//            return response.text().then((_responseText) => {
//            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
//            });
//        }
//        return Promise.resolve<void>(<any>null);
//    }

//    /**
//     * @return Success
//     */
//    hobbyProfileGet(employeeId: string): Promise<UserSideHobbyProfileFormModel[]> {
//        let url_ = this.baseUrl + "/api/v1/userside-profile/hobby-profile/{employeeId}";
//        if (employeeId === undefined || employeeId === null)
//            throw new Error("The parameter 'employeeId' must be defined.");
//        url_ = url_.replace("{employeeId}", encodeURIComponent("" + employeeId)); 
//        url_ = url_.replace(/[?&]$/, "");

//        let options_ = <RequestInit>{
//            method: "GET",
//            headers: {
//                "Accept": "application/json"
//            }
//        };

//        return this.http.fetch(url_, options_).then((_response: Response) => {
//            return this.processHobbyProfileGet(_response);
//        });
//    }

//    protected processHobbyProfileGet(response: Response): Promise<UserSideHobbyProfileFormModel[]> {
//        const status = response.status;
//        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
//        if (status === 200) {
//            return response.text().then((_responseText) => {
//            let result200: any = null;
//            result200 = _responseText === "" ? null : <UserSideHobbyProfileFormModel[]>JSON.parse(_responseText, this.jsonParseReviver);
//            return result200;
//            });
//        } else if (status !== 200 && status !== 204) {
//            return response.text().then((_responseText) => {
//            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
//            });
//        }
//        return Promise.resolve<UserSideHobbyProfileFormModel[]>(<any>null);
//    }

//    /**
//     * @param hobbyIds (optional) 
//     * @return Success
//     */
//    hobbyProfilePost(employeeId: string, hobbyIds: number[] | null | undefined): Promise<void> {
//        let url_ = this.baseUrl + "/api/v1/userside-profile/hobby-profile/{employeeId}";
//        if (employeeId === undefined || employeeId === null)
//            throw new Error("The parameter 'employeeId' must be defined.");
//        url_ = url_.replace("{employeeId}", encodeURIComponent("" + employeeId)); 
//        url_ = url_.replace(/[?&]$/, "");

//        const content_ = JSON.stringify(hobbyIds);

//        let options_ = <RequestInit>{
//            body: content_,
//            method: "POST",
//            headers: {
//                "Content-Type": "application/json",
//            }
//        };

//        return this.http.fetch(url_, options_).then((_response: Response) => {
//            return this.processHobbyProfilePost(_response);
//        });
//    }

//    protected processHobbyProfilePost(response: Response): Promise<void> {
//        const status = response.status;
//        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
//        if (status === 200) {
//            return response.text().then((_responseText) => {
//            return;
//            });
//        } else if (status !== 200 && status !== 204) {
//            return response.text().then((_responseText) => {
//            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
//            });
//        }
//        return Promise.resolve<void>(<any>null);
//    }

//    /**
//     * @return Success
//     */
//    hobbyProfileByTokenGet(): Promise<UserSideHobbyProfileFormModel[]> {
//        let url_ = this.baseUrl + "/api/v1/userside-profile/hobby-profile-by-token";
//        url_ = url_.replace(/[?&]$/, "");

//        let options_ = <RequestInit>{
//            method: "GET",
//            headers: {
//                "Accept": "application/json"
//            }
//        };

//        return this.http.fetch(url_, options_).then((_response: Response) => {
//            return this.processHobbyProfileByTokenGet(_response);
//        });
//    }

//    protected processHobbyProfileByTokenGet(response: Response): Promise<UserSideHobbyProfileFormModel[]> {
//        const status = response.status;
//        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
//        if (status === 200) {
//            return response.text().then((_responseText) => {
//            let result200: any = null;
//            result200 = _responseText === "" ? null : <UserSideHobbyProfileFormModel[]>JSON.parse(_responseText, this.jsonParseReviver);
//            return result200;
//            });
//        } else if (status !== 200 && status !== 204) {
//            return response.text().then((_responseText) => {
//            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
//            });
//        }
//        return Promise.resolve<UserSideHobbyProfileFormModel[]>(<any>null);
//    }

//    /**
//     * @param hobbyIds (optional) 
//     * @return Success
//     */
//    hobbyProfileByTokenPost(hobbyIds: number[] | null | undefined): Promise<void> {
//        let url_ = this.baseUrl + "/api/v1/userside-profile/hobby-profile-by-token";
//        url_ = url_.replace(/[?&]$/, "");

//        const content_ = JSON.stringify(hobbyIds);

//        let options_ = <RequestInit>{
//            body: content_,
//            method: "POST",
//            headers: {
//                "Content-Type": "application/json",
//            }
//        };

//        return this.http.fetch(url_, options_).then((_response: Response) => {
//            return this.processHobbyProfileByTokenPost(_response);
//        });
//    }

//    protected processHobbyProfileByTokenPost(response: Response): Promise<void> {
//        const status = response.status;
//        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
//        if (status === 200) {
//            return response.text().then((_responseText) => {
//            return;
//            });
//        } else if (status !== 200 && status !== 204) {
//            return response.text().then((_responseText) => {
//            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
//            });
//        }
//        return Promise.resolve<void>(<any>null);
//    }

//    /**
//     * @return Success
//     */
//    profileHomePage(employeeId: string): Promise<ProfileHomePage> {
//        let url_ = this.baseUrl + "/api/v1/userside-profile/profile-home-page/{employeeId}";
//        if (employeeId === undefined || employeeId === null)
//            throw new Error("The parameter 'employeeId' must be defined.");
//        url_ = url_.replace("{employeeId}", encodeURIComponent("" + employeeId)); 
//        url_ = url_.replace(/[?&]$/, "");

//        let options_ = <RequestInit>{
//            method: "GET",
//            headers: {
//                "Accept": "application/json"
//            }
//        };

//        return this.http.fetch(url_, options_).then((_response: Response) => {
//            return this.processProfileHomePage(_response);
//        });
//    }

//    protected processProfileHomePage(response: Response): Promise<ProfileHomePage> {
//        const status = response.status;
//        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
//        if (status === 200) {
//            return response.text().then((_responseText) => {
//            let result200: any = null;
//            result200 = _responseText === "" ? null : <ProfileHomePage>JSON.parse(_responseText, this.jsonParseReviver);
//            return result200;
//            });
//        } else if (status !== 200 && status !== 204) {
//            return response.text().then((_responseText) => {
//            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
//            });
//        }
//        return Promise.resolve<ProfileHomePage>(<any>null);
//    }

//    /**
//     * @return Success
//     */
//    profileHomePageByToken(): Promise<ProfileHomePage> {
//        let url_ = this.baseUrl + "/api/v1/userside-profile/profile-home-page-by-token";
//        url_ = url_.replace(/[?&]$/, "");

//        let options_ = <RequestInit>{
//            method: "GET",
//            headers: {
//                "Accept": "application/json"
//            }
//        };

//        return this.http.fetch(url_, options_).then((_response: Response) => {
//            return this.processProfileHomePageByToken(_response);
//        });
//    }

//    protected processProfileHomePageByToken(response: Response): Promise<ProfileHomePage> {
//        const status = response.status;
//        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
//        if (status === 200) {
//            return response.text().then((_responseText) => {
//            let result200: any = null;
//            result200 = _responseText === "" ? null : <ProfileHomePage>JSON.parse(_responseText, this.jsonParseReviver);
//            return result200;
//            });
//        } else if (status !== 200 && status !== 204) {
//            return response.text().then((_responseText) => {
//            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
//            });
//        }
//        return Promise.resolve<ProfileHomePage>(<any>null);
//    }

//    /**
//     * @param point (optional) 
//     * @return Success
//     */
//    employeeLevelMinValue(point: number | null | undefined): Promise<ProfileHomePage> {
//        let url_ = this.baseUrl + "/api/v1/userside-profile/employee-level-min-value?";
//        if (point !== undefined)
//            url_ += "point=" + encodeURIComponent("" + point) + "&"; 
//        url_ = url_.replace(/[?&]$/, "");

//        let options_ = <RequestInit>{
//            method: "GET",
//            headers: {
//                "Accept": "application/json"
//            }
//        };

//        return this.http.fetch(url_, options_).then((_response: Response) => {
//            return this.processEmployeeLevelMinValue(_response);
//        });
//    }

//    protected processEmployeeLevelMinValue(response: Response): Promise<ProfileHomePage> {
//        const status = response.status;
//        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
//        if (status === 200) {
//            return response.text().then((_responseText) => {
//            let result200: any = null;
//            result200 = _responseText === "" ? null : <ProfileHomePage>JSON.parse(_responseText, this.jsonParseReviver);
//            return result200;
//            });
//        } else if (status !== 200 && status !== 204) {
//            return response.text().then((_responseText) => {
//            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
//            });
//        }
//        return Promise.resolve<ProfileHomePage>(<any>null);
//    }

//    /**
//     * @param teamId (optional) 
//     * @return Success
//     */
//    getProfileRankByToken(teamId: number | null | undefined): Promise<ProfileRankModel> {
//        let url_ = this.baseUrl + "/api/v1/userside-profile/get-profile-rank-by-token?";
//        if (teamId !== undefined)
//            url_ += "teamId=" + encodeURIComponent("" + teamId) + "&"; 
//        url_ = url_.replace(/[?&]$/, "");

//        let options_ = <RequestInit>{
//            method: "GET",
//            headers: {
//                "Accept": "application/json"
//            }
//        };

//        return this.http.fetch(url_, options_).then((_response: Response) => {
//            return this.processGetProfileRankByToken(_response);
//        });
//    }

//    protected processGetProfileRankByToken(response: Response): Promise<ProfileRankModel> {
//        const status = response.status;
//        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
//        if (status === 200) {
//            return response.text().then((_responseText) => {
//            let result200: any = null;
//            result200 = _responseText === "" ? null : <ProfileRankModel>JSON.parse(_responseText, this.jsonParseReviver);
//            return result200;
//            });
//        } else if (status !== 200 && status !== 204) {
//            return response.text().then((_responseText) => {
//            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
//            });
//        }
//        return Promise.resolve<ProfileRankModel>(<any>null);
//    }

//    /**
//     * @param employeeId (optional) 
//     * @param teamId (optional) 
//     * @return Success
//     */
//    getProfileRank(employeeId: string | null | undefined, teamId: number | null | undefined): Promise<ProfileRankModel> {
//        let url_ = this.baseUrl + "/api/v1/userside-profile/get-profile-rank?";
//        if (employeeId !== undefined)
//            url_ += "employeeId=" + encodeURIComponent("" + employeeId) + "&"; 
//        if (teamId !== undefined)
//            url_ += "teamId=" + encodeURIComponent("" + teamId) + "&"; 
//        url_ = url_.replace(/[?&]$/, "");

//        let options_ = <RequestInit>{
//            method: "GET",
//            headers: {
//                "Accept": "application/json"
//            }
//        };

//        return this.http.fetch(url_, options_).then((_response: Response) => {
//            return this.processGetProfileRank(_response);
//        });
//    }

//    protected processGetProfileRank(response: Response): Promise<ProfileRankModel> {
//        const status = response.status;
//        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
//        if (status === 200) {
//            return response.text().then((_responseText) => {
//            let result200: any = null;
//            result200 = _responseText === "" ? null : <ProfileRankModel>JSON.parse(_responseText, this.jsonParseReviver);
//            return result200;
//            });
//        } else if (status !== 200 && status !== 204) {
//            return response.text().then((_responseText) => {
//            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
//            });
//        }
//        return Promise.resolve<ProfileRankModel>(<any>null);
//    }
//}

export class UsersideRankService {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getRankCoach(): Promise<UserSideRankModel> {
        let url_ = this.baseUrl + "/api/v1/userside-rank/get-rank-coach";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetRankCoach(_response);
        });
    }

    protected processGetRankCoach(response: Response): Promise<UserSideRankModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <UserSideRankModel>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserSideRankModel>(<any>null);
    }

    /**
     * @param itemPerPage (optional) 
     * @param pageIndex (optional) 
     * @return Success
     */
    positions(itemPerPage: number | null | undefined, pageIndex: number | null | undefined): Promise<UserSidePositionModel> {
        let url_ = this.baseUrl + "/api/v1/userside-rank/positions?";
        if (itemPerPage !== undefined)
            url_ += "itemPerPage=" + encodeURIComponent("" + itemPerPage) + "&"; 
        if (pageIndex !== undefined)
            url_ += "pageIndex=" + encodeURIComponent("" + pageIndex) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPositions(_response);
        });
    }

    protected processPositions(response: Response): Promise<UserSidePositionModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <UserSidePositionModel>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserSidePositionModel>(<any>null);
    }

    /**
     * @param itemPerPage (optional) 
     * @param pageIndex (optional) 
     * @return Success
     */
    areas(itemPerPage: number | null | undefined, pageIndex: number | null | undefined): Promise<UserSideAreaModel> {
        let url_ = this.baseUrl + "/api/v1/userside-rank/areas?";
        if (itemPerPage !== undefined)
            url_ += "itemPerPage=" + encodeURIComponent("" + itemPerPage) + "&"; 
        if (pageIndex !== undefined)
            url_ += "pageIndex=" + encodeURIComponent("" + pageIndex) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAreas(_response);
        });
    }

    protected processAreas(response: Response): Promise<UserSideAreaModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <UserSideAreaModel>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserSideAreaModel>(<any>null);
    }

    /**
     * @param itemPerPage (optional) 
     * @param pageIndex (optional) 
     * @return Success
     */
    dealers(itemPerPage: number | null | undefined, pageIndex: number | null | undefined): Promise<UserSideDealerModel> {
        let url_ = this.baseUrl + "/api/v1/userside-rank/dealers?";
        if (itemPerPage !== undefined)
            url_ += "itemPerPage=" + encodeURIComponent("" + itemPerPage) + "&"; 
        if (pageIndex !== undefined)
            url_ += "pageIndex=" + encodeURIComponent("" + pageIndex) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDealers(_response);
        });
    }

    protected processDealers(response: Response): Promise<UserSideDealerModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <UserSideDealerModel>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserSideDealerModel>(<any>null);
    }

    /**
     * @param areaIds (optional) 
     * @param dealerIds (optional) 
     * @param positionIds (optional) 
     * @param isAllTime (optional) 
     * @param sortBy (optional) 
     * @return Success
     */
    getRankAllUserByToken(areaIds: string[] | null | undefined, dealerIds: string[] | null | undefined, positionIds: number[] | null | undefined, isAllTime: boolean | null | undefined, sortBy: string | null | undefined): Promise<UserSideRankModel> {
        let url_ = this.baseUrl + "/api/v1/userside-rank/get-rank-all-user-by-token?";
        if (areaIds !== undefined)
            areaIds && areaIds.forEach(item => { url_ += "AreaIds=" + encodeURIComponent("" + item) + "&"; });
        if (dealerIds !== undefined)
            dealerIds && dealerIds.forEach(item => { url_ += "DealerIds=" + encodeURIComponent("" + item) + "&"; });
        if (positionIds !== undefined)
            positionIds && positionIds.forEach(item => { url_ += "PositionIds=" + encodeURIComponent("" + item) + "&"; });
        if (isAllTime !== undefined)
            url_ += "IsAllTime=" + encodeURIComponent("" + isAllTime) + "&"; 
        if (sortBy !== undefined)
            url_ += "SortBy=" + encodeURIComponent("" + sortBy) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetRankAllUserByToken(_response);
        });
    }

    protected processGetRankAllUserByToken(response: Response): Promise<UserSideRankModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <UserSideRankModel>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserSideRankModel>(<any>null);
    }

    /**
     * @return Success
     */
    getRankUserByToken(): Promise<UserSideRankModel> {
        let url_ = this.baseUrl + "/api/v1/userside-rank/get-rank-user-by-token";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetRankUserByToken(_response);
        });
    }

    protected processGetRankUserByToken(response: Response): Promise<UserSideRankModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <UserSideRankModel>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserSideRankModel>(<any>null);
    }
}

export class UsersideReviewService {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param trainingId (optional) 
     * @return Success
     */
    getAllCoach(trainingId: number | null | undefined): Promise<UserSideCoachReviewModel[]> {
        let url_ = this.baseUrl + "/api/v1/userside-review/get-all-coach?";
        if (trainingId !== undefined)
            url_ += "trainingId=" + encodeURIComponent("" + trainingId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllCoach(_response);
        });
    }

    protected processGetAllCoach(response: Response): Promise<UserSideCoachReviewModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <UserSideCoachReviewModel[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserSideCoachReviewModel[]>(<any>null);
    }

    /**
     * @param model (optional) 
     * @return Success
     */
    insertTrainingReview(model: UserSideTrainingReviewSubmitModel | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/v1/userside-review/insert-training-review";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processInsertTrainingReview(_response);
        });
    }

    protected processInsertTrainingReview(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param model (optional) 
     * @return Success
     */
    insertCoachReview(model: UserSideCoachReviewSubmitModel | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/v1/userside-review/insert-coach-review";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processInsertCoachReview(_response);
        });
    }

    protected processInsertCoachReview(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }
}

export class ScheduleBookingService {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param coachScheduleId (optional) 
     * @param message (optional) 
     * @return Success
     */
    coachScheduleBooking(coachScheduleId: number | null | undefined, message: string | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/v1/schedule-booking/coach-schedule-booking?";
        if (coachScheduleId !== undefined)
            url_ += "coachScheduleId=" + encodeURIComponent("" + coachScheduleId) + "&"; 
        if (message !== undefined)
            url_ += "message=" + encodeURIComponent("" + message) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCoachScheduleBooking(_response);
        });
    }

    protected processCoachScheduleBooking(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }
}

export class UsersideSearchService {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param learningName (optional) 
     * @param programTypeId (optional) 
     * @param learningTypeId (optional) 
     * @param materialTypeId (optional) 
     * @param coursePrice (optional) 
     * @param sortBy (optional) 
     * @param pageSize (optional) 
     * @param pageIndex (optional) 
     * @return Success
     */
    getAllLearnings(learningName: string | null | undefined, programTypeId: number[] | null | undefined, learningTypeId: number[] | null | undefined, materialTypeId: number[] | null | undefined, coursePrice: number[] | null | undefined, sortBy: string | null | undefined, pageSize: number | null | undefined, pageIndex: number | null | undefined): Promise<LearningViewModel[]> {
        let url_ = this.baseUrl + "/api/v1/userside-search/get-all-learnings?";
        if (learningName !== undefined)
            url_ += "LearningName=" + encodeURIComponent("" + learningName) + "&"; 
        if (programTypeId !== undefined)
            programTypeId && programTypeId.forEach(item => { url_ += "ProgramTypeId=" + encodeURIComponent("" + item) + "&"; });
        if (learningTypeId !== undefined)
            learningTypeId && learningTypeId.forEach(item => { url_ += "LearningTypeId=" + encodeURIComponent("" + item) + "&"; });
        if (materialTypeId !== undefined)
            materialTypeId && materialTypeId.forEach(item => { url_ += "MaterialTypeId=" + encodeURIComponent("" + item) + "&"; });
        if (coursePrice !== undefined)
            coursePrice && coursePrice.forEach(item => { url_ += "CoursePrice=" + encodeURIComponent("" + item) + "&"; });
        if (sortBy !== undefined)
            url_ += "SortBy=" + encodeURIComponent("" + sortBy) + "&"; 
        if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&"; 
        if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllLearnings(_response);
        });
    }

    protected processGetAllLearnings(response: Response): Promise<LearningViewModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <LearningViewModel[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<LearningViewModel[]>(<any>null);
    }

    /**
     * @param coachName (optional) 
     * @param areaId (optional) 
     * @param cityId (optional) 
     * @param dealerId (optional) 
     * @param provinceId (optional) 
     * @param outletId (optional) 
     * @param positionId (optional) 
     * @param sortBy (optional) 
     * @param pageSize (optional) 
     * @param pageIndex (optional) 
     * @param topicId (optional) 
     * @param eBadgeId (optional) 
     * @return Success
     */
    getAllCoaches(coachName: string | null | undefined, areaId: string[] | null | undefined, cityId: string[] | null | undefined, dealerId: string[] | null | undefined, provinceId: string[] | null | undefined, outletId: string[] | null | undefined, positionId: number[] | null | undefined, sortBy: string | null | undefined, pageSize: number | null | undefined, pageIndex: number | null | undefined, topicId: number[] | null | undefined, eBadgeId: number[] | null | undefined): Promise<CoachViewModel[]> {
        let url_ = this.baseUrl + "/api/v1/userside-search/get-all-coaches?";
        if (coachName !== undefined)
            url_ += "CoachName=" + encodeURIComponent("" + coachName) + "&"; 
        if (areaId !== undefined)
            areaId && areaId.forEach(item => { url_ += "AreaId=" + encodeURIComponent("" + item) + "&"; });
        if (cityId !== undefined)
            cityId && cityId.forEach(item => { url_ += "CityId=" + encodeURIComponent("" + item) + "&"; });
        if (dealerId !== undefined)
            dealerId && dealerId.forEach(item => { url_ += "DealerId=" + encodeURIComponent("" + item) + "&"; });
        if (provinceId !== undefined)
            provinceId && provinceId.forEach(item => { url_ += "ProvinceId=" + encodeURIComponent("" + item) + "&"; });
        if (outletId !== undefined)
            outletId && outletId.forEach(item => { url_ += "OutletId=" + encodeURIComponent("" + item) + "&"; });
        if (positionId !== undefined)
            positionId && positionId.forEach(item => { url_ += "PositionId=" + encodeURIComponent("" + item) + "&"; });
        if (sortBy !== undefined)
            url_ += "SortBy=" + encodeURIComponent("" + sortBy) + "&"; 
        if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&"; 
        if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&"; 
        if (topicId !== undefined)
            topicId && topicId.forEach(item => { url_ += "TopicId=" + encodeURIComponent("" + item) + "&"; });
        if (eBadgeId !== undefined)
            eBadgeId && eBadgeId.forEach(item => { url_ += "EBadgeId=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllCoaches(_response);
        });
    }

    protected processGetAllCoaches(response: Response): Promise<CoachViewModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <CoachViewModel[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CoachViewModel[]>(<any>null);
    }

    /**
     * @param areaId (optional) 
     * @param cityId (optional) 
     * @param dealerId (optional) 
     * @param provinceId (optional) 
     * @param outletId (optional) 
     * @param positionId (optional) 
     * @param name (optional) 
     * @param sortBy (optional) 
     * @param pageSize (optional) 
     * @param pageIndex (optional) 
     * @return Success
     */
    getAllPeoples(areaId: string[] | null | undefined, cityId: string[] | null | undefined, dealerId: string[] | null | undefined, provinceId: string[] | null | undefined, outletId: string[] | null | undefined, positionId: number[] | null | undefined, name: string | null | undefined, sortBy: string | null | undefined, pageSize: number | null | undefined, pageIndex: number | null | undefined): Promise<PeopleViewModel[]> {
        let url_ = this.baseUrl + "/api/v1/userside-search/get-all-peoples?";
        if (areaId !== undefined)
            areaId && areaId.forEach(item => { url_ += "AreaId=" + encodeURIComponent("" + item) + "&"; });
        if (cityId !== undefined)
            cityId && cityId.forEach(item => { url_ += "CityId=" + encodeURIComponent("" + item) + "&"; });
        if (dealerId !== undefined)
            dealerId && dealerId.forEach(item => { url_ += "DealerId=" + encodeURIComponent("" + item) + "&"; });
        if (provinceId !== undefined)
            provinceId && provinceId.forEach(item => { url_ += "ProvinceId=" + encodeURIComponent("" + item) + "&"; });
        if (outletId !== undefined)
            outletId && outletId.forEach(item => { url_ += "OutletId=" + encodeURIComponent("" + item) + "&"; });
        if (positionId !== undefined)
            positionId && positionId.forEach(item => { url_ += "PositionId=" + encodeURIComponent("" + item) + "&"; });
        if (name !== undefined)
            url_ += "Name=" + encodeURIComponent("" + name) + "&"; 
        if (sortBy !== undefined)
            url_ += "SortBy=" + encodeURIComponent("" + sortBy) + "&"; 
        if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&"; 
        if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllPeoples(_response);
        });
    }

    protected processGetAllPeoples(response: Response): Promise<PeopleViewModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <PeopleViewModel[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PeopleViewModel[]>(<any>null);
    }

    /**
     * @param name (optional) 
     * @param areaId (optional) 
     * @param cityId (optional) 
     * @param provinceId (optional) 
     * @param dealerId (optional) 
     * @param outletId (optional) 
     * @param positionId (optional) 
     * @param eventCategoryId (optional) 
     * @param sortBy (optional) 
     * @param pageSize (optional) 
     * @param pageIndex (optional) 
     * @return Success
     */
    getAllEvents(name: string | null | undefined, areaId: string[] | null | undefined, cityId: string[] | null | undefined, provinceId: string[] | null | undefined, dealerId: string[] | null | undefined, outletId: string[] | null | undefined, positionId: string[] | null | undefined, eventCategoryId: number[] | null | undefined, sortBy: string | null | undefined, pageSize: number | null | undefined, pageIndex: number | null | undefined): Promise<EventModel[]> {
        let url_ = this.baseUrl + "/api/v1/userside-search/get-all-events?";
        if (name !== undefined)
            url_ += "Name=" + encodeURIComponent("" + name) + "&"; 
        if (areaId !== undefined)
            areaId && areaId.forEach(item => { url_ += "AreaId=" + encodeURIComponent("" + item) + "&"; });
        if (cityId !== undefined)
            cityId && cityId.forEach(item => { url_ += "CityId=" + encodeURIComponent("" + item) + "&"; });
        if (provinceId !== undefined)
            provinceId && provinceId.forEach(item => { url_ += "ProvinceId=" + encodeURIComponent("" + item) + "&"; });
        if (dealerId !== undefined)
            dealerId && dealerId.forEach(item => { url_ += "DealerId=" + encodeURIComponent("" + item) + "&"; });
        if (outletId !== undefined)
            outletId && outletId.forEach(item => { url_ += "OutletId=" + encodeURIComponent("" + item) + "&"; });
        if (positionId !== undefined)
            positionId && positionId.forEach(item => { url_ += "PositionId=" + encodeURIComponent("" + item) + "&"; });
        if (eventCategoryId !== undefined)
            eventCategoryId && eventCategoryId.forEach(item => { url_ += "EventCategoryId=" + encodeURIComponent("" + item) + "&"; });
        if (sortBy !== undefined)
            url_ += "SortBy=" + encodeURIComponent("" + sortBy) + "&"; 
        if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&"; 
        if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllEvents(_response);
        });
    }

    protected processGetAllEvents(response: Response): Promise<EventModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <EventModel[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<EventModel[]>(<any>null);
    }

    /**
     * @param name (optional) 
     * @param newsCategoryIds (optional) 
     * @param newsInternalExternalTypeIds (optional) 
     * @param sortBy (optional) 
     * @param pageSize (optional) 
     * @param pageIndex (optional) 
     * @return Success
     */
    getAllNews(name: string | null | undefined, newsCategoryIds: number[] | null | undefined, newsInternalExternalTypeIds: number[] | null | undefined, sortBy: string | null | undefined, pageSize: number | null | undefined, pageIndex: number | null | undefined): Promise<NewsViewModel[]> {
        let url_ = this.baseUrl + "/api/v1/userside-search/get-all-news?";
        if (name !== undefined)
            url_ += "Name=" + encodeURIComponent("" + name) + "&"; 
        if (newsCategoryIds !== undefined)
            newsCategoryIds && newsCategoryIds.forEach(item => { url_ += "NewsCategoryIds=" + encodeURIComponent("" + item) + "&"; });
        if (newsInternalExternalTypeIds !== undefined)
            newsInternalExternalTypeIds && newsInternalExternalTypeIds.forEach(item => { url_ += "NewsInternalExternalTypeIds=" + encodeURIComponent("" + item) + "&"; });
        if (sortBy !== undefined)
            url_ += "SortBy=" + encodeURIComponent("" + sortBy) + "&"; 
        if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&"; 
        if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllNews(_response);
        });
    }

    protected processGetAllNews(response: Response): Promise<NewsViewModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <NewsViewModel[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<NewsViewModel[]>(<any>null);
    }

    /**
     * @param surveyName (optional) 
     * @param areaId (optional) 
     * @param cityId (optional) 
     * @param dealerId (optional) 
     * @param provinceId (optional) 
     * @param outletId (optional) 
     * @param sortBy (optional) 
     * @param pageSize (optional) 
     * @param pageIndex (optional) 
     * @return Success
     */
    getAllInsights(surveyName: string | null | undefined, areaId: string[] | null | undefined, cityId: string[] | null | undefined, dealerId: string[] | null | undefined, provinceId: string[] | null | undefined, outletId: string[] | null | undefined, sortBy: string | null | undefined, pageSize: number | null | undefined, pageIndex: number | null | undefined): Promise<NewsViewModel[]> {
        let url_ = this.baseUrl + "/api/v1/userside-search/get-all-insights?";
        if (surveyName !== undefined)
            url_ += "SurveyName=" + encodeURIComponent("" + surveyName) + "&"; 
        if (areaId !== undefined)
            areaId && areaId.forEach(item => { url_ += "AreaId=" + encodeURIComponent("" + item) + "&"; });
        if (cityId !== undefined)
            cityId && cityId.forEach(item => { url_ += "CityId=" + encodeURIComponent("" + item) + "&"; });
        if (dealerId !== undefined)
            dealerId && dealerId.forEach(item => { url_ += "DealerId=" + encodeURIComponent("" + item) + "&"; });
        if (provinceId !== undefined)
            provinceId && provinceId.forEach(item => { url_ += "ProvinceId=" + encodeURIComponent("" + item) + "&"; });
        if (outletId !== undefined)
            outletId && outletId.forEach(item => { url_ += "OutletId=" + encodeURIComponent("" + item) + "&"; });
        if (sortBy !== undefined)
            url_ += "SortBy=" + encodeURIComponent("" + sortBy) + "&"; 
        if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&"; 
        if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllInsights(_response);
        });
    }

    protected processGetAllInsights(response: Response): Promise<NewsViewModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <NewsViewModel[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<NewsViewModel[]>(<any>null);
    }

    /**
     * @param areaName (optional) 
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    getAllArea(areaName: string | null | undefined, pageIndex: number | null | undefined, pageSize: number | null | undefined): Promise<AreaModel[]> {
        let url_ = this.baseUrl + "/api/v1/userside-search/get-all-area?";
        if (areaName !== undefined)
            url_ += "AreaName=" + encodeURIComponent("" + areaName) + "&"; 
        if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&"; 
        if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllArea(_response);
        });
    }

    protected processGetAllArea(response: Response): Promise<AreaModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <AreaModel[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AreaModel[]>(<any>null);
    }
}

export class UsersideTaskanswerService {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param insert (optional) 
     * @param withTest (optional) 
     * @return Success
     */
    insertTaskAnswer(insert: TaskAnswerInsertModel | null | undefined, withTest: boolean | null | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/v1/userside-taskanswer/insert-task-answer?";
        if (withTest !== undefined)
            url_ += "withTest=" + encodeURIComponent("" + withTest) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(insert);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processInsertTaskAnswer(_response);
        });
    }

    protected processInsertTaskAnswer(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <boolean>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(<any>null);
    }

    /**
     * @return Success
     */
    calculateBulk(rangeDate: number): Promise<boolean> {
        let url_ = this.baseUrl + "/api/v1/userside-taskanswer/calculate-bulk/{rangeDate}";
        if (rangeDate === undefined || rangeDate === null)
            throw new Error("The parameter 'rangeDate' must be defined.");
        url_ = url_.replace("{rangeDate}", encodeURIComponent("" + rangeDate)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCalculateBulk(_response);
        });
    }

    protected processCalculateBulk(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <boolean>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(<any>null);
    }
}

export class UsersidetaskService {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    userSideGetTaskById(id: number | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/v1/usersidetask/user-side-get-task-by-id?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUserSideGetTaskById(_response);
        });
    }

    protected processUserSideGetTaskById(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param setupModuleId (optional) 
     * @return Success
     */
    userSideGetTaskIdsFromSetupModule(setupModuleId: number | null | undefined): Promise<number[]> {
        let url_ = this.baseUrl + "/api/v1/usersidetask/user-side-get-task-ids-from-setup-module?";
        if (setupModuleId !== undefined)
            url_ += "setupModuleId=" + encodeURIComponent("" + setupModuleId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUserSideGetTaskIdsFromSetupModule(_response);
        });
    }

    protected processUserSideGetTaskIdsFromSetupModule(response: Response): Promise<number[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <number[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<number[]>(<any>null);
    }

    /**
     * @param popQuizId (optional) 
     * @return Success
     */
    userSideGetTaskIdsFromPopQuiz(popQuizId: number | null | undefined): Promise<number[]> {
        let url_ = this.baseUrl + "/api/v1/usersidetask/user-side-get-task-ids-from-pop-quiz?";
        if (popQuizId !== undefined)
            url_ += "popQuizId=" + encodeURIComponent("" + popQuizId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUserSideGetTaskIdsFromPopQuiz(_response);
        });
    }

    protected processUserSideGetTaskIdsFromPopQuiz(response: Response): Promise<number[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <number[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<number[]>(<any>null);
    }
}

export class UsersideTeamService {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param employeeId (optional) 
     * @return Success
     */
    getTeamById(employeeId: string | null | undefined): Promise<UserSideTeamModel> {
        let url_ = this.baseUrl + "/api/v1/userside-team/get-team-by-id?";
        if (employeeId !== undefined)
            url_ += "employeeId=" + encodeURIComponent("" + employeeId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetTeamById(_response);
        });
    }

    protected processGetTeamById(response: Response): Promise<UserSideTeamModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <UserSideTeamModel>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserSideTeamModel>(<any>null);
    }

    /**
     * @return Success
     */
    getTeamByToken(): Promise<UserSideTeamModel> {
        let url_ = this.baseUrl + "/api/v1/userside-team/get-team-by-token";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetTeamByToken(_response);
        });
    }

    protected processGetTeamByToken(response: Response): Promise<UserSideTeamModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <UserSideTeamModel>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserSideTeamModel>(<any>null);
    }

    /**
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @param keyword (optional) 
     * @return Success
     */
    getAllLeader(pageIndex: number | null | undefined, pageSize: number | null | undefined, keyword: string | null | undefined): Promise<UserSideTeamResponseModel> {
        let url_ = this.baseUrl + "/api/v1/userside-team/get-all-leader?";
        if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&"; 
        if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&"; 
        if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllLeader(_response);
        });
    }

    protected processGetAllLeader(response: Response): Promise<UserSideTeamResponseModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <UserSideTeamResponseModel>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserSideTeamResponseModel>(<any>null);
    }

    /**
     * @param teams (optional) 
     * @return Success
     */
    rotateTeam(teamId: number, teams: any[] | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/v1/userside-team/rotate-team/{teamId}";
        if (teamId === undefined || teamId === null)
            throw new Error("The parameter 'teamId' must be defined.");
        url_ = url_.replace("{teamId}", encodeURIComponent("" + teamId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (teams !== null && teams !== undefined)
            content_.append("teams", teams.toString());

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRotateTeam(_response);
        });
    }

    protected processRotateTeam(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param employeeId (optional) 
     * @return Success
     */
    deleteTeam(employeeId: string | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/v1/userside-team/delete-team?";
        if (employeeId !== undefined)
            url_ += "employeeId=" + encodeURIComponent("" + employeeId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteTeam(_response);
        });
    }

    protected processDeleteTeam(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param nextTeamId (optional) 
     * @param employeeId (optional) 
     * @return Success
     */
    submitRotateByToken(nextTeamId: number | null | undefined, employeeId: string | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/v1/userside-team/submit-rotate-by-token?";
        if (nextTeamId !== undefined)
            url_ += "nextTeamId=" + encodeURIComponent("" + nextTeamId) + "&"; 
        if (employeeId !== undefined)
            url_ += "employeeId=" + encodeURIComponent("" + employeeId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSubmitRotateByToken(_response);
        });
    }

    protected processSubmitRotateByToken(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }
}

export class UsersideTeamCourseService {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @param keyword (optional) 
     * @return Success
     */
    byToken(pageIndex: number | null | undefined, pageSize: number | null | undefined, keyword: string | null | undefined): Promise<UserSideMyProfileCourseResponseModel> {
        let url_ = this.baseUrl + "/api/v1/userside-team-course/by-token?";
        if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&"; 
        if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&"; 
        if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processByToken(_response);
        });
    }

    protected processByToken(response: Response): Promise<UserSideMyProfileCourseResponseModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <UserSideMyProfileCourseResponseModel>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserSideMyProfileCourseResponseModel>(<any>null);
    }
}

export class UsersideTeamMappingService {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param teamId (optional) 
     * @return Success
     */
    getTeamPosition(teamId: number | null | undefined): Promise<UserSidePositionModel[]> {
        let url_ = this.baseUrl + "/api/v1/userside-team-mapping/get-team-position?";
        if (teamId !== undefined)
            url_ += "teamId=" + encodeURIComponent("" + teamId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetTeamPosition(_response);
        });
    }

    protected processGetTeamPosition(response: Response): Promise<UserSidePositionModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <UserSidePositionModel[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserSidePositionModel[]>(<any>null);
    }

    /**
     * @param teamId (optional) 
     * @param positionId (optional) 
     * @return Success
     */
    getTeamMappingById(teamId: number | null | undefined, positionId: number | null | undefined): Promise<UserSideTeamMappingModel> {
        let url_ = this.baseUrl + "/api/v1/userside-team-mapping/get-team-mapping-by-id?";
        if (teamId !== undefined)
            url_ += "teamId=" + encodeURIComponent("" + teamId) + "&"; 
        if (positionId !== undefined)
            url_ += "positionId=" + encodeURIComponent("" + positionId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetTeamMappingById(_response);
        });
    }

    protected processGetTeamMappingById(response: Response): Promise<UserSideTeamMappingModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <UserSideTeamMappingModel>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserSideTeamMappingModel>(<any>null);
    }

    /**
     * @param teamId (optional) 
     * @param positionName (optional) 
     * @return Success
     */
    getTeamMappingByPositionName(teamId: number | null | undefined, positionName: string | null | undefined): Promise<UserSideTeamMappingModel> {
        let url_ = this.baseUrl + "/api/v1/userside-team-mapping/get-team-mapping-by-position-name?";
        if (teamId !== undefined)
            url_ += "teamId=" + encodeURIComponent("" + teamId) + "&"; 
        if (positionName !== undefined)
            url_ += "positionName=" + encodeURIComponent("" + positionName) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetTeamMappingByPositionName(_response);
        });
    }

    protected processGetTeamMappingByPositionName(response: Response): Promise<UserSideTeamMappingModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <UserSideTeamMappingModel>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserSideTeamMappingModel>(<any>null);
    }
}

export class UsersideTimeTableService {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getFilterValue(): Promise<UserSideTimeTableFilterValueModel> {
        let url_ = this.baseUrl + "/api/v1/userside-time-table/get-filter-value";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetFilterValue(_response);
        });
    }

    protected processGetFilterValue(response: Response): Promise<UserSideTimeTableFilterValueModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <UserSideTimeTableFilterValueModel>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserSideTimeTableFilterValueModel>(<any>null);
    }
}

export class UsersideTrainingService {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param trainingId (optional) 
     * @return Success
     */
    getTrainingById(trainingId: number | null | undefined): Promise<UserSideTrainingModel> {
        let url_ = this.baseUrl + "/api/v1/userside-training/get-training-by-id?";
        if (trainingId !== undefined)
            url_ += "trainingId=" + encodeURIComponent("" + trainingId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetTrainingById(_response);
        });
    }

    protected processGetTrainingById(response: Response): Promise<UserSideTrainingModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <UserSideTrainingModel>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserSideTrainingModel>(<any>null);
    }

    /**
     * @return Success
     */
    getAllTraining(): Promise<UserSideTrainingModel> {
        let url_ = this.baseUrl + "/api/v1/userside-training/get-all-training";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllTraining(_response);
        });
    }

    protected processGetAllTraining(response: Response): Promise<UserSideTrainingModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <UserSideTrainingModel>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserSideTrainingModel>(<any>null);
    }

    /**
     * @param trainingId (optional) 
     * @param employeeId (optional) 
     * @return Success
     */
    getEvaluateTrainee(trainingId: number | null | undefined, employeeId: string | null | undefined): Promise<UserSideEmployeeTrainingModel> {
        let url_ = this.baseUrl + "/api/v1/userside-training/get-evaluate-trainee?";
        if (trainingId !== undefined)
            url_ += "trainingId=" + encodeURIComponent("" + trainingId) + "&"; 
        if (employeeId !== undefined)
            url_ += "employeeId=" + encodeURIComponent("" + employeeId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetEvaluateTrainee(_response);
        });
    }

    protected processGetEvaluateTrainee(response: Response): Promise<UserSideEmployeeTrainingModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <UserSideEmployeeTrainingModel>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserSideEmployeeTrainingModel>(<any>null);
    }

    /**
     * @param trainingId (optional) 
     * @return Success
     */
    getEvaluateTraineeByToken(trainingId: number | null | undefined): Promise<UserSideEmployeeTrainingModel> {
        let url_ = this.baseUrl + "/api/v1/userside-training/get-evaluate-trainee-by-token?";
        if (trainingId !== undefined)
            url_ += "trainingId=" + encodeURIComponent("" + trainingId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetEvaluateTraineeByToken(_response);
        });
    }

    protected processGetEvaluateTraineeByToken(response: Response): Promise<UserSideEmployeeTrainingModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <UserSideEmployeeTrainingModel>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserSideEmployeeTrainingModel>(<any>null);
    }

    /**
     * @param userSideEvaluationModels (optional) 
     * @return Success
     */
    insertScore(userSideEvaluationModels: UserSideEvaluationModel[] | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/v1/userside-training/insert-score";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(userSideEvaluationModels);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processInsertScore(_response);
        });
    }

    protected processInsertScore(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param employeeId (optional) 
     * @return Success
     */
    getAllTrainingByEmployeeId(employeeId: string | null | undefined): Promise<UserSideTrainingModel> {
        let url_ = this.baseUrl + "/api/v1/userside-training/get-all-training-by-employeeId?";
        if (employeeId !== undefined)
            url_ += "employeeId=" + encodeURIComponent("" + employeeId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllTrainingByEmployeeId(_response);
        });
    }

    protected processGetAllTrainingByEmployeeId(response: Response): Promise<UserSideTrainingModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <UserSideTrainingModel>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserSideTrainingModel>(<any>null);
    }

    /**
     * @return Success
     */
    getAllTrainingByToken(): Promise<UserSideTrainingModel> {
        let url_ = this.baseUrl + "/api/v1/userside-training/get-all-training-by-token";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllTrainingByToken(_response);
        });
    }

    protected processGetAllTrainingByToken(response: Response): Promise<UserSideTrainingModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <UserSideTrainingModel>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserSideTrainingModel>(<any>null);
    }
}

export class UsersideUploadCertificateService {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param fileUploaded_Base64 (optional) 
     * @param fileUploaded_FileName (optional) 
     * @param fileUploaded_ContentType (optional) 
     * @return Success
     */
    uploadCertificateByToken(title: string, type: string, eventDate: Date, trainingName: string, host: string, venue: string, fileUploaded_Base64: string | null | undefined, fileUploaded_FileName: string | null | undefined, fileUploaded_ContentType: string | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/v1/userside-upload-certificate/UploadCertificateByToken";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (title === null || title === undefined)
            throw new Error("The parameter 'title' cannot be null.");
        else
            content_.append("Title", title.toString());
        if (type === null || type === undefined)
            throw new Error("The parameter 'type' cannot be null.");
        else
            content_.append("Type", type.toString());
        if (eventDate === null || eventDate === undefined)
            throw new Error("The parameter 'eventDate' cannot be null.");
        else
            content_.append("EventDate", eventDate.toJSON());
        if (trainingName === null || trainingName === undefined)
            throw new Error("The parameter 'trainingName' cannot be null.");
        else
            content_.append("TrainingName", trainingName.toString());
        if (host === null || host === undefined)
            throw new Error("The parameter 'host' cannot be null.");
        else
            content_.append("Host", host.toString());
        if (venue === null || venue === undefined)
            throw new Error("The parameter 'venue' cannot be null.");
        else
            content_.append("Venue", venue.toString());
        if (fileUploaded_Base64 !== null && fileUploaded_Base64 !== undefined)
            content_.append("FileUploaded.Base64", fileUploaded_Base64.toString());
        if (fileUploaded_FileName !== null && fileUploaded_FileName !== undefined)
            content_.append("FileUploaded.FileName", fileUploaded_FileName.toString());
        if (fileUploaded_ContentType !== null && fileUploaded_ContentType !== undefined)
            content_.append("FileUploaded.ContentType", fileUploaded_ContentType.toString());

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUploadCertificateByToken(_response);
        });
    }

    protected processUploadCertificateByToken(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }
}

export class UsersideUseraccesstimeService {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    employeeStartAccessTime(): Promise<string> {
        let url_ = this.baseUrl + "/api/v1/userside-useraccesstime/employee-start-access-time";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processEmployeeStartAccessTime(_response);
        });
    }

    protected processEmployeeStartAccessTime(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <string>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(<any>null);
    }

    /**
     * @param employeeAccesTimeId (optional) 
     * @return Success
     */
    employeeEndAccessTime(employeeAccesTimeId: number | null | undefined): Promise<string> {
        let url_ = this.baseUrl + "/api/v1/userside-useraccesstime/employee-end-access-time?";
        if (employeeAccesTimeId !== undefined)
            url_ += "employeeAccesTimeId=" + encodeURIComponent("" + employeeAccesTimeId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processEmployeeEndAccessTime(_response);
        });
    }

    protected processEmployeeEndAccessTime(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <string>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(<any>null);
    }
}

export interface ApprovalContentFilterModel {
    page?: number | undefined;
    itemPage?: number | undefined;
    startDate?: Date | undefined;
    endDate?: Date | undefined;
    contentName?: string | undefined;
    contentCategory?: string | undefined;
    createdBy?: string | undefined;
    contentPosition?: string | undefined;
    approvalStatus?: string | undefined;
    orderBy?: string | undefined;
}

export interface ResponseApprovalContentModel {
    totalData?: number | undefined;
    contentList?: ApprovalContentViewModel[] | undefined;
}

export interface ApprovalContentViewModel {
    approvalId?: number | undefined;
    detailId?: number | undefined;
    contentName?: string | undefined;
    currentLevel?: number | undefined;
    contentCategory?: string | undefined;
    createdBy?: string | undefined;
    position?: string | undefined;
    approvalBy?: string | undefined;
    approvalDate?: Date | undefined;
    createdAt?: Date | undefined;
    approvalStatus?: string | undefined;
    isApprovableByUser?: boolean | undefined;
}

export interface InboxRejectedModel {
    approvalId?: number | undefined;
    message?: string | undefined;
}

export interface ApprovalMappingViewModel {
    listApprovalMapping?: ApprovalMappingModel[] | undefined;
    totalData?: number | undefined;
}

export interface ApprovalMappingModel {
    approvalMappingid?: number | undefined;
    pageId?: string | undefined;
    createdAt?: Date | undefined;
    updatedAt?: Date | undefined;
    approvalLevelId?: number | undefined;
    positionName?: string | undefined;
    pageName?: string | undefined;
    description?: string | undefined;
}

export interface ApprovalMappingFormModel {
    approvalMappingid?: number | undefined;
    pageId: string;
    approvalLevelId?: number | undefined;
}

export interface PagesModel {
    pageId?: string | undefined;
    name?: string | undefined;
    needApproval?: boolean | undefined;
}

export interface ApprovalLevelModel {
    approvalLevelId?: number | undefined;
    name?: string | undefined;
    description?: string | undefined;
}

export interface ApprovalStatusViewModel {
    listApprovalStatusModel?: ApprovalStatusModel[] | undefined;
    totalItem?: number | undefined;
}

export interface ApprovalStatusModel {
    approvalId?: number | undefined;
    approvalName?: string | undefined;
}

export interface ApprovalTrainingViewModel {
    listApprovalTraining?: ApprovalTrainingModel[] | undefined;
    totalItem?: number | undefined;
}

export interface ApprovalTrainingModel {
    trainingId?: number | undefined;
    courseName?: string | undefined;
    programType?: string | undefined;
    batch?: number | undefined;
    enrolment?: number | undefined;
    quota?: number | undefined;
    trainingStartDate?: Date | undefined;
    trainingEndDate?: Date | undefined;
}

export interface ApprovalTrainingDetailViewModel {
    trainingId?: number | undefined;
    courseName?: string | undefined;
    programTypeName?: string | undefined;
    batch?: number | undefined;
    quota?: number | undefined;
    startDate?: Date | undefined;
    endDate?: Date | undefined;
    employees?: ApprovalTrainingEmployee[] | undefined;
    learningTypeId?: number | undefined;
}

export interface ApprovalTrainingEmployee {
    enrollLearningId?: number | undefined;
    employeeId?: string | undefined;
    employeeName?: string | undefined;
    dealerName?: string | undefined;
    outletName?: string | undefined;
    isJoined?: boolean | undefined;
    isLocked?: boolean | undefined;
    isDrafted?: boolean | undefined;
    trainingInvitationApprovalStatus?: number | undefined;
}

export interface TrainingInvitationModel {
    trainingId?: number | undefined;
    employeeIds?: string[] | undefined;
}

export interface AssessmentGridModel {
    assessments?: AssessmentGridViewModel[] | undefined;
    totalFilterData?: number | undefined;
}

export interface AssessmentGridViewModel {
    assessmentId?: number | undefined;
    assessmentName?: string | undefined;
    employeeName?: string | undefined;
    positionName?: string | undefined;
    outletName?: string | undefined;
    publisherName?: string | undefined;
    createdAt?: Date | undefined;
    updatedAt?: Date | undefined;
}

export interface AssessmentCreateModel {
    employeeId: string;
    assessmentName: string;
    publisher: string;
    description?: string | undefined;
    fileContent: FileContent;
}

export interface FileContent {
    base64?: string | undefined;
    fileName?: string | undefined;
    contentType?: string | undefined;
}

export interface AssessmentViewDetailModel {
    assessmentId?: number | undefined;
    assessmentName?: string | undefined;
    publisherName?: string | undefined;
    description?: string | undefined;
    dealer?: DealerDropdownModel | undefined;
    outlet?: OutletDropdownModel | undefined;
    position?: PositionDropdownModel | undefined;
    employee?: EmployeeDropdownModel | undefined;
    imageBlobId?: string | undefined;
    imageBlobName?: string | undefined;
    imageBlobMIME?: string | undefined;
}

export interface DealerDropdownModel {
    dealerId?: string | undefined;
    dealerName?: string | undefined;
}

export interface OutletDropdownModel {
    outletId?: string | undefined;
    outletName?: string | undefined;
}

export interface PositionDropdownModel {
    positionId?: number | undefined;
    positionName?: string | undefined;
}

export interface EmployeeDropdownModel {
    employeeId?: string | undefined;
    employeeName?: string | undefined;
}

export interface AssessmentUpdateModel {
    assessmentId?: number | undefined;
    employeeId: string;
    assessmentName: string;
    publisher: string;
    description?: string | undefined;
    blobId: string;
    fileContent?: FileContent | undefined;
}

export interface BannerViewModel {
    listBanner?: BannerModel[] | undefined;
    totalData?: number | undefined;
}

export interface BannerModel {
    bannerId?: number | undefined;
    bannerTypeId?: number | undefined;
    blobId?: string | undefined;
    name?: string | undefined;
    startDate?: Date | undefined;
    endDate?: Date | undefined;
    mobilePageId?: number | undefined;
    contentId?: number | undefined;
    description?: string | undefined;
    createdAt?: Date | undefined;
    createdBy?: string | undefined;
    updatedAt?: Date | undefined;
    actionAt?: Date | undefined;
    approvalStatusId?: number | undefined;
    bannerTypeName?: string | undefined;
    approvalStatus?: string | undefined;
    actionBy?: string | undefined;
    pageName?: string | undefined;
    blobName?: string | undefined;
    mime?: string | undefined;
}

export interface BannerFormModel {
    bannerId?: number | undefined;
    bannerTypeId?: number | undefined;
    blobId?: string | undefined;
    name: string;
    startDate?: Date | undefined;
    endDate?: Date | undefined;
    mobilePageId?: number | undefined;
    contentId?: number | undefined;
    description: string;
    createdAt?: Date | undefined;
    createdBy?: string | undefined;
    updatedAt?: Date | undefined;
    approvedAt?: Date | undefined;
    bannerTypeName?: string | undefined;
    approvalStatus?: string | undefined;
    actionBy?: string | undefined;
    insertType?: number | undefined;
    imageUpload?: FileContent | undefined;
}

export interface LandingPageViewModel {
    data?: LandingPageModel[] | [];
}

export interface LandingPageModel {
    onBoardingID?: string,
    sectionNumber?: number,
    onBoardingFileURL?: string,
    onBoardingFileType? :string,
    description?: string,
    title?: string,
    statusView?: boolean,
    isSelected?: boolean | false
}

export interface MobileMappingPage {
    mobilePageId?: number | undefined;
    name?: string | undefined;
}

export interface ContentModel {
    id?: number | undefined;
    name?: string | undefined;
}

export interface ApprovalStatusForBannerModel {
    approvalStatusId?: number | undefined;
    approvalName?: string | undefined;
}

//export interface KeyValuePair`2OfOfStringAndCoreLibAnd_0AndCulture=neutralAndPublicKeyToken=7cec85d7bea7798eAndOfStringValuesAndPrimitivesAnd_0AndCulture=neutralAndPublicKeyToken=adb9793829ddae60 {
//    readonly key?: string | undefined;
//    readonly value?: string[] | undefined;
//}

export interface FileModel {
    name?: string | undefined;
    mime?: string | undefined;
    fileUrl?: string | undefined;
}

export interface BlobModel {
    blobId?: string | undefined;
    name?: string | undefined;
    mime?: string | undefined;
}

export interface CalendarScheduleCourseModel {
    title?: string | undefined;
    start?: Date | undefined;
    end?: Date | undefined;
    className?: string | undefined;
}

export interface CoachesViewModel {
    listCoaches?: CoachesModel[] | undefined;
    totalData?: number | undefined;
}

export interface CoachesModel {
    coachId?: number | undefined;
    coachName?: string | undefined;
    category?: string | undefined;
    coachIsActive?: boolean | undefined;
    employeeId?: string | undefined;
    ebadgeId?: number | undefined;
    coachScheduleId?: number | undefined;
    startDateTime?: string | undefined;
    endDateTime?: string | undefined;
    topicId?: number | undefined;
    topicName?: string | undefined;
    ebadgeName?: string | undefined;
    updatedAt?: string | undefined;
    createdAt?: string | undefined;
    updatedAtDate?: Date | undefined;
    createdAtDate?: Date | undefined;
    startDateTimeDate?: Date | undefined;
    endDateTimeDate?: Date | undefined;
}

export interface ListEmployeeForCoach {
    listEmployee?: EmployeeForCoachModel[] | undefined;
}

export interface EmployeeForCoachModel {
    employeeId?: string | undefined;
    employeeName?: string | undefined;
}

export interface TopicsEbadgeJoinModelForCoach {
    ebadgeId?: number | undefined;
    ebadgeName?: string | undefined;
    topicId?: number | undefined;
    topicName?: string | undefined;
}

export interface CoachFormModel {
    coachId?: number | undefined;
    coachName: string;
    category: string;
    categoryDetail: string;
    coachIsActive?: boolean | undefined;
    employeeId: string;
    createdAt?: Date | undefined;
    updatedAt?: Date | undefined;
    coachSchedule: CoachSchedulesFormModel[];
    topicId: number[];
}

export interface CoachSchedulesFormModel {
    coachScheduleId?: number | undefined;
    startDateTime?: string | undefined;
    startDate?: string | undefined;
    startDateTimeDate?: Date | undefined;
    endDateTime?: string | undefined;
    endDateTimeDate?: Date | undefined;
}

export interface CoachViewDetail {
    listTopicEbadge?: TopicsEbadgeJoinModelForCoach[] | undefined;
    listCoachSchedule?: CoachSchedulesFormModel[] | undefined;
}

export interface CoachDeleteFormModel {
    scheduleId?: number[] | undefined;
    topicId?: number[] | undefined;
    coachId?: number | undefined;
    deleteAll?: boolean | undefined;
}

export interface CompetencyJoinViewModel {
    listCompetencyJoinModel?: CompetencyJoinModel[] | undefined;
    totalItem?: number | undefined;
}

export interface CompetencyJoinModel {
    competencyId?: number | undefined;
    competencyTypeId?: number | undefined;
    competencyTypeName?: string | undefined;
    keyActionCode?: string | undefined;
    prefixCode?: string | undefined;
    competencyName?: string | undefined;
    competencyDescription?: string | undefined;
    createdAt?: Date | undefined;
    updatedAt?: Date | undefined;
    competencyKeyActionMappings?: CompetencyKeyActionMappingJoinModel[] | undefined;
}

export interface CompetencyKeyActionMappingJoinModel {
    competencyId?: number | undefined;
    keyActionId?: number | undefined;
    keyActionCode?: string | undefined;
}

export interface CompetencyFormModel {
    competencyId?: number | undefined;
    competencyTypeId?: number | undefined;
    prefixCode: string;
    competencyName: string;
    competencyDescription?: string | undefined;
    createdAt?: Date | undefined;
    updatedAt?: Date | undefined;
    competencyKeyActionMappings?: CompetencyKeyActionMappingModel[] | undefined;
}

export interface CompetencyKeyActionMappingModel {
    competencyId?: number | undefined;
    keyActionId?: number | undefined;
}

export interface CompetencyModel {
    competencyId?: number | undefined;
    competencyTypeId?: number | undefined;
    prefixCode?: string | undefined;
    competencyName?: string | undefined;
    competencyDescription?: string | undefined;
    createdAt?: Date | undefined;
    updatedAt?: Date | undefined;
}

export interface CompetencyMappingPaginate {
    data?: CompetencyMapping[] | undefined;
    totalData?: number | undefined;
}

export interface CompetencyMapping {
    competencyId?: number | undefined;
    evaluationTypeId?: number | undefined;
    competencyMappingCode?: string | undefined;
    competencyName?: string | undefined;
    typeofEvaluation?: string | undefined;
    bonusScoreLt50?: number | undefined;
    bonusScoreMte50?: number | undefined;
    createdAt?: Date | undefined;
    updatedAt?: Date | undefined;
}

export interface CompetencyMappingInsertModel {
    competencyId?: number | undefined;
    evaluationTypeId?: number | undefined;
    bonusScoreLt50?: number | undefined;
    bonusScoreMte50?: number | undefined;
}

export interface CompetencyTypeViewModel {
    listCompetencyTypeModel?: CompetencyTypeModel[] | undefined;
    totalItem?: number | undefined;
}

export interface CompetencyTypeModel {
    competencyTypeId?: number | undefined;
    competencyTypeName?: string | undefined;
}

export interface CourseJoinViewModel {
    listCourseJoinModel?: CourseJoinModel[] | undefined;
    totalItem?: number | undefined;
}

export interface CourseJoinModel {
    courseId?: number | undefined;
    programTypeId?: number | undefined;
    levelId?: number | undefined;
    courseCategoryId?: number | undefined;
    learningTypeId?: number | undefined;
    blobId?: string | undefined;
    approvalId?: number | undefined;
    programTypeName?: string | undefined;
    levelName?: string | undefined;
    courseCategoryName?: string | undefined;
    learningName?: string | undefined;
    mime?: string | undefined;
    fileName?: string | undefined;
    approvalName?: string | undefined;
    courseName?: string | undefined;
    coursePrice?: number | undefined;
    courseDescription?: string | undefined;
    others?: string | undefined;
    isRecommendedForYou?: boolean | undefined;
    isPopular?: boolean | undefined;
    isPublished?: boolean | undefined;
    createdBy?: string | undefined;
    createdAt?: Date | undefined;
    updatedAt?: Date | undefined;
    isDeleted?: boolean | undefined;
    courseApprovedAt?: Date | undefined;
    setupCourseApprovedAt?: Date | undefined;
}

export interface CourseFormModel {
    courseId?: number | undefined;
    programTypeId?: number | undefined;
    levelId?: number | undefined;
    courseCategoryId?: number | undefined;
    learningTypeId?: number | undefined;
    blobId?: string | undefined;
    approvalId?: number | undefined;
    courseName: string;
    coursePrice?: number | undefined;
    courseDescription?: string | undefined;
    others?: string | undefined;
    isRecommendedForYou?: boolean | undefined;
    isPopular?: boolean | undefined;
    isPublished?: boolean | undefined;
    createdBy?: string | undefined;
    createdAt?: Date | undefined;
    updatedAt?: Date | undefined;
    isDeleted?: boolean | undefined;
    imageUpload?: FileContent | undefined;
}

export interface CourseCategoryViewModel {
    listCourseCategoryModel?: CourseCategoryModel[] | undefined;
    totalItem?: number | undefined;
}

export interface CourseCategoryModel {
    courseCategoryId?: number | undefined;
    courseCategoryName?: string | undefined;
}

export interface DashboardApprovalListViewModel {
    listApproval?: DashboardApprovalData[] | undefined;
}

export interface DashboardApprovalData {
    approvalContent?: string | undefined;
    remaining?: number | undefined;
    completed?: number | undefined;
}

export interface DashboardUsersThisYearListViewModel {
    januaryUsersData?: number | undefined;
    februaryUsersData?: number | undefined;
    marchUsersData?: number | undefined;
    aprilUsersData?: number | undefined;
    mayUsersData?: number | undefined;
    juneUsersData?: number | undefined;
    julyUsersData?: number | undefined;
    augustUsersData?: number | undefined;
    septemberUsersData?: number | undefined;
    octoberUsersData?: number | undefined;
    novemberUsersData?: number | undefined;
    decemberUsersData?: number | undefined;
}

export interface DashboardClassListViewModel {
    thisWeekClassList?: DashboardClassData[] | undefined;
    totalThisWeekClass?: number | undefined;
    nextWeekClassList?: DashboardClassData[] | undefined;
    totalNextWeekClass?: number | undefined;
}

export interface DashboardClassData {
    courseName?: string | undefined;
    startDate?: Date | undefined;
    endDate?: Date | undefined;
}

export interface SetupTSLViewModel {
    sales?: Sales | undefined;
    afterSales?: AfterSales | undefined;
    total?: TotalSales | undefined;
}

export interface Sales {
    basicLevel?: number | undefined;
    fundamentalLevel?: number | undefined;
    advanceLevel?: number | undefined;
}

export interface AfterSales {
    basicLevel?: number | undefined;
    fundamentalLevel?: number | undefined;
    advanceLevel?: number | undefined;
}

export interface TotalSales {
    basicLevel?: number | undefined;
    fundamentalLevel?: number | undefined;
    advanceLevel?: number | undefined;
}

export interface PositionNameModel {
    positionName?: string | undefined;
}

export interface DashboardCompetencyMappingModel {
    hardCompetency?: CompetencyMappingModel[] | undefined;
    softCompetency?: CompetencyMappingModel[] | undefined;
}

export interface CompetencyMappingModel {
    prefixCode?: string | undefined;
    proficiencyLevel?: number | undefined;
    scoreTotal?: number | undefined;
    maxScoreTotal?: number | undefined;
}

export interface DashboardTop5TopicViewModel {
    topicsList?: DashboardTop5TopicData[] | undefined;
}

export interface DashboardTop5TopicData {
    topicName?: string | undefined;
    topicTotal?: number | undefined;
}

export interface DashboardTop5LearningViewModel {
    learningsList?: DashboardTop5LearningData[] | undefined;
}

export interface DashboardTop5LearningData {
    courseName?: string | undefined;
    rating?: number | undefined;
}

export interface DashboardTotalLearningLibraryViewModel {
    total?: number | undefined;
    totalCourses?: number | undefined;
    totalTask?: number | undefined;
    totalModules?: number | undefined;
    totalPopQuiz?: number | undefined;
}

export interface DashboardTop5NewsViewModel {
    topNewsList?: DashboardTop5NewsData[] | undefined;
}

export interface DashboardTop5NewsData {
    title?: string | undefined;
}

export interface DashboardTop5EventsViewModel {
    topEventsList?: DashboardTop5EventsData[] | undefined;
}

export interface DashboardTop5EventsData {
    title?: string | undefined;
}

export interface DashboardTop5CoachViewModel {
    coachList?: DashboardTop5CoachData[] | undefined;
}

export interface DashboardTop5CoachData {
    coachName?: string | undefined;
    rating?: number | undefined;
}

export interface DashboardTop5RewardTypeViewModel {
    topRewardTypeList?: DashboardTop5RewardTypeData[] | undefined;
}

export interface DashboardTop5RewardTypeData {
    rewardType?: string | undefined;
    totalReward?: number | undefined;
}

export interface DashboardNPSReportViewModel {
    promotor?: number | undefined;
    passive?: number | undefined;
    detractors?: number | undefined;
}

export interface DashboardMyInsightViewModel {
    thisMonth?: DashboardMyInsightData | undefined;
    lastMonth?: DashboardMyInsightData | undefined;
    last2Month?: DashboardMyInsightData | undefined;
}

export interface DashboardMyInsightData {
    getMonth?: string | undefined;
    totalInsight?: number | undefined;
}

export interface DigitalSignatureViewModel {
    listDigitalSignature?: DigitalSignatureJoinedModel[] | undefined;
    totalItem?: number | undefined;
}

export interface DigitalSignatureJoinedModel {
    digitalSignatureId?: number | undefined;
    employeeId?: string | undefined;
    employeeName?: string | undefined;
    blobId?: string | undefined;
    blobName?: string | undefined;
    createdAt?: Date | undefined;
    updatedAt?: Date | undefined;
    mime?: string | undefined;
    isDeleted?: boolean | undefined;
}

export interface DigitalSignatureFormModel {
    digitalSignatureId?: number | undefined;
    employeeId: string;
    blobId?: string | undefined;
    createdAt?: Date | undefined;
    updatedAt?: Date | undefined;
    isDeleted?: boolean | undefined;
    fileContent?: FileContent | undefined;
}

export interface RewardTypeDropdownModel {
    rewardTypeId?: number | undefined;
    rewardTypeName?: string | undefined;
}

export interface ModuleDropdownModel {
    moduleId?: number | undefined;
    moduleName?: string | undefined;
}

export interface CoachDropdownModel {
    coachId?: number | undefined;
    coachName?: string | undefined;
}

export interface EventDropdownModel {
    eventId?: number | undefined;
    eventName?: string | undefined;
}

export interface RewardPointTypeDropdown {
    rewardPointTypeId?: number | undefined;
    rewardPointTypeName?: string | undefined;
}

export interface MaterialTypeDropdownModel {
    materialTypeId?: number | undefined;
    materialTypeName?: string | undefined;
}

export interface TopicDropdownModel {
    topicId?: number | undefined;
    topicName?: string | undefined;
}

export interface ApprovalStatusDropdownModel {
    statusId?: number | undefined;
    statusName?: string | undefined;
}

export interface DropDownModel {
    id?: number | undefined;
    name?: string | undefined;
}

export interface EmployeeListViewModel {
    employeeList?: EmployeeViewModel[] | undefined;
}

export interface EmployeeViewModel {
    employeeId?: string | undefined;
    outletId?: string | undefined;
    employeeUsername?: string | undefined;
    employeeName?: string | undefined;
    employeeExperience?: number | undefined;
    employeeEmail?: string | undefined;
    employeePhone?: string | undefined;
    lastSeenAt?: Date | undefined;
    createdAt?: Date | undefined;
    createdBy?: string | undefined;
    updatedAt?: Date | undefined;
    updatedBy?: string | undefined;
    isDeleted?: boolean | undefined;
}

export interface EmployeeFormModel {
    employeeId?: string | undefined;
    outletId?: string | undefined;
    employeeUsername: string;
    employeeName: string;
    employeeExperience?: number | undefined;
    employeeEmail?: string | undefined;
    employeePhone?: string | undefined;
    lastSeenAt?: Date | undefined;
    createdAt?: Date | undefined;
    createdBy: string;
    updatedAt?: Date | undefined;
    updatedBy: string;
    isDeleted?: boolean | undefined;
}

export interface EvaluationTypesViewModel {
    evaluationTypeId?: number | undefined;
    evaluationTypeName?: string | undefined;
}

export interface EventJoinViewModel {
    listEventJoinModel?: EventJoinModel[] | undefined;
    totalItem?: number | undefined;
}

export interface EventJoinModel {
    eventId?: number | undefined;
    eventCategoryId?: number | undefined;
    eventCategoryName?: string | undefined;
    blobId?: string | undefined;
    fileName?: string | undefined;
    mime?: string | undefined;
    eventName?: string | undefined;
    startDateTime?: Date | undefined;
    endDateTime?: Date | undefined;
    eventHostName?: string | undefined;
    location?: string | undefined;
    eventDescription?: string | undefined;
    createdAt?: Date | undefined;
    updatedAt?: Date | undefined;
    approvedAt?: Date | undefined;
    isDeleted?: boolean | undefined;
    approvalStatus?: string | undefined;
    approvalId?: number | undefined;
    listEventOutlets?: EventOutletModel[] | undefined;
    listEventPositions?: EventPositionModel[] | undefined;
    listEventAreaIds?: string[] | undefined;
    listEventCityIds?: string[] | undefined;
    listEventDealerIds?: string[] | undefined;
    listEventProvinceIds?: string[] | undefined;
    listEventRegionIds?: EventRegionModel[] | undefined;
    imageUpload?: FileContent | undefined;
}

export interface EventOutletModel {
    eventId?: number | undefined;
    outletId?: string | undefined;
}

export interface EventPositionModel {
    eventId?: number | undefined;
    positionId?: number | undefined;
}

export interface EventRegionModel {
    regionId?: number | undefined;
}

export interface EventFormModel {
    eventId?: number | undefined;
    eventCategoryId?: number | undefined;
    blobId?: string | undefined;
    eventName: string;
    startDateTime?: Date | undefined;
    endDateTime?: Date | undefined;
    eventHostName: string;
    location: string;
    eventDescription?: string | undefined;
    createdAt?: Date | undefined;
    updatedAt?: Date | undefined;
    isDeleted?: boolean | undefined;
    approvalId?: number | undefined;
    listEventOutlets?: EventOutletModel[] | undefined;
    listEventPositions?: EventPositionModel[] | undefined;
    imageUpload?: FileContent | undefined;
}

export interface EventCategoryViewModel {
    listEventCategoryModel?: EventCategoryModel[] | undefined;
    totalItem?: number | undefined;
}

export interface EventCategoryModel {
    eventCategoryId?: number | undefined;
    eventCategoryName?: string | undefined;
    eventCategoryDescription?: string | undefined;
    createdAt?: Date | undefined;
    updatedAt?: Date | undefined;
}

export interface EventCategoryFormModel {
    eventCategoryId?: number | undefined;
    eventCategoryName: string;
    eventCategoryDescription?: string | undefined;
    createdAt?: Date | undefined;
    updatedAt?: Date | undefined;
}

export interface GuideJoinViewModel {
    listGuideJoinModel?: GuideJoinModel[] | undefined;
    totalItem?: number | undefined;
}

export interface GuideJoinModel {
    guideId?: number | undefined;
    guideTypeId?: number | undefined;
    guideTypeName?: string | undefined;
    blobId?: string | undefined;
    fileName?: string | undefined;
    mime?: string | undefined;
    name?: string | undefined;
    description?: string | undefined;
    createdAt?: Date | undefined;
    createdBy?: string | undefined;
    updatedAt?: Date | undefined;
    approvedAt?: Date | undefined;
    approvalStatus?: string | undefined;
    isSelected?: boolean | false;
}

export interface GuideFormModel {
    guideId?: number | undefined;
    guideTypeId?: number | undefined;
    blobId?: string | undefined;
    name: string;
    description?: string | undefined;
    createdAt?: Date | undefined;
    createdBy: string;
    updatedAt?: Date | undefined;
    approvedAt?: Date | undefined;
    approvalId?: number | undefined;
    fileContent?: FileContent | undefined;
}

export interface GuideTypeViewModel {
    listGuideTypeModel?: GuideTypeModel[] | undefined;
    totalItem?: number | undefined;
}

export interface GuideTypeModel {
    guideTypeId?: number | undefined;
    name?: string | undefined;
}

export interface HobbyGridModel {
    grid?: HobbyGridViewModel[] | undefined;
    totalFilterData?: number | undefined;
    totalData?: number | undefined;
}

export interface HobbyGridViewModel {
    hobbyId?: number | undefined;
    hobbyName?: string | undefined;
    hobbyDescription?: string | undefined;
    createdAt?: Date | undefined;
    updatedAt?: Date | undefined;
}

export interface HobbyCreateModel {
    hobbyName: string;
    hobbyDescription?: string | undefined;
}

export interface HobbyViewModel {
    hobbyId?: number | undefined;
    hobbyName?: string | undefined;
    hobbyDescription?: string | undefined;
}

export interface HobbyUpdateModel {
    hobbyId?: number | undefined;
    hobbyName: string;
    hobbyDescription?: string | undefined;
}

export interface InboxViewModel {
    listInbox?: InboxModel[] | undefined;
    totalData?: number | undefined;
}

export interface InboxModel {
    inboxId?: number | undefined;
    employeeId?: string | undefined;
    title?: string | undefined;
    message?: string | undefined;
    linkToPage?: string | undefined;
    approvalId?: number | undefined;
    createdAt?: Date | undefined;
    createdBy?: string | undefined;
    isRead?: boolean | undefined;
    isDone?: boolean | undefined;
    employeeName?: string | undefined;
}

export interface ApprovalInboxModel {
    approvalId?: number | undefined;
    contentName?: string | undefined;
    contentCategory?: string | undefined;
    createdBy?: string | undefined;
    createdAt?: Date | undefined;
    linkToPage?: string | undefined;
    message?: string | undefined;
    inboxId?: number | undefined;
    title?: string | undefined;
    userName?: string | undefined;
    userPosition?: string | undefined;
    isDone?: boolean | undefined;
    approvalLevel?: number | undefined;
}

export interface KeyActionViewModel {
    listActionModel?: KeyActionModel[] | undefined;
    totalItem?: number | undefined;
}

export interface KeyActionModel {
    keyActionId?: number | undefined;
    keyActionCode?: string | undefined;
    keyActionName?: string | undefined;
    keyActionDescription?: string | undefined;
    createdAt?: Date | undefined;
    updatedAt?: Date | undefined;
}

export interface KeyActionFormModel {
    keyActionId?: number | undefined;
    keyActionCode: string;
    keyActionName: string;
    keyActionDescription?: string | undefined;
    createdAt?: Date | undefined;
    updatedAt?: Date | undefined;
}

export interface LearningTypeViewModel {
    listLearningTypeModel?: LearningTypeModel[] | undefined;
    totalItem?: number | undefined;
}

export interface LearningTypeModel {
    learningTypeId?: number | undefined;
    learningName?: string | undefined;
}

export interface LevelViewModel {
    listLevelModel?: LevelModel[] | undefined;
    totalItem?: number | undefined;
}

export interface LevelModel {
    levelId?: number | undefined;
    levelName?: string | undefined;
}

export interface MasterNewsFilterModel {
    page?: number | undefined;
    itemPage?: number | undefined;
    startDate?: Date | undefined;
    endDate?: Date | undefined;
    newsTitle?: string | undefined;
    newsCategory?: string | undefined;
    newsStatus?: string | undefined;
    orderBy?: string | undefined;
}

export interface ResponseMasterNewsModel {
    totalData?: number | undefined;
    contentList?: MasterNewsViewModel[] | undefined;
}

export interface MasterNewsViewModel {
    id?: number | undefined;
    createdDate?: Date | undefined;
    updatedDate?: Date | undefined;
    newsTitle?: string | undefined;
    newsCategory?: string | undefined;
    newsStatus?: string | undefined;
}

export interface MasterNewsFormModel {
    newsId?: number | undefined;
    createdDate?: Date | undefined;
    updatedDate?: Date | undefined;
    newsTitle?: string | undefined;
    newsLink?: string | undefined;
    author?: string | undefined;
    description?: string | undefined;
    newsCategoryId?: number | undefined;
    isDownloadable?: boolean | undefined;
    thumbnailBlobId?: string | undefined;
    fileBlobId?: string | undefined;
    thumbnailUpload?: FileContent | undefined;
    fileUpload?: FileContent | undefined;
}

export interface StagingUser {
    id?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    noReg?: string | undefined;
    email?: string | undefined;
    state: string;
}

export interface StagingActualOrganizationStructure {
    id?: number | undefined;
    code?: string | undefined;
    noReg?: string | undefined;
    postCode?: string | undefined;
    postName?: string | undefined;
    staffing?: number | undefined;
    state?: string | undefined;
    orgCode?: string | undefined;
    parentOrgCode?: string | undefined;
    orgName?: string | undefined;
    jobCode?: string | undefined;
    jobName?: string | undefined;
    muid?: string | undefined;
    versionName?: string | undefined;
    versionNumber?: number | undefined;
    versionId?: number | undefined;
    versionFlag?: string | undefined;
    name?: string | undefined;
    changeTrackingMask?: number | undefined;
    service?: string | undefined;
    employeeGroup?: string | undefined;
    employeeGroupText?: string | undefined;
    employeeSubgroup?: string | undefined;
    employeeSubgroupText?: string | undefined;
    workContract?: string | undefined;
    workContractText?: string | undefined;
    personalArea?: string | undefined;
    personalSubarea?: string | undefined;
    depthLevel?: number | undefined;
    chief?: number | undefined;
    orgLevel?: number | undefined;
    period?: Date | undefined;
    vacant?: number | undefined;
    structure?: string | undefined;
    objectDescription?: string | undefined;
    enterDateTime?: Date | undefined;
    enterUserName?: string | undefined;
    enterVersionNumber?: number | undefined;
    lastChgDateTime?: Date | undefined;
    lastChgUserName?: string | undefined;
    lastChgVersionNumber?: number | undefined;
    validationStatus?: string | undefined;
}

export interface StagingOrganizationObject {
    id?: number | undefined;
    code?: string | undefined;
    objectType?: string | undefined;
    objectId?: string | undefined;
    abbreviation?: string | undefined;
    objectText?: string | undefined;
    objectDescription?: string | undefined;
    state?: string | undefined;
}

export interface StagingDealerEmployee {
    code?: string | undefined;
    name?: string | undefined;
    outletId?: number | undefined;
    lastManpowerPositionTypeId?: string | undefined;
    manpowerStatusTypeId?: string | undefined;
    employeeId?: string | undefined;
    phone?: string | undefined;
    email?: string | undefined;
    state?: string | undefined;
    id?: number | undefined;
    manpowerTypeId?: string | undefined;
    sex?: string | undefined;
    ktp?: string | undefined;
    dateOfBirth?: Date | undefined;
}

export interface StagingManpowerPositionType {
    code?: string | undefined;
    name?: string | undefined;
    state: string;
    id?: number | undefined;
}

export interface StagingManpowerType {
    id?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    state?: string | undefined;
}

export interface StagingOutlet {
    code?: string | undefined;
    name?: string | undefined;
    dealerCompanyId?: number | undefined;
    outletFunctionId?: string | undefined;
    outletCode?: string | undefined;
    phoneNumber?: string | undefined;
    kabupatenId?: number | undefined;
    tamAreaId?: number | undefined;
    tamAreaAfterSalesId?: number | undefined;
    state: string;
    id?: number | undefined;
    regionCode?: number | undefined;
}

export interface StagingRegion {
    code?: string | undefined;
    parentCode?: number | undefined;
    name?: string | undefined;
    state: string;
    id?: number | undefined;
    regionType?: string | undefined;
}

export interface StagingSalesArea {
    code?: string | undefined;
    name?: string | undefined;
    state: string;
    id?: number | undefined;
}

export interface StagingAfterSalesArea {
    code?: string | undefined;
    name?: string | undefined;
    state: string;
    id?: number | undefined;
}

export interface StagingDealerGroup {
    code?: string | undefined;
    name?: string | undefined;
    dealerGroupCode?: string | undefined;
    state: string;
    id?: number | undefined;
}

export interface StagingDealerCompany {
    code?: string | undefined;
    name?: string | undefined;
    dealerGroupId?: number | undefined;
    state: string;
    id?: number | undefined;
}

export interface ModuleGridModel {
    modules?: ModuleGridViewModel[] | undefined;
    totalFilterData?: number | undefined;
}

export interface ModuleGridViewModel {
    moduleName?: string | undefined;
    moduleId?: number | undefined;
    typeMaterialName?: string | undefined;
    topicName?: string | undefined;
    approvalStatus?: string | undefined;
    createdAt?: Date | undefined;
    updatedAt?: Date | undefined;
}

export interface ModuleCreateModel {
    moduleName: string;
    moduleFileContent?: FileContent | undefined;
    moduleDesc?: string | undefined;
    materialTypeId: number;
    materialFileContent?: FileContent | undefined;
    link?: string | undefined;
    topicId: number[];
    downloadable: boolean;
    approvalStatusId: number;
}

export interface ModuleViewDetailModel {
    moduleId?: number | undefined;
    moduleName?: string | undefined;
    moduleDescription?: string | undefined;
    moduleBlobId?: string | undefined;
    moduleBlobName?: string | undefined;
    moduleBlobMIME?: string | undefined;
    materialType?: MaterialTypeDropdownModel | undefined;
    materialBlobId?: string | undefined;
    materialBlobName?: string | undefined;
    materialBlobMIME?: string | undefined;
    materialLink?: string | undefined;
    isDownloadable?: boolean | undefined;
    topics?: TopicDropdownModel[] | undefined;
    approvalStatusId?: number | undefined;
}

export interface ModuleUpdateModel {
    moduleId?: number | undefined;
    moduleName: string;
    moduleFileContent?: FileContent | undefined;
    moduleDesc?: string | undefined;
    materialTypeId: number;
    materialFileContent?: FileContent | undefined;
    link?: string | undefined;
    topicId: number[];
    downloadable: boolean;
    approvalStatusId: number;
}

export interface DeleteModuleModel {
    moduleId?: number | undefined;
    isDeleteModule?: boolean | undefined;
    topicIds?: number[] | undefined;
}

export interface PointTypeViewModel {
    pointTypeId?: number | undefined;
    pointTypeName?: string | undefined;
}

export interface PositionMapFormModel {
    positionMapId?: number | undefined;
    positionId?: number | undefined;
    positionName?: string | undefined;
    positionDescription?: string | undefined;
    competencyList?: PosCompetencyModel[] | undefined;
}

export interface PosCompetencyModel {
    competencyId?: number | undefined;
    competencyName?: string | undefined;
    priority?: string | undefined;
    proficiencyLevel?: number | undefined;
}

export interface PositionMapFilterModel {
    page?: number | undefined;
    itemPage?: number | undefined;
    startDate?: Date | undefined;
    endDate?: Date | undefined;
    positionName?: string | undefined;
    competencyName?: string | undefined;
    priority?: string | undefined;
    proficiencyLevel?: number | undefined;
    orderBy?: string | undefined;
}

export interface ResponsePositionMapModel {
    totalData?: number | undefined;
    contentList?: PositionMapViewModel[] | undefined;
}

export interface PositionMapViewModel {
    posCompetencyId?: number | undefined;
    positionId?: number | undefined;
    positionName?: string | undefined;
    competencyName?: string | undefined;
    priority?: string | undefined;
    proficiencyLevel?: number | undefined;
    createdAt?: Date | undefined;
    updateAt?: Date | undefined;
}

export interface PositionMapDeleteModel {
    positionId?: number | undefined;
    competencyListId?: number[] | undefined;
}

export interface ProgramTypeViewModel {
    listProgramTypeModel?: ProgramTypeModel[] | undefined;
    totalItem?: number | undefined;
}

export interface ProgramTypeModel {
    programTypeId?: number | undefined;
    programTypeName?: string | undefined;
}

export interface CourseReleaseTrainingModel {
    courseId?: number | undefined;
    courseName?: string | undefined;
    programTypeName?: string | undefined;
    learningTypeId?: number | undefined;
}

export interface ApprovalStatusViewModels {
    approvalId?: number | undefined;
    approvalName?: string | undefined;
}

export interface ReleaseTrainingSetupModuleModel {
    trainingTypesName?: string | undefined;
    moduleName?: string | undefined;
    setupModuleId?: number | undefined;
}

export interface ReleaseTrainingFormModel {
    trainingId?: number | undefined;
    course?: CourseReleaseTrainingModel | undefined;
    batch?: number | undefined;
    quota?: number | undefined;
    startDate?: Date | undefined;
    endDate?: Date | undefined;
    location?: string | undefined;
    isAccommodate?: boolean | undefined;
    isParticipantTrainee?: boolean | undefined;
    isParticipantPermanent?: boolean | undefined;
    listSetupModule?: TrainingModuleFormModel[] | undefined;
    listOutlet?: TrainingOutletFormModel[] | undefined;
    listPosition?: TrainingPositionModel[] | undefined;
    listPositionOnlyView?: TrainingPositionModel[] | undefined;
    inputType?: number | undefined;
    isCertificate?: boolean | false;
    enumCertificate?: string | undefined;
    enumCertificationTtrigger?: string | undefined;
    listCertifications?: any[] | undefined;
}

export interface TrainingModuleFormModel {
    trainingModuleMappingId?: number | undefined;
    trainingId?: number | undefined;
    trainingStart?: Date | undefined;
    trainingEnd?: Date | undefined;
    teachingTimePoint?: TeachingTimepPointsModel | undefined;
    coach?: CoachForReleaseTraining | undefined;
    setupModuleId?: number | undefined;
    trainingTypesName?: string | undefined;
    moduleName?: string | undefined;
}

export interface TrainingOutletFormModel {
    trainingId?: number | undefined;
    outletId?: string | undefined;
}

export interface TrainingPositionModel {
    trainingId?: number | undefined;
    positionId?: number | undefined;
}

export interface TeachingTimepPointsModel {
    timePointId?: number | undefined;
    time?: number | undefined;
    points?: number | undefined;
}

export interface CoachForReleaseTraining {
    employeeName?: string | undefined;
    employeeId?: string | undefined;
    coachId?: number | undefined;
}

export interface PositionViewModel {
    positionId?: number | undefined;
    positionName?: string | undefined;
}

export interface AreaViewModel {
    areaId?: string | undefined;
    name?: string | undefined;
}

export interface DealerViewModel {
    dealerId?: string | undefined;
    dealerName?: string | undefined;
}

export interface ProvinceViewModel {
    provinceId?: string | undefined;
    provinceName?: string | undefined;
}

export interface CityViewModel {
    cityId?: string | undefined;
    cityName?: string | undefined;
}

export interface OutletCompleteViewModel {
    outletId?: string | undefined;
    provinceId?: string | undefined;
    areaId?: string | undefined;
    cityId?: string | undefined;
    dealerId?: string | undefined;
    name?: string | undefined;
}

export interface OutletViewModel {
    outletId?: string | undefined;
    name?: string | undefined;
}

export interface ReleaseTrainingViewModel {
    listTraining?: ReleaseTrainingModel[] | undefined;
    totalData?: number | undefined;
}

export interface ReleaseTrainingModel {
    trainingId?: number | undefined;
    courseName?: string | undefined;
    batch?: number | undefined;
    startDate?: Date | undefined;
    endDate?: Date | undefined;
    isPublished?: boolean | undefined;
    createdAt?: Date | undefined;
    updatedAt?: Date | undefined;
    approvalStatus?: string | undefined;
}

export interface RelaseTrainingDetailModel {
    trainingId?: number | undefined;
    course?: CourseReleaseTrainingModel | undefined;
    batch?: number | undefined;
    startDate?: Date | undefined;
    endDate?: Date | undefined;
    quota?: number | undefined;
    location?: string | undefined;
    isAccommodate?: boolean | undefined;
    isParticipantPermanent?: boolean | undefined;
    isParticipantTrainee?: boolean | undefined;
    listSetupModule?: TrainingModuleFormModel[] | undefined;
    listOutlet?: OutletViewModel[] | undefined;
    listPosition?: PositionViewModel[] | undefined;
    listPositionOnlyView?: PositionViewModel[] | undefined;
    listArea?: AreaViewModel[] | undefined;
    listRegion?: RegionViewModel[] | undefined;
    listProvince?: ProvinceViewModel[] | undefined;
    listCity?: CityViewModel[] | undefined;
    listDealer?: DealerViewModel[] | undefined;
    isCertificate?: boolean | false;
    enumCertificate?: string | undefined;
    enumCertificationTrigger?: string | undefined;
    trainingCertificateView?: any[] | undefined;
}

export interface RegionViewModel {
    regionId?: number | undefined;
    regionName?: string | undefined;
}

export interface TotalCourseDetail {
    totalPoints?: number | undefined;
    totalModule?: number | undefined;
    totalTime?: number | undefined;
    totalScore?: number | undefined;
}

export interface ReportModel {
    italentReportId?: number | undefined;
    name?: string | undefined;
    url?: string | undefined;
}

export interface ReportNPSViewModel {
    reportNPSItems?: ReportNPSItemModel[] | undefined;
    totalData?: number | undefined;
}

export interface ReportNPSItemModel {
    trainingId?: number | undefined;
    programTypeId?: number | undefined;
    programTypeName?: string | undefined;
    courseName?: string | undefined;
    courseId?: number | undefined;
    startDate?: Date | undefined;
    endDate?: Date | undefined;
    batch?: number | undefined;
    status?: string | undefined;
    viewCourseUrl?: string | undefined;
    viewCoachUrl?: string | undefined;
}

export interface RewardGridModel {
    grid?: RewardGridViewModel[] | undefined;
    totalFilterData?: number | undefined;
}

export interface RewardGridViewModel {
    rewardId?: number | undefined;
    rewardName?: string | undefined;
    typeOfReward?: string | undefined;
    typeOfPoint?: string | undefined;
    status?: string | undefined;
    createdAt?: Date | undefined;
    updateAt?: Date | undefined;
}

export interface RewardCreateModel {
    rewardTypeId: number;
    moduleId?: number | undefined;
    coachId?: number | undefined;
    eventId?: number | undefined;
    rewardName: string;
    startDate?: Date | undefined;
    endDate?: Date | undefined;
    rewardRequiredTeachingPoints?: number | undefined;
    rewardRequiredTotalPoints?: number | undefined;
    rewardRequiredLearningPoints?: number | undefined;
    isActive: boolean;
    description?: string | undefined;
    termsAndConditions: string;
    howToUse: string;
}

export interface RewardViewDetailModel {
    rewardId?: number | undefined;
    rewardType?: RewardTypeDropdownModel | undefined;
    module?: ModuleDropdownModel | undefined;
    coach?: CoachDropdownModel | undefined;
    event?: EventDropdownModel | undefined;
    rewardName?: string | undefined;
    startDate?: Date | undefined;
    endDate?: Date | undefined;
    rewardRequiredTeachingPoints?: number | undefined;
    rewardRequiredTotalPoints?: number | undefined;
    rewardRequiredLearningPoints?: number | undefined;
    isActive?: boolean | undefined;
    description?: string | undefined;
    termsAndConditions?: string | undefined;
    howToUse?: string | undefined;
}

export interface RewardUpdateModel {
    rewardId?: number | undefined;
    rewardTypeId: number;
    moduleId?: number | undefined;
    coachId?: number | undefined;
    eventId?: number | undefined;
    rewardName: string;
    startDate?: Date | undefined;
    endDate?: Date | undefined;
    rewardRequiredTeachingPoints?: number | undefined;
    rewardRequiredTotalPoints?: number | undefined;
    rewardRequiredLearningPoints?: number | undefined;
    isActive: boolean;
    description?: string | undefined;
    termsAndConditions: string;
    howToUse: string;
}

export interface CourseViewModel {
    listCourseModel?: CourseModel[] | undefined;
    totalItem?: number | undefined;
}

export interface CourseModel {
    courseId?: number | undefined;
    programTypeId?: number | undefined;
    levelId?: number | undefined;
    courseCategoryId?: number | undefined;
    learningTypeId?: number | undefined;
    blobId?: string | undefined;
    approvalId?: number | undefined;
    courseName?: string | undefined;
    coursePrice?: number | undefined;
    courseDescription?: string | undefined;
    others?: string | undefined;
    isRecommendedForYou?: boolean | undefined;
    isPopular?: boolean | undefined;
    isPublished?: boolean | undefined;
    createdBy?: string | undefined;
    createdAt?: Date | undefined;
    updatedAt?: Date | undefined;
    isDeleted?: boolean | undefined;
    courseApprovedAt?: Date | undefined;
    setupCourseApprovedAt?: Date | undefined;
}

export interface ModuleForSetupModel {
    moduleId?: number | undefined;
    moduleName?: string | undefined;
}

export interface CoursePrerequisiteViewModel {
    nextCourseId?: number | undefined;
    nextSetupModuleId?: number | undefined;
    name?: string | undefined;
}

export interface CompetencyMappingJoinModel {
    competencyNameMapping?: string | undefined;
    competencyId?: number | undefined;
    evaluationTypeId?: number | undefined;
    competencyTypeId?: number | undefined;
    prefixCode?: string | undefined;
    competencyTypeName?: string | undefined;
    evaluationTypeName?: string | undefined;
}

export interface TaskForSetupModuleModel {
    taskCode?: string | undefined;
    taskId?: number | undefined;
    taskTypeId?: number | undefined;
    score?: number | undefined;
    points?: number | undefined;
}

export interface SetupCourseFormModel {
    courseId?: number | undefined;
    courseName?: string | undefined;
    programTypeName?: string | undefined;
    isRecommendedForYou?: boolean | undefined;
    isPopular?: boolean | undefined;
    approvalId?: number | undefined;
    listCourseTrainingTypeMappings?: CourseTrainingTypeMappingModel[] | undefined;
    listCoursePrerequisiteMappings?: CoursePrerequisiteViewModel[] | undefined;
    listCourseLearningObjectives?: CourseLearningObjectiveModel[] | undefined;
    listSetupModules?: SetupModuleFormModel[] | undefined;
}

export interface CourseTrainingTypeMappingModel {
    courseId?: number | undefined;
    trainingTypeId?: number | undefined;
    minimumScore?: number | undefined;
    workloadRequirement?: string | undefined;
    percentage?: number | undefined;
}

export interface CourseLearningObjectiveModel {
    learningObjectiveId?: number | undefined;
    courseId?: number | undefined;
    learningObjectiveName: string;
}

export interface SetupModuleFormModel {
    setupModuleId?: number | undefined;
    courseId?: number | undefined;
    moduleId?: number | undefined;
    moduleName?: string | undefined;
    moduleDescription?: string | undefined;
    trainingTypeId?: number | undefined;
    timePointId?: number | undefined;
    score?: number | undefined;
    points?: number | undefined;
    isRecommendedForYou?: boolean | undefined;
    isPopular?: boolean | undefined;
    minimumScore?: number | undefined;
    isForRemedial?: boolean | undefined;
    setupTaskForm?: SetupTaskFormModel | undefined;
    inputType?: number | undefined;
    assesmentId?: any;
    order?: number | undefined;
    enumRemedialOption?: string,
    remedialLimit?: number,
    enumScoringMethod?: string,
    isByOption?: boolean,
    enumCategoryPreDuringPost?: string,
    assesmentList? : any | undefined,
}

export interface SetupTaskFormModel {
    setupTaskId?: number | undefined;
    setupModuleId?: number | undefined;
    popQuizId?: number | undefined;
    competencyId?: number | undefined;
    competencyNameMapping?: string | undefined;
    evaluationTypeId?: number | undefined;
    competencyTypeId?: number | undefined;
    prefixCode?: string | undefined;
    competencyTypeName?: string | undefined;
    evaluationTypeName?: string | undefined;
    moduleId?: number | undefined;
    moduleName?: string | undefined;
    moduleDescription?: string | undefined;
    testTime?: number | undefined;
    isGrouping?: boolean | undefined;
    totalParticipant?: number | undefined;
    totalQuestion?: number | undefined;
    questionPerParticipant?: number | undefined;
    taskList?: SetupTaskCodesFormModel[] | undefined;
}

export interface SetupTaskCodesFormModel {
    setupTaskId?: number | undefined;
    taskId?: number | undefined;
    questionNumber?: number | undefined;
    taskName?: string | undefined;
    taskCode?: string | undefined;
    taskTypeId?: number | undefined;
    score?: number | undefined;
    points?: number | undefined;
}

export interface SetupLearningPaginate {
    data?: SetupLearningModels[] | undefined;
    totalData?: number | undefined;
}

export interface SetupLearningModels {
    setupLearningId?: number | undefined;
    setupModuleId?: number | undefined;
    popQuizId?: number | undefined;
    courseId?: number | undefined;
    learningName?: string | undefined;
    programTypeName?: string | undefined;
    learningCategoryName?: string | undefined;
    approvalStatus?: string | undefined;
    createdAt?: Date | undefined;
    updatedAt?: Date | undefined;
    approvedAt?: Date | undefined;
}

export interface SetupLearningCourseLockUnlock {
    courseId?: number | undefined;
    courseName?: string | undefined;
    programTypeName?: string | undefined;
    module?: SetupLearningModuleLockUnlock[] | undefined;
    assesment?: any;
}

export interface SetupLearningModuleLockUnlock {
    moduleId?: number | undefined;
    moduleName?: string | undefined;
    isPublishedModule?: boolean | undefined;
}

export interface SetupModuleModuleViewModel {
    moduleId?: number | undefined;
    moduleName?: string | undefined;
    moduleDescription?: string | undefined;
}

export interface TimePointTaskModel {
    timePointId?: number | undefined;
    score?: number | undefined;
    time?: number | undefined;
    points?: number | undefined;
}

export interface CompetencySetupModel {
    competencyId?: number | undefined;
    prefixCode?: string | undefined;
    competencyTypeId?: number | undefined;
    competencyTypeName?: string | undefined;
}

export interface ModuleSetupModel {
    moduleId?: number | undefined;
    moduleName?: string | undefined;
}

export interface TaskCodeSetupModel {
    taskId?: number | undefined;
    competencyId?: number | undefined;
    evaluationTypeId?: number | undefined;
    competencyTypeId?: number | undefined;
    moduleId?: number | undefined;
    taskCode?: string | undefined;
    taskNumber?: number | undefined;
    prefixCode?: string | undefined;
    competencyTypeName?: string | undefined;
    evaluationTypeName?: string | undefined;
    moduleName?: string | undefined;
}

export interface SetupPopUpQuizCreateModel {
    quizTitle?: string | undefined;
    approvalId?: number | undefined;
    testTime?: number | undefined;
    isGrouping?: boolean | undefined;
    competencyId?: number | undefined;
    moduleId?: number | undefined;
    totalParticipant?: number | undefined;
    totalQuestion?: number | undefined;
    questionPerParticipant?: number | undefined;
    taskIds?: number[] | undefined;
}

export interface SetupPopQuizDetailModel {
    popQuizId?: number | undefined;
    quizTitle?: string | undefined;
    setupTaskId?: number | undefined;
    testTime?: number | undefined;
    isGrouping?: boolean | undefined;
    competencyId?: number | undefined;
    moduleId?: number | undefined;
    totalParticipant?: number | undefined;
    totalQuestion?: number | undefined;
    questionPerParticipant?: number | undefined;
    taskIds?: TaskCodeSetupModel[] | undefined;
}

export interface SetupPopQuizUpdateModel {
    popQuizId?: number | undefined;
    quizTitle?: string | undefined;
    approvalId?: number | undefined;
    testTime?: number | undefined;
    isGrouping?: boolean | undefined;
    competencyId?: number | undefined;
    moduleId?: number | undefined;
    totalParticipant?: number | undefined;
    totalQuestion?: number | undefined;
    questionPerParticipant?: number | undefined;
    taskIds?: number[] | undefined;
}

export interface SetupTimePointPaginate {
    data?: SetupTimePoint[] | undefined;
    totalData?: number | undefined;
}

export interface SetupTimePoint {
    timePointId?: number | undefined;
    pointTypeId?: number | undefined;
    pointTypeName?: string | undefined;
    time?: number | undefined;
    score?: number | undefined;
    points?: number | undefined;
    createdDate?: Date | undefined;
    updatedDate?: Date | undefined;
}

export interface SetupTimePointInsertModel {
    pointTypeId?: number | undefined;
    time?: number | undefined;
    score?: number | undefined;
    points?: number | undefined;
}

export interface SetupTop5CourseViewModel {
    listSetupTop5Course?: SetupTop5CourseJoinedModel[] | undefined;
    totalItem?: number | undefined;
}

export interface SetupTop5CourseJoinedModel {
    courseId?: number | undefined;
    trainingId?: number | undefined;
    courseName?: string | undefined;
    programTypeName?: string | undefined;
    createdBy?: string | undefined;
    date?: Date | undefined;
    top5Course?: number | undefined;
    isDeleted?: boolean | undefined;
    isPublished?: boolean | undefined;
    approvedAt?: Date | undefined;
    batch?: number | undefined;
}

export interface SetupTop5CourseDropdownList {
    courseNameDropdown?: SetupTop5CourseDropdownData[] | undefined;
}

export interface SetupTop5CourseDropdownData {
    courseId?: number | undefined;
    trainingId?: number | undefined;
    courseName?: string | undefined;
    isDeleted?: boolean | undefined;
    top5Course?: number | undefined;
    approvedAt?: Date | undefined;
    batch?: number | undefined;
}

export interface SurveyReportViewModel {
    surveyReportList?: SurveyReportModel[] | undefined;
    totalData?: number | undefined;
}

export interface SurveyReportModel {
    surveyId?: number | undefined;
    surveyTitle?: string | undefined;
    respondent?: number | undefined;
    respondentRate?: number | undefined;
    status?: string | undefined;
    startDate?: Date | undefined;
    endDate?: Date | undefined;
    urlDetail?: string | undefined;
}

export interface SurveysPaginate {
    data?: SurveysModel[] | undefined;
    totalData?: number | undefined;
}

export interface SurveysModel {
    surveyId?: number | undefined;
    title?: string | undefined;
    position?: string | undefined;
    outlet?: string | undefined;
    statusId?: number | undefined;
    status?: string | undefined;
    createdAt?: Date | undefined;
    updatedAt?: Date | undefined;
    isDeleted?: boolean | undefined;
}

export interface SurveyQuestionType {
    surveyQuestionTypeId?: number | undefined;
    name?: string | undefined;
}

export interface SurveyInitialize {
    surveyId?: number | undefined;
    title?: string | undefined;
    startDate?: Date | undefined;
    endDate?: Date | undefined;
    position?: PositionViewModel[] | undefined;
    outlet?: OutletViewModel[] | undefined;
    question?: SurveyQuestionGet[] | undefined;
    area?: AreaViewModel[] | undefined;
    province?: ProvinceViewModel[] | undefined;
    city?: CityViewModel[] | undefined;
    dealer?: DealerViewModel[] | undefined;
}

export interface SurveyQuestionGet {
    surveyQuestionId?: number | undefined;
    surveyQuestionTypeId?: number | undefined;
    questionNumber?: number | undefined;
    question?: string | undefined;
    blobId?: string | undefined;
    fileContent?: FileContent | undefined;
    fileName?: string | undefined;
    choice?: SurveyChoiceGet[] | undefined;
    matrixChoice?: SurveyMatrixModel | undefined;
    matchingChoices?: SurveyMatchingChoice | undefined;
}

export interface SurveyChoiceGet {
    surveyChoiceId?: number | undefined;
    choice?: string | undefined;
    blobId?: string | undefined;
    fileName?: string | undefined;
    fileContent?: FileContent | undefined;
}

export interface SurveyMatrixModel {
    matrixChoice?: SurveyMatrixChoicesModel[] | undefined;
    matrixQuestion?: SurveyMatrixQuestionsModel[] | undefined;
}

export interface SurveyMatchingChoice {
    leftChoices?: SurveyMatchingChoiceFormModel[] | undefined;
    rightChoices?: SurveyMatchingChoiceFormModel[] | undefined;
}

export interface SurveyMatrixChoicesModel {
    surveyMatrixChoiceId?: number | undefined;
    surveyQuestionId?: number | undefined;
    text?: string | undefined;
    number?: number | undefined;
}

export interface SurveyMatrixQuestionsModel {
    surveyMatrixQuestionId?: number | undefined;
    surveyQuestionId?: number | undefined;
    number?: number | undefined;
    question?: string | undefined;
}

export interface SurveyMatchingChoiceFormModel {
    type?: string | undefined;
    surveyMatchingChoiceId?: number | undefined;
    surveyMatchingChoiceCode: string;
    text?: string | undefined;
    blobId?: string | undefined;
    imageUpload?: FileContent | undefined;
}

export interface SurveyInsert {
    title?: string | undefined;
    startDate?: Date | undefined;
    endDate?: Date | undefined;
    position?: PositionViewModel[] | undefined;
    outlet?: OutletViewModel[] | undefined;
    question?: SurveyQuestion[] | undefined;
}

export interface SurveyQuestion {
    surveyQuestionTypeId?: number | undefined;
    questionNumber?: number | undefined;
    question?: string | undefined;
    blobId?: string | undefined;
    fileContent?: FileContent | undefined;
    choice?: SurveyChoice[] | undefined;
    matrixChoice?: SurveyMatrixModel | undefined;
    matchingChoices?: SurveyMatchingChoice | undefined;
}

export interface SurveyChoice {
    choice?: string | undefined;
    blobId?: string | undefined;
    fileContent?: FileContent | undefined;
}

export interface ModuleForTaskModel {
    moduleId?: number | undefined;
    moduleName?: string | undefined;
}

export interface TaskInsertModel {
    taskId?: number | undefined;
    competencyId?: number | undefined;
    questionTypeId?: number | undefined;
    moduleId?: number | undefined;
    blobId?: string | undefined;
    taskNumber?: number | undefined;
    layoutType?: number | undefined;
    storyLineDescription?: string | undefined;
    evaluationTypeId?: number | undefined;
    fileContent?: FileContent | undefined;
}

export interface TaskPaginationModel {
    taskData?: TaskViewModel[] | undefined;
    totalData?: number | undefined;
}

export interface TaskViewModel {
    taskCode?: string | undefined;
    questionTypeId?: number | undefined;
    moduleName?: string | undefined;
    createdBy?: string | undefined;
    createdAtDate?: Date | undefined;
    updateAtDate?: Date | undefined;
    updateAt?: string | undefined;
    createdAt?: string | undefined;
    taskId?: number | undefined;
}

export interface ChecklistCreateModel {
    task?: TaskModel | undefined;
    question?: string | undefined;
    choices?: ChecklistChoiceModel[] | undefined;
    fileContent?: FileContent | undefined;
}

export interface TaskModel {
    taskId?: number | undefined;
    competencyId?: number | undefined;
    questionTypeId?: number | undefined;
    moduleId?: number | undefined;
    blobId?: string | undefined;
    taskNumber?: number | undefined;
    layoutType?: number | undefined;
    storyLineDescription?: string | undefined;
    isDeleted?: boolean | undefined;
    createdAt?: Date | undefined;
    createdBy?: string | undefined;
    updatedAt?: Date | undefined;
    evaluationTypeId?: number | undefined;
}

export interface ChecklistChoiceModel {
    taskId?: number | undefined;
    number?: number | undefined;
    text?: string | undefined;
    isAnswer?: boolean | undefined;
    score?: number | undefined;
}

export interface ChecklistViewDetailModel {
    task?: TaskModel | undefined;
    question?: string | undefined;
    blobImageName?: string | undefined;
    blobImageFileType?: string | undefined;
    moduleName?: string | undefined;
    prefixCode?: string | undefined;
    competencyTypeId?: number | undefined;
    evaluationTypeId?: number | undefined;
    competencyTypeName?: string | undefined;
    evaluationTypeName?: string | undefined;
    choices?: ChecklistChoiceModel[] | undefined;
    totalScore?: number | undefined;
    totalPoint?: number | undefined;
}

export interface ChecklistUpdateModel {
    task?: TaskModel | undefined;
    question?: string | undefined;
    competencyTypeId?: number | undefined;
    choices?: ChecklistChoiceModel[] | undefined;
    fileContent?: FileContent | undefined;
}

export interface TaskEssayTypeFormModel {
    taskId?: number | undefined;
    competencyId?: number | undefined;
    questionTypeId?: number | undefined;
    moduleId?: number | undefined;
    blobId?: string | undefined;
    fileName?: string | undefined;
    mime?: string | undefined;
    taskNumber?: number | undefined;
    layoutType?: number | undefined;
    storyLineDescription?: string | undefined;
    isDeleted?: boolean | undefined;
    createdAt?: Date | undefined;
    createdBy: string;
    updatedAt?: Date | undefined;
    evaluationTypeId?: number | undefined;
    question: string;
    fileContent?: FileContent | undefined;
}

export interface TaskFileUploadFormModel {
    taskId?: number | undefined;
    competencyId?: number | undefined;
    questionTypeId?: number | undefined;
    moduleId?: number | undefined;
    blobId?: string | undefined;
    taskNumber?: number | undefined;
    layoutType?: number | undefined;
    storyLineDescription?: string | undefined;
    isDeleted?: boolean | undefined;
    createdAt?: Date | undefined;
    createdBy?: string | undefined;
    updatedAt?: Date | undefined;
    evaluationTypeId?: number | undefined;
    question?: string | undefined;
    fileContent?: FileContent | undefined;
}

export interface TaskFileUploadViewDetail {
    taskId?: number | undefined;
    question?: string | undefined;
    competencyId?: number | undefined;
    questionTypeId?: number | undefined;
    moduleId?: number | undefined;
    blobId?: string | undefined;
    taskNumber?: number | undefined;
    layoutType?: number | undefined;
    storyLineDescription?: string | undefined;
    isDeleted?: boolean | undefined;
    createdAt?: Date | undefined;
    createdBy?: string | undefined;
    updatedAt?: Date | undefined;
    evaluationTypeId?: number | undefined;
    competencyTypeName?: string | undefined;
    prefixCode?: string | undefined;
    evaluationTypeName?: string | undefined;
    moduleName?: string | undefined;
    name?: string | undefined;
    mime?: string | undefined;
    competencyTypeId?: number | undefined;
}

export interface TaskTebakGambarTypesModel {
    taskId?: number | undefined;
    question?: string | undefined;
    answer?: number | undefined;
    score?: number | undefined;
}

export interface TaskHotSpotAnswerModel {
    taskHotSpotAnswerId?: number | undefined;
    taskId?: number | undefined;
    number?: number | undefined;
    answer?: string | undefined;
    score?: number | undefined;
}

export interface TaskHotSpotModel {
    task?: TaskInsertModel | undefined;
    type?: TaskHotSpotTypeModel | undefined;
    choice?: TaskHotSpotAnswerModel[] | undefined;
}

export interface TaskHotSpotTypeModel {
    taskId?: number | undefined;
    blobId?: string | undefined;
    question?: string | undefined;
    fileContent?: FileContent | undefined;
}

export interface TaskMatchingTypeFormModel {
    taskId?: number | undefined;
    competencyId?: number | undefined;
    questionTypeId?: number | undefined;
    moduleId?: number | undefined;
    blobId?: string | undefined;
    fileName?: string | undefined;
    mime?: string | undefined;
    taskNumber?: number | undefined;
    layoutType?: number | undefined;
    storyLineDescription?: string | undefined;
    isDeleted?: boolean | undefined;
    createdAt?: Date | undefined;
    createdBy: string;
    updatedAt?: Date | undefined;
    evaluationTypeId?: number | undefined;
    question: string;
    answer: string;
    score?: number | undefined;
    imageUpload?: FileContent | undefined;
    taskMatchingChoices?: TaskMatchingChoiceFormModel[] | undefined;
}

export interface TaskMatchingChoiceFormModel {
    taskId?: number | undefined;
    taskMatchingChoiceId?: number | undefined;
    taskMatchingCode: string;
    text?: string | undefined;
    blobId?: string | undefined;
    fileName?: string | undefined;
    mime?: string | undefined;
    imageUpload?: FileContent | undefined;
}

export interface TaskMatrixTypeFormModel {
    taskId?: number | undefined;
    competencyId?: number | undefined;
    questionTypeId?: number | undefined;
    moduleId?: number | undefined;
    blobId?: string | undefined;
    fileName?: string | undefined;
    mime?: string | undefined;
    taskNumber?: number | undefined;
    layoutType?: number | undefined;
    storyLineDescription?: string | undefined;
    isDeleted?: boolean | undefined;
    createdAt?: Date | undefined;
    createdBy: string;
    updatedAt?: Date | undefined;
    evaluationTypeId?: number | undefined;
    question: string;
    scoreColumn1?: number | undefined;
    scoreColumn2?: number | undefined;
    scoreColumn3?: number | undefined;
    scoreColumn4?: number | undefined;
    scoreColumn5?: number | undefined;
    taskMatrixChoices?: TaskMatrixChoiceFormModel[] | undefined;
    taskMatrixQuestions?: TaskMatrixQuestionFormModel[] | undefined;
    imageUpload?: FileContent | undefined;
}

export interface TaskMatrixChoiceFormModel {
    taskMatrixChoiceId?: number | undefined;
    taskId?: number | undefined;
    text: string;
    number?: number | undefined;
}

export interface TaskMatrixQuestionFormModel {
    taskId?: number | undefined;
    number?: number | undefined;
    question: string;
}

export interface TaskMultipleChoiceTypeModel {
    taskId?: number | undefined;
    answerId?: number | undefined;
    question?: string | undefined;
    score?: number | undefined;
}

export interface TaskMultipleChoiceModel {
    task?: TaskInsertModel | undefined;
    type?: TaskMultipleChoiceTypeModel | undefined;
    choice?: TaskMultipleChoiceChoiceModel[] | undefined;
}

export interface TaskMultipleChoiceChoiceModel {
    taskMultipleChoiceChoiceId?: number | undefined;
    taskId?: number | undefined;
    number?: number | undefined;
    text?: string | undefined;
}

export interface TaskRatingModel {
    task?: TaskInsertModel | undefined;
    type?: TaskRatingTypeModel | undefined;
    choice?: TaskRatingChoicesModel[] | undefined;
}

export interface TaskRatingTypeModel {
    taskId?: number | undefined;
    question?: string | undefined;
    score0To20?: number | undefined;
    score21To40?: number | undefined;
    score41To60?: number | undefined;
    score61To80?: number | undefined;
    score81To100?: number | undefined;
}

export interface TaskRatingChoicesModel {
    taskRatingChoiceId?: number | undefined;
    taskId?: number | undefined;
    number?: number | undefined;
    text?: string | undefined;
}

export interface SequenceCreateModel {
    task?: TaskModel | undefined;
    question: string;
    answer?: string | undefined;
    choices?: SequenceChoiceModel[] | undefined;
    fileContent?: FileContent | undefined;
}

export interface SequenceChoiceModel {
    taskSequenceChoiceId?: number | undefined;
    choiceNumber?: number | undefined;
    choiceText?: string | undefined;
    score?: number | undefined;
}

export interface SequenceViewDetailModel {
    task?: TaskModel | undefined;
    question?: string | undefined;
    answer?: string | undefined;
    blobImageName?: string | undefined;
    blobImageFileType?: string | undefined;
    moduleName?: string | undefined;
    prefixCode?: string | undefined;
    competencyTypeId?: number | undefined;
    evaluationTypeId?: number | undefined;
    competencyTypeName?: string | undefined;
    evaluationTypeName?: string | undefined;
    choices?: SequenceChoiceModel[] | undefined;
    totalScore?: number | undefined;
    totalPoint?: number | undefined;
}

export interface SequenceUpdateModel {
    task?: TaskModel | undefined;
    question: string;
    answer?: string | undefined;
    competencyTypeId?: number | undefined;
    choices?: SequenceChoiceModel[] | undefined;
    fileContent?: FileContent | undefined;
}

export interface TaskShortAnswerForm {
    taskId?: number | undefined;
    question: string;
    competencyId?: number | undefined;
    questionTypeId?: number | undefined;
    moduleId?: number | undefined;
    blobId?: string | undefined;
    taskNumber?: number | undefined;
    layoutType?: number | undefined;
    storyLineDescription?: string | undefined;
    isDeleted?: boolean | undefined;
    createdAt?: Date | undefined;
    createdBy?: string | undefined;
    updatedAt?: Date | undefined;
    evaluationTypeId?: number | undefined;
    fileContent?: FileContent | undefined;
}

export interface TaskShortAnswerViewDetail {
    taskId?: number | undefined;
    question?: string | undefined;
    competencyId?: number | undefined;
    questionTypeId?: number | undefined;
    moduleId?: number | undefined;
    blobId?: string | undefined;
    taskNumber?: number | undefined;
    layoutType?: number | undefined;
    storyLineDescription?: string | undefined;
    isDeleted?: boolean | undefined;
    createdAt?: Date | undefined;
    createdBy?: string | undefined;
    updatedAt?: Date | undefined;
    evaluationTypeId?: number | undefined;
    competencyTypeName?: string | undefined;
    prefixCode?: string | undefined;
    evaluationTypeName?: string | undefined;
    moduleName?: string | undefined;
    name?: string | undefined;
    mime?: string | undefined;
    competencyTypeId?: number | undefined;
}

export interface TaskTebakGambarPicturesModel {
    taskTebakGambarId?: number | undefined;
    taskId?: number | undefined;
    blobId?: string | undefined;
    number?: number | undefined;
    imageUpload?: FileContent | undefined;
}

export interface TaskTebakGambarModel {
    task?: TaskInsertModel | undefined;
    type?: TaskTebakGambarTypesModel | undefined;
    picture?: TaskTebakGambarPicturesModel[] | undefined;
}

export interface TrueFalseTypeViewDetails {
    layoutType?: number | undefined;
    blobId?: string | undefined;
    storyLineDescription?: string | undefined;
    competencyTypeName?: string | undefined;
    prefixCode?: string | undefined;
    evaluationTypeName?: string | undefined;
    taskNumber?: number | undefined;
    moduleName?: string | undefined;
    question?: string | undefined;
    answer?: boolean | undefined;
    name?: string | undefined;
    evaluationTypeId?: number | undefined;
    timePoint?: TimePointTaskModel | undefined;
    mime?: string | undefined;
    competencyId?: number | undefined;
    competencyTypeId?: number | undefined;
    moduleId?: number | undefined;
}

export interface TaskTrueFalseFormModel {
    taskId?: number | undefined;
    question: string;
    answer?: boolean | undefined;
    competencyId?: number | undefined;
    questionTypeId?: number | undefined;
    moduleId?: number | undefined;
    blobId?: string | undefined;
    taskNumber?: number | undefined;
    layoutType?: number | undefined;
    timePoint?: TimePointTaskModel | undefined;
    storyLineDescription?: string | undefined;
    evaluationTypeId?: number | undefined;
    fileContent?: FileContent | undefined;
}

export interface GridTopicModel {
    topics?: TopicViewModel[] | undefined;
    totalData?: number | undefined;
    totalDataFilter?: number | undefined;
}

export interface TopicViewModel {
    topicId?: number | undefined;
    topicName?: string | undefined;
    topicDesc?: string | undefined;
    eBadge?: number | undefined;
    minPoint?: number | undefined;
    createdAt?: string | undefined;
    updatedAt?: string | undefined;
}

export interface TopicCreateModel {
    topicName: string;
    topicDesc?: string | undefined;
    eBadge: number;
    minPoint: number;
    fileContent?: FileContent | undefined;
}

export interface TopicViewDetailModel {
    topicId?: number | undefined;
    topicName?: string | undefined;
    topicDesc?: string | undefined;
    eBadgeId?: number | undefined;
    minPoint?: number | undefined;
    blobId?: string | undefined;
    blobName?: string | undefined;
    blobFileType?: string | undefined;
}

export interface TopicUpdateModel {
    topicId?: number | undefined;
    topicName: string;
    topicDesc?: string | undefined;
    eBadge: number;
    minPoint: number;
    blobId?: string | undefined;
    blobName?: string | undefined;
    blobFileType?: string | undefined;
    fileContent?: FileContent | undefined;
}

export interface TopicCoachOptionModel {
    topicId?: number | undefined;
    topicName?: string | undefined;
    ebadgeId?: number | undefined;
    ebadgeName?: string | undefined;
}

export interface TopicEbadgeOptionModel {
    ebadgeId?: number | undefined;
    ebadgeName?: string | undefined;
}

export interface TrainingProcessViewModel {
    listTrainingProcess?: TrainingProcessModel[] | undefined;
    totalItem?: number | undefined;
}

export interface TrainingProcessModel {
    trainingId?: number | undefined;
    courseName?: string | undefined;
    programType?: string | undefined;
    batch?: number | undefined;
    confirmed?: number | undefined;
    quota?: number | undefined;
    trainingStartDate?: Date | undefined;
    trainingEndDate?: Date | undefined;
}

export interface TrainingProcessDetailViewModel {
    trainingProcessDetailList?: TrainingProcessDetailModel[] | undefined;
}

export interface TrainingProcessDetailModel {
    trainingInvitationId?: number | undefined;
    employeeName?: string | undefined;
    gender?: string | undefined;
    dealer?: string | undefined;
    outlet?: string | undefined;
    accommodation?: string | undefined;
    price?: number | undefined;
    dateofStayStart?: Date | undefined;
    dateofStayEnd?: Date | undefined;
    isJoined?: boolean | undefined;
    isConfirmed?: boolean | undefined;
}

export interface ReportTrainingScoreViewModel {
    listReportTrainingScore?: ReportTrainingScoreModel[] | undefined;
    totalData?: number | undefined;
}

export interface ReportTrainingScoreModel {
    trainingId?: number | undefined;
    courseName?: string | undefined;
    programType?: string | undefined;
    batch?: number | undefined;
    participant?: number | undefined;
    participantRate?: number | undefined;
    status?: string | undefined;
    startTime?: Date | undefined;
    endTime?: Date | undefined;
    urlDetail?: string | undefined;
}

export interface UserPrivilegeSettingsPaginateModel {
    data?: UserPrivilegeSettingsModel[] | undefined;
    totalData?: number | undefined;
}

export interface UserPrivilegeSettingsModel {
    privilegeSettingsId?: number | undefined;
    userRoleId?: number | undefined;
    userRole?: string | undefined;
    menuId?: string | undefined;
    menu?: string | undefined;
    pageId?: string | undefined;
    page?: string | undefined;
    create?: boolean | undefined;
    read?: boolean | undefined;
    update?: boolean | undefined;
    delete?: boolean | undefined;
    createdAt?: Date | undefined;
    updatedAt?: Date | undefined;
}

export interface UserPrivilegeSettingsUserRoleModel {
    userRoleId?: number | undefined;
    userRole?: string | undefined;
}

export interface UserPrivilegeSettingsMenuModel {
    menuId?: string | undefined;
    menu?: string | undefined;
}

export interface UserPrivilegeSettingsPageModel {
    pageId?: string | undefined;
    page?: string | undefined;
}

export interface UserPrivilegeSettingPageCRUD {
    isPageCheck?: boolean | undefined;
    pageId?: string | undefined;
    page?: string | undefined;
    menuId?: string | undefined;
    create?: boolean | undefined;
    read?: boolean | undefined;
    update?: boolean | undefined;
    delete?: boolean | undefined;
}

export interface UserPrivilegeSettingGetByUserId {
    userRoleId?: number | undefined;
    menuPage?: UserPrivilegeSettingPageCRUD[] | undefined;
}

export interface UserPrivilegeSettingsInsertModel {
    userRoleId?: number | undefined;
    pageId?: string | undefined;
    create?: boolean | undefined;
    read?: boolean | undefined;
    update?: boolean | undefined;
    delete?: boolean | undefined;
}

export interface UserAccessCRUD {
    create?: boolean | undefined;
    read?: boolean | undefined;
    update?: boolean | undefined;
    delete?: boolean | undefined;
}

export interface UserRoleGridModel {
    userRole?: UserRoleModelView[] | undefined;
    totalData?: number | undefined;
    totalDataFilter?: number | undefined;
}

export interface UserRoleModelView {
    userRoleId?: number | undefined;
    userRoleName?: string | undefined;
    typeOfPeople?: string | undefined;
    position?: PositionDropdownModel | undefined;
    category?: CategoryDropdownModel | undefined;
    createdAt?: Date | undefined;
    updatedAt?: Date | undefined;
}

export interface CategoryDropdownModel {
    categoryId?: string | undefined;
    categoryName?: string | undefined;
}

export interface UserRoleModelCreate {
    userRoleName: string;
    roleDescription?: string | undefined;
    typeOfPeople: boolean;
    position: PositionDropdownModel;
    dealerCategory?: CategoryDropdownModel | undefined;
    createdAt?: Date | undefined;
    updatedAt?: Date | undefined;
}

export interface UserRoleModelUpdate {
    userRoleId?: number | undefined;
    userRoleName: string;
    roleDescription?: string | undefined;
    typeOfPeople: boolean;
    position: PositionDropdownModel;
    dealerCategory?: CategoryDropdownModel | undefined;
    updatedAt?: Date | undefined;
}

export interface UserRoleDropdownModel {
    userRoleId?: number | undefined;
    userRoleName?: string | undefined;
}

export interface UserRoleModelViewDetail {
    userRoleId?: number | undefined;
    userRoleName?: string | undefined;
    roleDescription?: string | undefined;
    typeOfPeople?: boolean | undefined;
    position?: PositionDropdownModel | undefined;
    dealerCategory?: CategoryDropdownModel | undefined;
    updatedAt?: Date | undefined;
}

export interface UserSideBadgesViewModel {
    listBadgesGold?: UserSideBadgesModel[] | undefined;
    listBadgesSilver?: UserSideBadgesModel[] | undefined;
    listBadgesBronze?: UserSideBadgesModel[] | undefined;
}

export interface UserSideBadgesModel {
    employeeId?: string | undefined;
    eBadgesId?: number | undefined;
    eBadgesName?: string | undefined;
    topicId?: number | undefined;
    topicName?: string | undefined;
    topicDescription?: string | undefined;
}

export interface UserSideBannerModel {
    bannerId?: string | undefined;
    bannerTypeId?: string | undefined;
    bannerTypeName?: string | undefined;
    blobId?: string | undefined;
    imageUrl?: string | undefined;
    name?: string | undefined;
    createdDate?: Date | undefined;
    startDate?: Date | undefined;
    endDate?: Date | undefined;
    mobilePageId?: number | undefined;
    mobilePageRoute?: string | undefined;
    contentId?: string | undefined;
    description?: string | undefined;
    approvedAt?: Date | undefined;
    trainingId?: number | undefined;
    courseId?: number | undefined;
    setupModuleId?: number | undefined;
    popQuizId?: number | undefined;
}

export interface UserSideCertificateModel {
    title?: string | undefined;
    employeeCertificateId?: number | undefined;
    type?: string | undefined;
    eventDate?: Date | undefined;
    trainingName?: string | undefined;
    host?: string | undefined;
    venue?: string | undefined;
    imageUrl?: string | undefined;
    fileName?: string | undefined;
    contentType?: string | undefined;
    assesmentId?: number | undefined;
}

export interface UserSideCoachResponseModel {
    coachList?: UserSideCoachModel[] | undefined;
    totalData?: number | undefined;
}

export interface UserSideCoachModel {
    coachId?: number | undefined;
    coachIsActive?: number | undefined;
    employeeId?: string | undefined;
    imageUrl?: string | undefined;
    employeeName?: string | undefined;
    coachTopics?: UserSideTopicModel[] | undefined;
    totalBadge?: UserSideTotalBadgeModel | undefined;
}

export interface UserSideTopicModel {
    topicId?: number | undefined;
    topicName?: string | undefined;
    ebadgesId?: number | undefined;
    blobId?: string | undefined;
}

export interface UserSideTotalBadgeModel {
    gold?: number | undefined;
    silver?: number | undefined;
    bronze?: number | undefined;
}

export interface UserSideCoachScheduleBookingModel {
    coachId?: number | undefined;
    employeeid?: string | undefined;
    imageUrl?: string | undefined;
    employeeName?: string | undefined;
    totalBadge?: UserSideTotalBadgeModel | undefined;
    scheduleList?: UserSideCoachScheduleViewModel[] | undefined;
}

export interface UserSideCoachScheduleViewModel {
    coachId?: number | undefined;
    coachScheduleId?: number | undefined;
    scheduleName?: string | undefined;
    startDateTime?: Date | undefined;
    endDateTime?: Date | undefined;
    isBooked?: boolean | undefined;
}

export interface UserSideMyTeamFilterListModel {
    outlets?: UserSideOutletFilterListModel[] | undefined;
    positions?: UserSidePositionFilterListModel[] | undefined;
}

export interface UserSideOutletFilterListModel {
    filterId?: string | undefined;
    filterName?: string | undefined;
}

export interface UserSidePositionFilterListModel {
    filterId?: string | undefined;
    filterName?: string | undefined;
}

export interface UserSideMyRankFilterListModel {
    area?: UserSideAreaFilterListModel[] | undefined;
    position?: UserSidePositionFilterListModel[] | undefined;
    dealer?: UserSideDealerFilterListModel[] | undefined;
}

export interface UserSideAreaFilterListModel {
    filterId?: string | undefined;
    filterName?: string | undefined;
}

export interface UserSideDealerFilterListModel {
    filterId?: string | undefined;
    filterName?: string | undefined;
}

export interface UserSideGeneralFilterListModel {
    outlets?: UserSideOutletFilterListModel[] | undefined;
    areas?: UserSideAreaFilterListModel[] | undefined;
    dealers?: UserSideDealerFilterListModel[] | undefined;
    provinces?: UserSideProvinceFilterListModel[] | undefined;
    cities?: UserSideCityFilterListModel[] | undefined;
    position?: UserSidePositionFilterListModel[] | undefined;
}

export interface UserSideProvinceFilterListModel {
    filterId?: string | undefined;
    filterName?: string | undefined;
}

export interface UserSideCityFilterListModel {
    filterId?: string | undefined;
    filterName?: string | undefined;
}

export interface UserSideMyLearningFilterListModel {
    programTypes?: UserSideProgramTypeFilterListModel[] | undefined;
    learningTypes?: UserSideLearningTypeFilterListModel[] | undefined;
    materialTypes?: UserSideMaterialTypeFilterListModel[] | undefined;
    pricing?: UserSidePricingTypeFilterListModel[] | undefined;
}

export interface UserSideProgramTypeFilterListModel {
    filterId?: number | undefined;
    filterName?: string | undefined;
}

export interface UserSideLearningTypeFilterListModel {
    filterId?: number | undefined;
    filterName?: string | undefined;
}

export interface UserSideMaterialTypeFilterListModel {
    filterId?: number | undefined;
    filterName?: string | undefined;
}

export interface UserSidePricingTypeFilterListModel {
    filterId?: number | undefined;
    filterName?: string | undefined;
}

export interface UserSideMyNewsFilterListModel {
    internalExternal?: UserSideNewsInternalExternalFilterListModel[] | undefined;
    newsCategories?: UserSideNewsCategoriesFilterListModel[] | undefined;
}

export interface UserSideNewsInternalExternalFilterListModel {
    filterId?: number | undefined;
    filterName?: string | undefined;
}

export interface UserSideNewsCategoriesFilterListModel {
    filterId?: number | undefined;
    filterName?: string | undefined;
}

export interface UserSideMyEventFilterListModel {
    eventCategory?: UserSideEventCategoryFilterListModel[] | undefined;
}

export interface UserSideEventCategoryFilterListModel {
    filterId?: number | undefined;
    filterName?: string | undefined;
}

export interface UserSideMyCoachFilterListModel {
    ebadges?: UserSideEBadgesFilterListModel[] | undefined;
    topics?: UserSideTopicFilterListModel[] | undefined;
}

export interface UserSideEBadgesFilterListModel {
    filterId?: number | undefined;
    filterName?: string | undefined;
}

export interface UserSideTopicFilterListModel {
    filterId?: number | undefined;
    filterName?: string | undefined;
}

export interface UserSideHobbyModel {
    hobbyId?: number | undefined;
    name?: string | undefined;
    description?: string | undefined;
}

export interface UserSideInboxModel {
    inboxId?: number | undefined;
    inboxTypeId?: number | undefined;
    inboxTypeName?: string | undefined;
    employeeId?: string | undefined;
    employeeName?: string | undefined;
    title?: string | undefined;
    message?: string | undefined;
    notes?: string | undefined;
    employeeResign?: UserSideEmployeeResignModel | undefined;
    rotateTeamMemberRequest?: UserSideTeamMemberRotationRequestModel | undefined;
    teamMemberRequest?: UserSideTeamMemberRequestModel | undefined;
    isRead?: boolean | undefined;
    fromImageUrl?: string | undefined;
    fromName?: string | undefined;
    createdAt?: Date | undefined;
}

export interface UserSideEmployeeResignModel {
    employeeId?: string | undefined;
    name?: string | undefined;
    positionName?: string | undefined;
    outletName?: string | undefined;
    teamLeaderName?: string | undefined;
    imageUrl?: string | undefined;
}

export interface UserSideTeamMemberRotationRequestModel {
    rotateTeamMemberId?: number | undefined;
    employeeId?: string | undefined;
    employeeName?: string | undefined;
    previousTeamId?: number | undefined;
    previousTeamLeaderId?: string | undefined;
    previousTeamLeaderName?: string | undefined;
    previousTeamLeaderOutletName?: string | undefined;
    nextTeamId?: number | undefined;
    nextTeamLeaderId?: string | undefined;
    nextTeamLeaderName?: string | undefined;
    approvalStatus?: string | undefined;
    imageUrl?: string | undefined;
}

export interface UserSideTeamMemberRequestModel {
    teamMemberRequestId?: number | undefined;
    employeeId?: string | undefined;
    employeeName?: string | undefined;
    teamId?: number | undefined;
    teamLeaderId?: string | undefined;
    teamLeaderName?: string | undefined;
    imageUrl?: string | undefined;
    approvalStatus?: string | undefined;
    positionName?: string | undefined;
    outletName?: string | undefined;
}

export interface UserSideUpdateStatusRequestRotationModel {
    rotateTeamMemberId?: number | undefined;
    status?: number | undefined;
}

export interface UserSideUpdateStatusRequestTeamMemberModel {
    requestTeamMemberId?: number | undefined;
    status?: number | undefined;
}

export interface UserSideInterestModel {
    topicId?: number | undefined;
    topicName?: string | undefined;
    topicDescription?: string | undefined;
}

export interface UserSideLearningHistoryResponseModel {
    employeeId?: string | undefined;
    learnings?: UserSideLearningHistoryModel[] | undefined;
    totalData?: number | undefined;
}

export interface UserSideLearningHistoryModel {
    courseId?: number | undefined;
    courseName?: string | undefined;
    learningHistoryId?: number | undefined;
    learningHistoryName?: string | undefined;
    setupModuleId?: number | undefined;
    ratingScore?: number | undefined;
    setupCourseApprovedAt?: Date | undefined;
    imageUrl?: string | undefined;
    createdAt?: Date | undefined;
    trainingId?: number | undefined;
}

export interface UserSideDetailLearningHistoryModel {
    employeeId?: string | undefined;
    courseId?: number | undefined;
    courseName?: string | undefined;
    modules?: UserSideModuleLearningHistoryModel[] | undefined;
}

export interface UserSideModuleLearningHistoryModel {
    moduleId?: number | undefined;
    moduleName?: string | undefined;
    evaluations?: UserSideEvaluationLearningHistoryModel[] | undefined;
}

export interface UserSideEvaluationLearningHistoryModel {
    evaluationTypeId?: number | undefined;
    evaluationTypeName?: string | undefined;
    evaluationScore?: number | undefined;
}

export interface UserSideLearningHistoryFilterValueModel {
    programTypes?: UserSideLearningHistoryFilterValueTypeModel[] | undefined;
    learningTypes?: UserSideLearningHistoryFilterValueTypeModel[] | undefined;
    materialTypes?: UserSideLearningHistoryFilterValueTypeModel[] | undefined;
}

export interface UserSideLearningHistoryFilterValueTypeModel {
    id?: number | undefined;
    name?: string | undefined;
}

export interface UserSideLoginReturnModel {
    employeeId?: string | undefined;
    email?: string | undefined;
    name?: string | undefined;
    position?: UserSidePositionModel[] | undefined;
    isCoach?: boolean | undefined;
    isTeamLeader?: boolean | undefined;
    talentToken?: string | undefined;
}

export interface UserSidePositionModel {
    positionId?: number | undefined;
    positionName?: string | undefined;
    positionDescription?: string | undefined;
}

export interface MainPageModel {
    savedEventList?: SingleViewEventModel[] | undefined;
    recomendEventList?: SingleViewEventModel[] | undefined;
    popularEventList?: SingleViewEventModel[] | undefined;
}

export interface SingleViewEventModel {
    eventId?: number | undefined;
    imageUrl?: string | undefined;
    title?: string | undefined;
    description?: string | undefined;
    location?: string | undefined;
    startDate?: Date | undefined;
    endDate?: Date | undefined;
    startTime?: string | undefined;
    endTime?: string | undefined;
    isJoin?: boolean | undefined;
    isSave?: boolean | undefined;
}

export interface MyEventFormModel {
    eventId?: number | undefined;
    name?: string | undefined;
    categoryId?: number | undefined;
    location?: string | undefined;
    outletId?: string | undefined;
    description?: string | undefined;
    startDate?: Date | undefined;
    endDate?: Date | undefined;
    startTimeString?: string | undefined;
    endTimeString?: string | undefined;
    host?: string | undefined;
}

export interface DropDownStringModel {
    id?: string | undefined;
    name?: string | undefined;
}

export interface DropdownWithImage {
    id?: string | undefined;
    name?: string | undefined;
    imageUrl?: string | undefined;
}

export interface EventAttendModel {
    eventId?: number | undefined;
    type?: string | undefined;
    value?: boolean | undefined;
}

export interface UserSideMyGuideAPIModel {
    getStarted?: UserSideMyGuideModel[] | undefined;
    findYourPath?: UserSideMyGuideModel[] | undefined;
    buildYourExpertise?: UserSideMyGuideModel[] | undefined;
    growYourCareer?: UserSideMyGuideModel[] | undefined;
    connectWithPeople?: UserSideMyGuideModel[] | undefined;
    rewardAndRecognition?: UserSideMyGuideModel[] | undefined;
    tutorial?: UserSideMyGuideModel[] | undefined;
}

export interface UserSideMyGuideModel {
    guideName?: string | undefined;
    description?: string | undefined;
    guideTypeId?: number | undefined;
    guideType?: string | undefined;
    imageURL?: string | undefined;
}

export interface UserSideTutorialGuideModel {
    title?: string | undefined;
    description?: string | undefined;
    imageUrl?: string | undefined;
}

export interface UserSideMyInsightModel {
    surveyId?: number | undefined;
    surveyTitle?: string | undefined;
    surveyDueDate?: Date | undefined;
}

export interface SurveyAnswerInsertModel {
    surveyId?: number | undefined;
    answer?: SurveyAnswerDetailModel[] | undefined;
}

export interface SurveyAnswerDetailModel {
    questionTypeId?: number | undefined;
    surveyQuestionId?: number | undefined;
    file?: SurveyAnswerFileModel | undefined;
    answer?: string | undefined;
    special?: SurveySpecialAnswerDetailModel[] | undefined;
}

export interface SurveyAnswerFileModel {
    fileName?: string | undefined;
    contextType?: string | undefined;
    base64String?: string | undefined;
}

export interface SurveySpecialAnswerDetailModel {
    number?: number | undefined;
    answer?: string | undefined;
}

export interface UserSideCourseViewModel {
    trainingName?: string | undefined;
    programTypeName?: string | undefined;
    topicName?: string[] | undefined;
    duration?: number | undefined;
    points?: number | undefined;
    rating?: number | undefined;
    price?: number | undefined;
    imageUrl?: string | undefined;
    batch?: number | undefined;
    startDate?: Date | undefined;
    endDate?: Date | undefined;
    createdAt?: Date | undefined;
    updatedAt?: Date | undefined;
    isQueue?: boolean | undefined;
    isEnroll?: boolean | undefined;
    isJoined?: boolean | undefined;
    isAllowEnroll?: boolean | undefined;
    isPassed?: boolean | undefined;
    remedialLevel?: number | undefined;
}

export interface UserSideModuleViewModel {
    imageUrl?: string | undefined;
    points?: number | undefined;
    moduleName?: string | undefined;
    materialTypeName?: string | undefined;
    moduleDescription?: string | undefined;
    topicNames?: string[] | undefined;
    duration?: number | undefined;
    isQueue?: boolean | undefined;
    isEnroll?: boolean | undefined;
}

export interface UserSideMyLearningHomepageCourseModel {
    trainingId?: number | undefined;
    courseId?: number | undefined;
    setupModuleId?: number | undefined;
    trainingBatch?: number | undefined;
    imageUrl?: string | undefined;
    trainingName?: string | undefined;
    rating?: number | undefined;
    programTypeName?: string | undefined;
    materialTypeName?: string | undefined;
    startDate?: Date | undefined;
    endDate?: Date | undefined;
    createdAt?: Date | undefined;
    updatedAt?: Date | undefined;
    approvedAt?: Date | undefined;
    percentage?: number | undefined;
}

export interface UserSidePopQuizModel {
    popQuizId?: number | undefined;
    popQuizName?: string | undefined;
    createdAt?: Date | undefined;
    testTime?: number | undefined;
}

export interface TaskAnswerInsertModel {
    setupModuleId?: number | undefined;
    trainingId?: number | undefined;
    popQuizId?: number | undefined;
    answer?: TaskAnswerDetailModel[] | undefined;
}

export interface TaskAnswerDetailModel {
    questionTypeId?: number | undefined;
    taskId?: number | undefined;
    file?: TaskAnswerFileModel | undefined;
    answer?: string | undefined;
    score?: number | undefined;
    point?: number | undefined;
    isCheck?: boolean | undefined;
    isTrue?: boolean | undefined;
    special?: TaskSpecialAnswerDetailModel[] | undefined;
}

export interface TaskAnswerFileModel {
    fileName?: string | undefined;
    contextType?: string | undefined;
    base64String?: string | undefined;
}

export interface TaskSpecialAnswerDetailModel {
    number?: number | undefined;
    answer?: string | undefined;
    score?: number | undefined;
    point?: number | undefined;
    isTrue?: boolean | undefined;
}

export interface UserSideMyLearningHomepageModuleModel {
    setupModuleId?: number | undefined;
    imageUrl?: string | undefined;
    moduleName?: string | undefined;
    materialTypeName?: string | undefined;
    approvedAt?: Date | undefined;
}

export interface UserSideMyLearningHomepageCourseBadgeModelNew {
    trainingId?: number | undefined;
    trainingBatch?: number | undefined;
    setupModuleId?: number | undefined;
    courseId?: number | undefined;
    imageUrl?: string | undefined;
    trainingName?: string | undefined;
    rating?: number | undefined;
    programTypeName?: string | undefined;
    bronzeBadge?: number | undefined;
    silverBadge?: number | undefined;
    goldBadge?: number | undefined;
    startDate?: Date | undefined;
    endDate?: Date | undefined;
    createdAt?: Date | undefined;
    updatedAt?: Date | undefined;
}

export interface UserSideCourseOverviewModel {
    courseDesc?: string | undefined;
    learningObjs?: string[] | undefined;
    prerequisites?: UserSidePrerequisiteModel[] | undefined;
}

export interface UserSidePrerequisiteModel {
    trainingId?: number | undefined;
    setupModuleId?: number | undefined;
    moduleName?: string | undefined;
    courseId?: number | undefined;
    courseName?: string | undefined;
}

export interface UserSideCourseTrainingViewModel {
    trainingTypeName?: string | undefined;
    minScore?: number | undefined;
    workloadReq?: string | undefined;
    percentage?: number | undefined;
}

export interface UserSideCourseCoachViewModel {
    coachId?: number | undefined;
    coachName?: string | undefined;
    imageUrl?: string | undefined;
}

export interface UserSideCourseLikePeopleListModel {
    employeeId?: string | undefined;
    employeeName?: string | undefined;
    position?: string | undefined;
    imageUrl?: string | undefined;
}

export interface UserSideCourseLikePeopleSampleImage {
    imageUrl?: string[] | undefined;
    count?: number | undefined;
}

export interface UserSideWhoTookTheCourseSampleImage {
    imageUrl?: string[] | undefined;
    count?: number | undefined;
}

export interface UserSidePeopleWhoTookTheCourseListModel {
    employeeId?: string | undefined;
    employeeName?: string | undefined;
    position?: string | undefined;
    imageUrl?: string | undefined;
}

export interface ModuleContentViewModel {
    setupModuleId?: number | undefined;
    moduleId?: number | undefined;
    contentName?: string | undefined;
    moduleType?: string | undefined;
    imageUrl?: string | undefined;
    moduleTimeLength?: number | undefined;
    moduleTotalPoints?: number | undefined;
    startTime?: Date | undefined;
    endTime?: Date | undefined;
    isEnrolled?: boolean | undefined;
    isAvailable?: boolean | undefined;
    isPublished?: boolean | undefined;
    moduleStartTime?: Date | undefined;
    moduleEndTime?: Date | undefined;
    isLast?: boolean | undefined;
}

export interface CourseReviewViewModel {
    review?: string | undefined;
    imageUrl?: string | undefined;
}

export interface TeamMemberAssignModel {
    employeeId?: string[] | undefined;
    trainingId?: number | undefined;
    setupModuleId?: number | undefined;
}

export interface TeamMemberDetail {
    employeeId?: string | undefined;
    name?: string | undefined;
    position?: string | undefined;
    imageUrl?: string | undefined;
    iscChecked?: boolean | undefined;
    isValidAsignee?: boolean | undefined;
}

export interface GetModule {
    setupModuleId?: number | undefined;
    moduleName?: string | undefined;
    moduleDescription?: string | undefined;
    fileUrl?: string | undefined;
    fileName?: string | undefined;
    contentType?: string | undefined;
    rating?: number | undefined;
    point?: number | undefined;
    duration?: number | undefined;
    materialType?: string | undefined;
    minimumScore?: number | undefined;
    startTime?: Date | undefined;
    endTime?: Date | undefined;
    testTime?: number | undefined;
    isForRemedial?: boolean | undefined;
    isDownloadable?: boolean | undefined;
}

export interface CheckModuleStartModel {
    trainingId?: number | undefined;
    setupModuleId?: number | undefined;
}

export interface UserSideIsLearningPassModel {
    isPass?: boolean | undefined;
    certificateImageUrl?: string | undefined;
}

export interface ModuleScoreModel {
    setupModulId?: number | undefined;
    moduleName?: string | undefined;
    score?: number | undefined;
}

export interface UserSideMyPointModel {
    learningPoint?: number | undefined;
    teachingPoint?: number | undefined;
    totalPoint?: number | undefined;
}

export interface UserSideHistoryPointModel {
    learningPointHistories?: UserSideHistoryPointDetailModel[] | undefined;
    teachingPointHistories?: UserSideHistoryPointDetailModel[] | undefined;
    totalPointHistories?: UserSideHistoryPointDetailModel[] | undefined;
    currentLearningPoint?: number | undefined;
    currentTeachingPoint?: number | undefined;
    currentTotalPoint?: number | undefined;
}

export interface UserSideHistoryPointDetailModel {
    year?: number | undefined;
    rewardPointTypeId?: number | undefined;
    totalPoint?: number | undefined;
}

export interface UserSideRewardModel {
    rewardId?: number | undefined;
    rewardTypeId?: number | undefined;
    name?: string | undefined;
    startDate?: Date | undefined;
    endDate?: Date | undefined;
    rewardTypeName?: string | undefined;
    description?: string | undefined;
    termsAndConditions?: string | undefined;
    howToUse?: string | undefined;
    teachingPoint?: number | undefined;
    learningPoint?: number | undefined;
    totalPoint?: number | undefined;
}

export interface UserSideValidAddModel {
    ableToAdd?: boolean | undefined;
    nonTeamEmployees?: UserSideMyTeamEmployeeModel[] | undefined;
}

export interface UserSideMyTeamEmployeeModel {
    employeeId?: string | undefined;
    blobImageUrl?: string | undefined;
    positionName?: string | undefined;
    employeeName?: string | undefined;
    isWaitingApproval?: boolean | undefined;
    blobId?: string | undefined;
    mime?: string | undefined;
}

export interface UserSideNewsCategoryModel {
    newsCategoryId?: number | undefined;
    newsCategoryName?: string | undefined;
}

export interface UserSideNewsModel {
    newsId?: number | undefined;
    title?: string | undefined;
    description?: string | undefined;
    newsCategoryId?: number | undefined;
    newsCategoryName?: string | undefined;
    link?: string | undefined;
    author?: string | undefined;
    thumbnailUrl?: string | undefined;
    fileUrl?: string | undefined;
    isDownloadable?: boolean | undefined;
    totalView?: number | undefined;
    approvedAt?: Date | undefined;
    createdAt?: Date | undefined;
    updatedAt?: Date | undefined;
    isDeleted?: boolean | undefined;
}

export interface UserSidePersonalMappingModel {
    employeeId?: string | undefined;
    listHardCompetencyModel?: UserSideCompetencyMappingViewModel[] | undefined;
    listSoftCompetencyModel?: UserSideCompetencyMappingViewModel[] | undefined;
}

export interface UserSideCompetencyMappingViewModel {
    prefixCode?: string | undefined;
    competencyName?: string | undefined;
    competencyDescription?: string | undefined;
    competencyTypeName?: string | undefined;
    scoreTotal?: number | undefined;
    maxScoreTotal?: number | undefined;
    listKeyAction?: UsersideKeyactionViewModel[] | undefined;
}

export interface UsersideKeyactionViewModel {
    proficiencyLevel?: number | undefined;
    keyActionCode?: string | undefined;
    keyActionName?: string | undefined;
    keyActionDescription?: string | undefined;
    score?: number | undefined;
    maxScore?: number | undefined;
}

export interface ProfileViewModel {
    employee?: UserSideEmployeeModel | undefined;
    position?: UserSidePositionModel[] | undefined;
    outlet?: UserSideOutletModel | undefined;
    area?: UserSideAreaModel | undefined;
    province?: ProvinceViewModel2 | undefined;
    dealer?: UserSideDealerModel | undefined;
    hobbies?: UserSideHobbyModel[] | undefined;
    interests?: UserSideInterestModel[] | undefined;
    certificates?: UserSideCertificateModel[] | undefined;
    totalBadge?: UserSideTotalBadgeModel | undefined;
}

export interface UserSideEmployeeModel {
    employeeId?: string | undefined;
    imageUrl?: string | undefined;
    employeeUsername?: string | undefined;
    employeeName?: string | undefined;
    employeeEmail?: string | undefined;
    employeePhone?: string | undefined;
    nickname?: string | undefined;
    description?: string | undefined;
    dateOfBirth?: Date | undefined;
    gender?: string | undefined;
    isCoach?: boolean | undefined;
    coachId?: number | undefined;
    teamId?: number | undefined;
}

export interface UserSideOutletModel {
    outletId?: string | undefined;
    name?: string | undefined;
    phone?: string | undefined;
}

export interface UserSideAreaModel {
    areaId?: string | undefined;
    areaName?: string | undefined;
}

export interface ProvinceViewModel2 {
    provinceId?: string | undefined;
    provinceName?: string | undefined;
}

export interface UserSideDealerModel {
    dealerId?: string | undefined;
    dealerName?: string | undefined;
}

export interface UserSideInterestProfileFormModel {
    topicId?: number | undefined;
    topicName?: string | undefined;
    topicDescription?: string | undefined;
    isChecked?: boolean | undefined;
}

export interface UserSideHobbyProfileFormModel {
    hobbyId?: number | undefined;
    name?: string | undefined;
    description?: string | undefined;
    isChecked?: boolean | undefined;
}

export interface ProfileHomePage {
    employeeId?: string | undefined;
    employeeName?: string | undefined;
    employeeNickName?: string | undefined;
    isCoach?: boolean | undefined;
    imageUrl?: string | undefined;
    rankUser?: UserSideRankProfileHome | undefined;
}

export interface UserSideRankProfileHome {
    employeePoint?: number | undefined;
    level?: number | undefined;
    totalExperience?: number | undefined;
    rank?: number | undefined;
}

export interface ProfileRankModel {
    employeeId?: string | undefined;
    employeeName?: string | undefined;
    positionName?: string | undefined;
    name?: string | undefined;
    imageUrl?: string | undefined;
    employeePoint?: number | undefined;
    level?: number | undefined;
    totalExperience?: number | undefined;
    rank?: number | undefined;
    isLoggedInUser?: boolean | undefined;
    areaName?: string | undefined;
    dealerName?: string | undefined;
}

export interface UserSideRankModel {
    employeeId?: string | undefined;
    employeeName?: string | undefined;
    positionName?: string | undefined;
    name?: string | undefined;
    imageUrl?: string | undefined;
    employeePoint?: number | undefined;
    level?: number | undefined;
    totalExperience?: number | undefined;
    rank?: number | undefined;
    isLoggedInUser?: boolean | undefined;
    areaName?: string | undefined;
    dealerName?: string | undefined;
}

export interface UserSideCoachReviewModel {
    coachId?: number | undefined;
    coachName?: string | undefined;
    coachImageUrl?: string | undefined;
}

export interface UserSideTrainingReviewSubmitModel {
    trainingId?: number | undefined;
    ratingScore?: number | undefined;
    review?: string | undefined;
}

export interface UserSideCoachReviewSubmitModel {
    trainingId?: number | undefined;
    coachId?: number | undefined;
    ratingScore?: number | undefined;
    review?: string | undefined;
}

export interface LearningViewModel {
    trainingId?: number | undefined;
    courseId?: number | undefined;
    setupModuleId?: number | undefined;
    trainingBatch?: number | undefined;
    imageUrl?: string | undefined;
    trainingName?: string | undefined;
    rating?: number | undefined;
    programTypeName?: string | undefined;
    isPopular?: boolean | undefined;
    createdAt?: Date | undefined;
    updatedAt?: Date | undefined;
}

export interface CoachViewModel {
    coachId?: number | undefined;
    employeeId?: string | undefined;
    employeeName?: string | undefined;
    position?: string | undefined;
    imageUrl?: string | undefined;
    rating?: number | undefined;
    totalBadge?: UserSideTotalBadgeModel | undefined;
}

export interface PeopleViewModel {
    employeeId?: string | undefined;
    employeeName?: string | undefined;
    position?: string | undefined;
    imageUrl?: string | undefined;
}

export interface EventModel {
    eventId?: number | undefined;
    imageUrl?: string | undefined;
    description?: string | undefined;
    location?: string | undefined;
    startDate?: Date | undefined;
    endDate?: Date | undefined;
    startTime?: string | undefined;
    endTime?: string | undefined;
}

export interface NewsViewModel {
    newsId?: number | undefined;
    newsName?: string | undefined;
    newsUrl?: string | undefined;
    newsImageUrl?: string | undefined;
    newsFile?: string | undefined;
    newsDescription?: string | undefined;
    updatedAt?: Date | undefined;
}

export interface AreaModel {
    areaId?: string | undefined;
    areaName?: string | undefined;
}

export interface UserSideTeamModel {
    employeeId?: string | undefined;
    teamId?: number | undefined;
    imageUrl?: string | undefined;
    employeeName?: string | undefined;
    positionName?: string | undefined;
    statusContract?: string | undefined;
    isTeamLeader?: boolean | undefined;
    isRotated?: boolean | undefined;
    isAssign?: boolean | undefined;
}

export interface UserSideTeamResponseModel {
    listTeam?: UserSideTeamModel[] | undefined;
    totalData?: number | undefined;
}

export interface UserSideTeamFormModel {
    isRotated?: boolean | undefined;
    isChecked?: boolean | undefined;
    employeeId?: string | undefined;
}

export interface UserSideMyProfileCourseResponseModel {
    courses?: UserSideMyProfileCourseModel[] | undefined;
    totalData?: number | undefined;
}

export interface UserSideMyProfileCourseModel {
    trainingId?: number | undefined;
    courseId?: number | undefined;
    courseName?: string | undefined;
    imageUrl?: string | undefined;
    rating?: number | undefined;
    isAssign?: boolean | undefined;
}

export interface UserSideTeamMappingModel {
    listHardCompetencyModel?: UserSideTeamCompetencyMappingViewModel[] | undefined;
    listSoftCompetencyModel?: UserSideTeamCompetencyMappingViewModel[] | undefined;
}

export interface UserSideTeamCompetencyMappingViewModel {
    prefixCode?: string | undefined;
    competencyName?: string | undefined;
    competencyId?: number | undefined;
    competencyDescription?: string | undefined;
    competencyTypeId?: number | undefined;
    competencyTypeName?: string | undefined;
    scoreTotal?: number | undefined;
    maxScoreTotal?: number | undefined;
    listKeyAction?: UsersideTeamKeyactionViewModel[] | undefined;
}

export interface UsersideTeamKeyactionViewModel {
    positionId?: number | undefined;
    keyActionCode?: string | undefined;
    keyActionName?: string | undefined;
    keyActionDescription?: string | undefined;
    proficiencyLevel?: number | undefined;
    scoreSubTotal?: number | undefined;
    maxScoreSubTotal?: number | undefined;
    proficiencies?: UserSideTeamProficiencyViewModel[] | undefined;
}

export interface UserSideTeamProficiencyViewModel {
    employeeId?: string | undefined;
    imageUrl?: string | undefined;
    teamId?: number | undefined;
    possitionId?: number | undefined;
    score?: number | undefined;
    maxScore?: number | undefined;
}

export interface UserSideTimeTableResponseModel {
    timeTables?: UserSideTimeTableModel[] | undefined;
    totalData?: number | undefined;
}

export interface UserSideTimeTableModel {
    courseId?: number | undefined;
    courseName?: string | undefined;
    programTypeId?: number | undefined;
    programTypeName?: string | undefined;
    trainingId?: number | undefined;
    batch?: number | undefined;
    startDate?: Date | undefined;
    endDate?: Date | undefined;
    scheduleStatus?: string | undefined;
    isDeleted?: number | undefined;
    quota?: number | undefined;
    coursePrice?: number | undefined;
    updatedAt?: Date | undefined;
    positions?: UserSidePositionModel[] | undefined;
    outlets?: UserSideTimeTableOutletModel[] | undefined;
}

export interface UserSideTimeTableOutletModel {
    outletId?: string | undefined;
    outletName?: string | undefined;
    areaId?: string | undefined;
    areaName?: string | undefined;
    dealerId?: string | undefined;
    dealerName?: string | undefined;
}

export interface UserSideTimeTableFilterValueModel {
    areas?: UserSideAreaModel[] | undefined;
    dealers?: UserSideDealerModel[] | undefined;
    positions?: UserSidePositionModel[] | undefined;
    priceList?: number[] | undefined;
}

export interface UserSideTrainingModel {
    trainingId?: number | undefined;
    courseId?: number | undefined;
    courseName?: string | undefined;
    batch?: number | undefined;
    startDate?: Date | undefined;
    endDate?: Date | undefined;
    imageUrl?: string | undefined;
    approvedAt?: Date | undefined;
    listEmployeeTraining?: UserSideEmployeeTrainingModel[] | undefined;
}

export interface UserSideEmployeeTrainingModel {
    employeeId?: string | undefined;
    employeeName?: string | undefined;
    positionName?: string | undefined;
    imageUrl?: string | undefined;
    isEvaluate?: boolean | undefined;
    listQuestion?: UserSideEvaluateTraineeModel[] | undefined;
}

export interface UserSideEvaluateTraineeModel {
    questionNumber?: number | undefined;
    questionTypeId?: number | undefined;
    questionTypeName?: string | undefined;
    question?: string | undefined;
    taskId?: number | undefined;
    answer?: string | undefined;
    taskAnswerDetailId?: number | undefined;
}

export interface UserSideEvaluationModel {
    taskAnswerDetailId?: number | undefined;
    score?: number | undefined;
}

export interface UserSideTrainingProcessViewModel {
    imageUrl?: string | undefined;
    trainingInvId?: number | undefined;
    trainingName?: string | undefined;
    programType?: string | undefined;
    batch?: number | undefined;
    trainingStartDate?: Date | undefined;
    trainingEndDate?: Date | undefined;
    enrollDate?: Date | undefined;
    trainingStatus?: string | undefined;
    isRescheluded?: boolean | undefined;
    isConfirmed?: boolean | undefined;
    isRejected?: boolean | undefined;
    isAccommodate?: boolean | undefined;
}

export interface UserSideAcomodationListModel {
    id?: number | undefined;
    name?: string | undefined;
    price?: number | undefined;
    each?: number | undefined;
}

export interface UserSideTrainingProcessDetailModel {
    trainingInvId?: number | undefined;
    trainingId?: number | undefined;
    trainingName?: string | undefined;
    batch?: number | undefined;
    trainingStartDate?: Date | undefined;
    trainingEndDate?: Date | undefined;
    location?: string | undefined;
    trainingStatus?: string | undefined;
    isRescheluded?: boolean | undefined;
    isConfirmed?: boolean | undefined;
    isRejected?: boolean | undefined;
    employeeName?: string | undefined;
    employeePosition?: string | undefined;
    price?: number | undefined;
    accomodationList?: UserSideAcomodationListModel[] | undefined;
    needAccomodation?: boolean | undefined;
    selectedAccomodation?: number | undefined;
    stayStartDate?: Date | undefined;
    stayEndDate?: Date | undefined;
}

export interface UserSideTrainingProcessConfirmModel {
    trainingInvId?: number | undefined;
    answer?: string | undefined;
    needAccomodation?: boolean | undefined;
    accomodation?: UserSideAcomodationConfirmModel | undefined;
}

export interface UserSideAcomodationConfirmModel {
    id?: number | undefined;
    startTime?: Date | undefined;
    endTime?: Date | undefined;
}

export class ApiException extends Error {
    message: string;
    status: number; 
    response: string; 
    headers: { [key: string]: any; };
    result: any; 

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}